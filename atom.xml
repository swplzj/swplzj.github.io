<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    
    <title><![CDATA[Leo Lee]]></title>
    <link href="http://swplzj.github.io/atom.xml" rel="self"/>
    <link href="http://swplzj.github.io/"/>
    <updated>2016-02-04T18:06:48+08:00</updated>
    <id>http://swplzj.github.io/</id>
    <author>
        <name><![CDATA[Leo Lee]]></name>
        <email><![CDATA[swplzj@126.com]]></email>
    </author>
    <generator uri="http://octopress.org/">Octopress</generator>
    
    
    <entry>
        <title type="html"><![CDATA[2015年个人总结]]></title>
        <link href="http://swplzj.github.io/blog/2015/12/24/2015nian-ge-ren-zong-jie/"/>
        <updated>2015-12-24T16:44:16+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/12/24/2015nian-ge-ren-zong-jie</id>
        <content type="html"><![CDATA[<h2>2015年个人总结</h2>

<hr />

<p>2015年对我来说意义重大，人生中的几件大事都在今年发生了，顺其自然的发生了。。。</p>

<h3>关于技术&amp;职业</h3>

<p>年初跳槽来到目前这家公司，也是我做出的职业很重要的抉择，互联网金融行业虽然议论纷纷，数不清有多少家互联网公司跑路了，有包括最近的e租宝公司集团的倒塌。这个行业很浮躁，但是我还是坚信自己的选择，我们老大说过：做任何意见事情，都是有特定的时间窗口，比如目前的互联网金融，现在不做，等格局已定，你也没有可做的了。。。（大概意思^-^）。选择这家公司这个行业，和我目前的个人价值观很是相符。</p>

<p>这一年可以是说技术沉淀和个人自由的一年，我现在就是个小兵，不用关心任何的管理事项(当然管理好自己是很必要的:）)，自己专心做技术，到目前为止，做了四个项目，上线了两个，其实没有太大的挑战，自己私下专研的东西，很自由。每件事情都是有利有弊，对于个人而言，自己的影响力减少了很多，之前自己还带领十几人的团队，进行项目开发，现在作为专职 iOS 开发专心研发任务，和其他人打交道机会很少，当然，这是自己的选择，只不过，自己的进步还是不能令我满意，还需继续努力</p>

<h3>生活</h3>

<p>谈到生活，今年拍摄了婚纱照，美美哒，帅帅的，然后在十一月份完婚，还是双喜临门，有了小宝宝（婚后才知道的）。清楚地记得拍摄婚纱照时内心的喜悦和幸福，还有脸部肌肉的僵硬和劳累；清楚地记得迎娶新娘路上36个小时的惊险和心急等待；清楚地记得在那个特别、简单的婚礼——晚上才把新娘迎娶回家，感谢亲朋好友亲临婚礼的祝福；清楚地记得刚回到北京验出有小宝宝时那种不知该怎么应对的复杂心情；清楚地记得与自己合租了两年多的朋友分别的不舍；清楚地记得参加朋友婚礼时衷心地祝福；清楚地记得得知爸爸耳朵突然听不见了的心疼。。。
一年经历了种种，让我开始懂得生活和工作的权衡，还是罗列一下生活中发生的大事情吧。</p>

<ul>
<li>3月到新公司工作</li>
<li>5月买房</li>
<li>7月和朋友分居（呵呵）</li>
<li>8月拍摄婚纱照</li>
<li>11月完婚</li>
<li>9月有了小 baby（知道的有点晚）</li>
</ul>


<h3>有关爱好和习惯</h3>

<p>到目前为止，还是没有找到自己真正的兴趣爱好，突然感觉没有自己的兴趣，好像损失好多，这些年自己尝试过的东西很多，比如：健身房、跑步、游泳、花样轮滑、练钢笔字、弹吉他、练习钢琴、学习思维导图、学习应用、学习动画、学习一切令人振奋美好的东西，但问题来了，好像很少有坚持下来的东西，实践过之后，才发觉坚持的重要。工作长时间的坐着，自己都开始虚胖起来了，后期找事情给自己做，下午的时候，我坚持爬楼梯，爬楼梯的过程中也思考了很多东西，28层爬上爬下，运动过之后，身体特舒服。</p>

<p>有关习惯的培养，我想说下自己的见解。每天都有很多刺激刺激着我们，我们遇到的刺激我把他分为：新鲜刺激、弱刺激和强刺激。新鲜刺激就是我们生活中遇到让我们感觉很新鲜和美好的事物和事情，比如：第一次看到思维导图；弱刺激是指一些事情或事物对我们有一点点影响，没有那么强烈；比如：早上洗头；强刺激就是对本身产生强烈影响的事物或事情，比如：亲眼目睹他人没有遵守交规而发生重大交通事故；新鲜刺激其实对我们的影响甚微，没有起到成长的作用，最容易让人发生改变的强刺激，但是强刺激不是每天都有的。再说一下习惯，一个坏的习惯不可能被消灭，只能是用一个好的习惯来代替坏的习惯。其实，归根揭底，一个习惯的养成是建立在重复的弱刺激之上的，我也发现了这个规律。</p>

<p>今年影响我最大的习惯是：天天早上洗头。培养这个习惯是为了慢慢增强自己的自信，从一年的坚持来看，的确有效果，现在的自己能够有自己的想法，有自己的坚持，有自己的选择。</p>

<h2>总结</h2>

<p>见贤思齐焉，每当遇到那些比自己优秀的人，我都有感觉豪情万丈，这种情绪也是三天热度，通过一年的学习经历，发现自己身上缺少一种很重要的品质，就是坚持。所以，2016，我会 Focus 我的精力，去做那些真正想做的事情！！！
2016，我来了。</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[iOS 设备和 Mac 文件共享传输的几种方式]]></title>
        <link href="http://swplzj.github.io/blog/2015/11/18/ios-she-bei-he-mac-wen-jian-gong-xiang-chuan-shu-de-ji-chong-fang-shi/"/>
        <updated>2015-11-18T11:15:18+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/11/18/ios-she-bei-he-mac-wen-jian-gong-xiang-chuan-shu-de-ji-chong-fang-shi</id>
        <content type="html"><![CDATA[<p>相信大家都有过这样的经历：想实现共享 Mac 和 iPhone 上的文件，下面我粗略的总结了集中方式，和大家一起分享。
通过共享介质的不同可以分为：网络共享、蓝牙无线方式文件传输、数据线连接同步。</p>

<!--more-->


<h2>网络共享</h2>

<p>网络共享又分为局域网共享和互联网共享。</p>

<h3>局域网共享</h3>

<p>我们可以在 Mac 搭建一个临时服务器，通过移动设备访问浏览器，来浏览文件并保存文件，具体操作：</p>

<ol>
<li>Mac 要和 iPad 在同一局域网内；</li>
<li>打开 <code>Terminal</code>，切换到文件所在的目录；</li>
<li>输入 <code>python -m SimpleHTTPServer 8000</code>，利用 python 的 SimpleHTTPServer 模块直接在 Mac 上搭建一个 Web 服务器；</li>
<li>在 iPad 的 Safari 上访问 Mac 的 Web 服务器，点击 pdf 文件就可以打开了；如果 iPad 上装了 iBooks 应用，也可以保存到 iPad 上；</li>
</ol>


<p><code>优点：</code></p>

<p>可以很方便的将 PDF 文件同步到设备上浏览或保存；</p>

<p><code>缺点：</code></p>

<p>支持的文件类型也是非常有限，支持图片、PDF、TXT、Docx等文件类型。</p>

<h3>互联网共享</h3>

<p>这种方式最常见的是我们通过类似 QQ 的方式发送的移动设备上，这类型的应用还有百度云盘、iCloud、Dropbox等。</p>

<p><code>优点：</code></p>

<p>支持的文件格式类型比较多</p>

<p><code>缺点：</code></p>

<p>需要走网络，同步速度慢</p>

<p><code>补充</code></p>

<p>iOS 9.0 之后的备忘录也支持附件存储了，这和 Mac 上的 Note 同步起来简直效率利器，也是我平常最常用的。</p>

<h2>蓝牙无线方式文件传输</h2>

<p>这种方式常见的就是 AirDrop 传输，速度相当不错，非常方便。
值得一提的是 Handoff 功能，这个功能也是用到了蓝牙无线技术，Handoff 是 iOS8 新出的一个功能，当你的 iPhone、iPad、Mac 都打开蓝牙并处于同一个 WiFi 下，它可以在你的 iPhone、iPad 和 Mac 上自由切换未完成的邮件，未制作完的文档，未浏览完的网页，在有人拨打你的iPhone，你正在使用iPad，这时候就不需要放下iPad区接听电话，而可以直接在iPad上接听。</p>

<p><code>值得一说</code></p>

<p>如果你使用 Keynote 来演示，那么你不应该错过使用 iPhone 来作为 Keynote 遥控器，设置方法自己搜索一下，很方便。</p>

<h2>数据线连接同步</h2>

<p>这就需要使用设备管理工具了，我们通常使用的有 iTunes 和 iTools，这里不再赘述功能使用。</p>

<h2>写在最后</h2>

<p>大概就这些方式了，祝大家玩的愉快！</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[iOS - 工作中遇到的问题]]></title>
        <link href="http://swplzj.github.io/blog/2015/11/09/ios-gong-zuo-zhong-yu-dao-de-wen-ti/"/>
        <updated>2015-11-09T16:44:05+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/11/09/ios-gong-zuo-zhong-yu-dao-de-wen-ti</id>
        <content type="html"><![CDATA[<p>在做iOS项目的过程中，到了了一些值得记录下来的问题，以便回顾和帮助他人，跳过他人跌过的坑。</p>

<!--more-->


<h3>1. UITableViewCell 获取当前Cell的方法</h3>

<p>获取cell 的方法一般有两种：</p>

<ul>
<li><p><code>cellForRowAtIndexPath:</code></p>

<p>  利用 tableView 根据indexPath来回调方法，但是这种方法有个值得注意的地方，就是当要获取的cell不可见或者下标超出数组范围的时候，就返回nil；参照文档</p>

<pre><code class="`` ">  - (nullable __kindof UITableViewCell *)cellForRowAtIndexPath:(NSIndexPath *)indexPath;   // returns nil if cell is not visible or index path is out of range
</code></pre></li>
<li><p><code>tableView: cellForRowAtIndexPath:</code></p>

<p>  利用tableView 的代理方法，使用视图控制器来调用，这种调用的时候，也有点需要注意的地方，就是有可能会重绘Cell。</p></li>
</ul>


<h3>2. 获取Cell上textfield数据的方法</h3>

<p>好了，下面有个场景，在一个 tableView 上放置很多自定义 Cell ，cell 上又都有 textfield 输入框，页面最下面有保存按钮，现在问题来了（暂时不关心为什么有这样的需求，为什么使用tableView来显示），当用户在输入框中输入完成之后，滚动到下方，然后，上方cell上textfield的数据被清空了，很显然是Cell被重用了，那解决方法是什么呢。</p>

<p>后来想保存一个Cell数组，每次从这个cell数组中来取值，这时，需要用到上面提到的取Cell 的方法了，这种场景下应该使用哪种方法呢，使用第一种应该没有问题的，但是，有自定义cell需要用户选择值，比如复选按钮，单选按钮，从一个列表中选取项，选择时间等，这就要刷新tableView了，这时，问题又来了，我们需要临时保存用户操作的每一个选项值，最关键的是保存textfield上的值。
使用textfield的代理方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)textFieldDidEndEditing:(UITextField *)textField
</span><span class='line'>{
</span><span class='line'>    UCCustomerEditCell *cell = (UCCustomerEditCell *)[[textField superview] superview];
</span><span class='line'>    NSInteger row = [self.tableView indexPathForCell:cell].row;
</span><span class='line'>    // 根据下标来保存textField的输入值
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这种方法还是会有问题，在iOS7 和 iOS8、9上都是不一样的，就是因为cell里面的继承层级关系我们不是确定的，导致我们取到的不是我们想要的cell，更不要说cell的下标了，使用tag值也是不可取的，有种方法可以解决这个问题：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)textFieldDidEndEditing:(UITextField *)textField
</span><span class='line'>{
</span><span class='line'>    UIView *view = textField;
</span><span class='line'>    while (view != nil && ![view isKindOfClass:[UITableViewCell class]]) {
</span><span class='line'>        view = [view superview];
</span><span class='line'>    }   
</span><span class='line'>    UCCustomerEditCell *cell = (UCCustomerEditCell *)view;
</span><span class='line'>    NSInteger row = [self.tableView indexPathForCell:cell].row;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这种方法就是一次遍历父类视图，不清楚cell里面的视图关系，但是一直向上遍历父类view，肯定可以找到cell的。
接下来就是保存每个cell中textfield的值，刷新tableView时给重新赋值，这样就解决了这个问题。</p>

<p>欢迎进入我的博客<a href="http://swplzj.github.io">http://swplzj.github.io</a></p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Git-问题记录]]></title>
        <link href="http://swplzj.github.io/blog/2015/11/09/git-wen-ti-ji-lu/"/>
        <updated>2015-11-09T15:39:22+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/11/09/git-wen-ti-ji-lu</id>
        <content type="html"><![CDATA[<p>在做项目的过程中，遇到很多关于Git相关的问题，记录下来与大家分享，也便于自己回顾。</p>

<h4>介绍一个成功的 Git 分支模型</h4>

<p>当自己从 SVN 转到 Git 后，首先面临的就是创建Git项目，参照网上给出的Git 模型，来创建合理的分支，实际项目也是参照于下面这篇文章，创建了 master 和 develop 本地分支和远程分支，然后每个开发者都有自己的本地分支。</p>

<!--more-->


<p><a href="http://www.oschina.net/translate/a-successful-git-branching-model">参照Git模型</a></p>

<h4>搜索已执行的命令</h4>

<p> terminal 下, <code>control + r</code> 可以搜索已执行的命令，然后按 <code>ESC</code> ，回车</p>

<h4>配置用户名和邮箱</h4>

<p>全局的通过vim ~/.gitconfig来查看</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git config --global user.name "Your Name"
</span><span class='line'>gigit config --global user.email you@example.com</span></code></pre></td></tr></table></div></figure>


<p>局部的通过当前路径下的 .git/config文件来查看</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git config user.name "Your Name"
</span><span class='line'>git config user.email you@example.com</span></code></pre></td></tr></table></div></figure>


<p>修改最后一次提交的用户名和邮箱地址</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git commit --amend --author='Your Name &lt;you@example.com&gt;'
</span></code></pre></td></tr></table></div></figure>


<h4>Git使用gitignore建立项目过滤规则</h4>

<p> git中提供两种过滤机制，一种是全局过滤机制，即对所有的git都适用；另一种是针对某个项目使用的过滤规则。</p>

<p><code>问题:</code>
<code>.gitignore</code> 只适用于尚未添加到 <code>git</code> 库的文件。如果已经添加了，则需用 <code>git rm</code> 移除后再重新 <code>commit</code>。</p>

<h4>删除文件</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git rm -r .
</span><span class='line'>rm -rf HIFramework
</span><span class='line'>git rm HIFramework
</span><span class='line'>rm 'HIFramework'
</span><span class='line'>git commit -m 'delete'</span></code></pre></td></tr></table></div></figure>


<h4>远程仓库相关命令</h4>

<pre><code>检出仓库：$ git clone git://github.com/jquery/jquery.git

查看远程仓库：$ git remote -v

添加远程仓库：$ git remote add [name] [url]

删除远程仓库：$ git remote rm [name]

修改远程仓库：$ git remote set-url --push [name] [newUrl]

拉取远程仓库：$ git pull [remoteName] [localBranchName]

推送远程仓库：$ git push [remoteName] [localBranchName]

强制推送更改：$ git push --force origin master
</code></pre>

<p>如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git push origin test:master         // 提交本地test分支作为远程的master分支
</span><span class='line'>$ git push origin test:test              // 提交本地test分支作为远程的test分支</span></code></pre></td></tr></table></div></figure>


<h4>分支(branch)操作相关命令</h4>

<pre><code>查看本地分支：$ git branch -av
查看远程分支：$ git branch -r （如果还是看不到就先 git fetch origin 先）
创建本地分支：$ git branch [name] ----注意新分支创建后不会自动切换为当前分支
切换分支：$ git checkout [name]
创建新分支并立即切换到新分支：$ git checkout -b [name]
直接检出远程分支：$ git checkout -b [name] [remoteName] (如：git checkout -b myNewBranch origin/dragon)
删除分支：$ git branch -d [name] ---- -d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项
合并分支：$ git merge [name] ----将名称为[name]的分支与当前分支合并
合并最后的2个提交：$ git rebase -i HEAD~2 ---- 数字2按需修改即可（如果需提交到远端$ git push -f origin master 慎用！）
创建远程分支(本地分支push到远程)：$ git push origin [name]
删除远程分支：$ git push origin :heads/[name] 或 $ git push origin :[name] 
修改分支名称：git branch -m &lt;old_branch_name&gt; &lt;new_branch_name&gt;  
</code></pre>

<p>创建空的分支：(执行命令之前记得先提交你当前分支的修改，否则会被强制删干净没得后悔)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git symbolic-ref HEAD refs/heads/[name]
</span><span class='line'>$ rm .git/index
</span><span class='line'>$ git clean -fdx</span></code></pre></td></tr></table></div></figure>


<h4>版本(tag)操作相关命令</h4>

<pre><code>查看版本：$ git tag

创建版本：$ git tag [name]

删除版本：$ git tag -d [name]

查看远程版本：$ git tag -r

创建远程版本(本地版本push到远程)：$ git push origin [name]

删除远程版本：$ git push origin :refs/tags/[name]

合并远程仓库的tag到本地：$ git pull origin --tags

上传本地tag到远程仓库：$ git push origin --tags

创建带注释的tag：$ git tag -a [name] -m 'yourMessage'
</code></pre>

<h4>删除和回退</h4>

<pre><code>删除当前仓库内未受版本管理的文件：$ git clean -f

恢复仓库到上一次的提交状态：$ git reset --hard

回退所有内容到上一个版本：$ git reset HEAD^

回退a.py这个文件的版本到上一个版本：$ git reset HEAD^ a.py

回退到某个版本：$ git reset 057d 

将本地的状态回退到和远程的一样：$ git reset –hard origin/master  

向前回退到第3个版本：$ git reset –-soft HEAD~3

修改最后的提交日志：$ git commit --amend

也可以修改提交的用户名和Email：

git commit --amend --author='Your Name &lt;you@example.com&gt;'
</code></pre>

<h4>查看提交日志</h4>

<p>使用 $ git log &ndash;oneline &ndash;graph &ndash;name-status 既可以看到简介的日志信息，也可以看到改了哪些文件，一举两得：</p>

<p>暂时就是这么多了，持续更新中，待续。。。</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Git 在项目中的基本使用]]></title>
        <link href="http://swplzj.github.io/blog/2015/11/09/git-zai-xiang-mu-zhong-de-ji-ben-shi-yong/"/>
        <updated>2015-11-09T11:36:49+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/11/09/git-zai-xiang-mu-zhong-de-ji-ben-shi-yong</id>
        <content type="html"><![CDATA[<h3>Git 基础</h3>

<hr />

<h4>直接记录快照，而非差异比较</h4>

<p>Git 和其它版本控制系统（包括 Subversion 和近似工具）的主要差别在于 Git 对待数据的方法。 概念上来区分，其它大部分系统以文件变更列表的方式存储信息。 这类系统（CVS、Subversion、Perforce、Bazaar 等等）将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。</p>

<!--more-->


<p><code>存储每个文件与初始版本的差异</code></p>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_11_06_svn_work_flow.png"></p>

<p>Git 不按照以上方式对待或保存数据。 反之，Git 更像是把数据看作是对小型文件系统的一组快照。 每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 快照流。</p>

<p><code>存储项目随时间改变的快照</code></p>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_11_06_git_screenshot.png"></p>

<h4>近乎所有操作都是本地执行</h4>

<p>在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。
要浏览项目的历史，Git 不需外连到服务器去获取历史，然后再显示出来——它只需直接从本地数据库中读取。 你能立即看到项目历史。 如果你想查看当前版本与一个月前的版本之间引入的修改，Git 会查找到一个月前的文件做一次本地的差异计算，而不是由远程服务器处理或从远程服务器拉回旧版本文件再来本地处理。</p>

<h4>Git 保证完整性</h4>

<p>Git 中所有数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。 这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。 若你在传送过程中丢失信息或损坏文件，Git 就能发现。</p>

<p>Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来。 SHA-1 哈希看起来是这样：</p>

<pre><code>24b9da6552252987aa493b52f8696cd6d3b00373
</code></pre>

<p>Git 中使用这种哈希值的情况很多，你将经常看到这种哈希值。 实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。</p>

<h4>Git 一般只添加数据</h4>

<p>你执行的 Git 操作，几乎只往 Git 数据库中增加数据。 很难让 Git 执行任何不可逆操作，或者让它以任何方式清除数据。 同别的 VCS 一样，未提交更新时有可能丢失或弄乱修改的内容；但是一旦你提交快照到 Git 中，就难以再丢失数据，特别是如果你定期的推送数据库到其它仓库的话。</p>

<h4>三种状态</h4>

<p>Git 有三种状态，你的文件可能处于其中之一：已提交（committed）、已修改（modified）和已暂存（staged）。 已提交表示数据已经安全的保存在本地数据库中。 已修改表示修改了文件，但还没保存到数据库中。 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</p>

<p>由此引入 Git 项目的三个工作区域的概念：Git 仓库、工作目录以及暂存区域。</p>

<p><code>工作目录、暂存区域以及 Git 仓库</code></p>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_11_06_git_areas.png"></p>

<p>Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。</p>

<p>工作目录是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</p>

<p>暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。 有时候也被称作“索引”，不过一般说法还是叫暂存区域。</p>

<p>基本的 Git 工作流程如下：</p>

<ol>
<li><p>在工作目录中修改文件。</p></li>
<li><p>暂存文件，将文件的快照放入暂存区域。</p></li>
<li><p>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。</p></li>
</ol>


<h3>获取 Git 仓库</h3>

<hr />

<pre><code>$ git init
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git add *.c
</span><span class='line'>$ git add LICENSE
</span><span class='line'>$ git commit -m 'initial project version'</span></code></pre></td></tr></table></div></figure>


<h5>克隆现有的仓库</h5>

<pre><code>$ git clone https://github.com/libgit2/libgit2


$ git clone https://github.com/libgit2/libgit2 mylibgit
</code></pre>

<p>这将执行与上一个命令相同的操作，不过在本地创建的仓库名字变为 mylibgit。</p>

<h3>记录每次更新到仓库</h3>

<p>使用 Git 时文件的生命周期如下：</p>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_11_06_git_file_life_cycle.png"></p>

<h5>检查当前文件状态</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git status
</span><span class='line'>On branch master
</span><span class='line'>nothing to commit, working directory clean</span></code></pre></td></tr></table></div></figure>


<h5>跟踪新文件</h5>

<pre><code>$ git add README
</code></pre>

<h5>暂存已修改文件</h5>

<p> 要暂存这次更新，需要运行 git add 命令。 这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。</p>

<h5>状态简览</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git status -s
</span><span class='line'> M README
</span><span class='line'>MM Rakefile
</span><span class='line'>A  lib/git.rb
</span><span class='line'>M  lib/simplegit.rb
</span><span class='line'>?? LICENSE.txt</span></code></pre></td></tr></table></div></figure>


<p>新添加的未跟踪文件前面有 <code>??</code> 标记，新添加到暂存区中的文件前面有 <code>A</code> 标记，修改过的文件前面有 <code>M</code> 标记。 你可能注意到了 <code>M</code> 有两个可以出现的位置，出现在右边的 <code>M</code> 表示该文件被修改了但是还没放入暂存区，出现在靠左边的 <code>M</code> 表示该文件被修改了并放入了暂存区。</p>

<h5>忽略文件</h5>

<p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cat .gitignore
</span><span class='line'>*.[oa]
</span><span class='line'>*~</span></code></pre></td></tr></table></div></figure>


<p>第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。 第二行告诉 Git 忽略所有以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。 此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。 要养成一开始就设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。</p>

<p>文件 .gitignore 的格式规范如下：</p>

<pre><code>所有空行或者以 ＃ 开头的行都会被 Git 忽略。

可以使用标准的 glob 模式匹配。

匹配模式可以以（/）开头防止递归。

匹配模式可以以（/）结尾指定目录。

要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。
</code></pre>

<p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>星号（*）匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。 使用两个星号（*) 表示匹配任意中间目录，比如a/**/z 可以匹配 a/z, a/b/z 或 a/b/c/z等。</span></code></pre></td></tr></table></div></figure>


<p><code>Tip</code></p>

<p><code>GitHub</code> 有一个十分详细的针对数十种项目及语言的 <code>.gitignore</code> 文件列表，你可以在 <a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a> 找到它.</p>

<h5>查看已暂存和未暂存的修改</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git diff
</span><span class='line'>diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
</span><span class='line'>index 8ebb991..643e24f 100644
</span><span class='line'>--- a/CONTRIBUTING.md
</span><span class='line'>+++ b/CONTRIBUTING.md
</span><span class='line'>@@ -65,7 +65,8 @@ branch directly, things can get messy.
</span><span class='line'> Please include a nice description of your changes when you submit your PR;
</span><span class='line'> if we have to read the whole diff to figure out why you're contributing
</span><span class='line'> in the first place, you're less likely to get feedback and have your change
</span><span class='line'>-merged in.
</span><span class='line'>+merged in. Also, split your changes into comprehensive chunks if you patch is
</span><span class='line'>+longer than a dozen lines.
</span><span class='line'>
</span><span class='line'> If you are starting to work on a particular area, feel free to submit a PR
</span><span class='line'> that highlights your work in progress (and note in the PR title that it's</span></code></pre></td></tr></table></div></figure>


<p>git diff 将通过文件补丁的格式显示具体哪些行发生了改变。
此命令比较的是工作目录中当前文件和暂存区域快照之间的差异， 也就是修改之后还没有暂存起来的变化内容。</p>

<p>若要查看已暂存的将要添加到下次提交里的内容，可以用 git diff &ndash;cached 命令。（Git 1.6.1 及更高版本还允许使用 git diff &ndash;staged，效果是相同的，但更好记些。）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git diff --staged
</span><span class='line'>diff --git a/README b/README
</span><span class='line'>new file mode 100644
</span><span class='line'>index 0000000..03902a1
</span><span class='line'>--- /dev/null
</span><span class='line'>+++ b/README
</span><span class='line'>@@ -0,0 +1 @@
</span><span class='line'>+My Project</span></code></pre></td></tr></table></div></figure>


<h5>提交更新</h5>

<p>默认的提交消息包含最后一次运行 git status 的输出，放在注释行里，另外开头还有一空行，供你输入提交说明。 退出编辑器时，Git 会丢掉注释行，用你输入提交附带信息生成一次提交。另外，你也可以在 commit 命令后添加 -m 选项，将提交信息与命令放在同一行。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git commit -m "Story 182: Fix benchmarks for speed"
</span><span class='line'>[master 463dc4f] Story 182: Fix benchmarks for speed
</span><span class='line'> 2 files changed, 2 insertions(+)
</span><span class='line'> create mode 100644 README</span></code></pre></td></tr></table></div></figure>


<h5>跳过使用暂存区域</h5>

<p>Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git status
</span><span class='line'>On branch master
</span><span class='line'>Changes not staged for commit:
</span><span class='line'>  (use "git add &lt;file&gt;..." to update what will be committed)
</span><span class='line'>  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)
</span><span class='line'>
</span><span class='line'>    modified:   CONTRIBUTING.md
</span><span class='line'>
</span><span class='line'>no changes added to commit (use "git add" and/or "git commit -a")
</span><span class='line'>$ git commit -a -m 'added new benchmarks'
</span><span class='line'>[master 83e38c7] added new benchmarks
</span><span class='line'> 1 file changed, 5 insertions(+), 0 deletions(-)</span></code></pre></td></tr></table></div></figure>


<h5>移除文件</h5>

<p>要从 <code>Git</code> 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 可以用 <code>git rm</code> 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p>

<p>如果只是简单地从工作目录中手工删除文件，运行 <code>git status</code> 时就会在 “Changes not staged for commit” 部分（也就是 未暂存清单）看到：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ rm PROJECTS.md
</span><span class='line'>$ git status
</span><span class='line'>On branch master
</span><span class='line'>Your branch is up-to-date with 'origin/master'.
</span><span class='line'>Changes not staged for commit:
</span><span class='line'>  (use "git add/rm &lt;file&gt;..." to update what will be committed)
</span><span class='line'>  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)
</span><span class='line'>
</span><span class='line'>        deleted:    PROJECTS.md
</span><span class='line'>
</span><span class='line'>no changes added to commit (use "git add" and/or "git commit -a")</span></code></pre></td></tr></table></div></figure>


<p>然后再运行 git rm 记录此次移除文件的操作：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git rm PROJECTS.md
</span><span class='line'>rm 'PROJECTS.md'
</span><span class='line'>$ git status
</span><span class='line'>On branch master
</span><span class='line'>Changes to be committed:
</span><span class='line'>  (use "git reset HEAD &lt;file&gt;..." to unstage)
</span><span class='line'>
</span><span class='line'>    deleted:    PROJECTS.md</span></code></pre></td></tr></table></div></figure>


<p>下一次提交时，该文件就不再纳入版本管理了。 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f（译注：即 force 的首字母）。 这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被 Git 恢复。</p>

<p>另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。 换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。 当你忘记添加 .gitignore 文件，不小心把一个很大的日志文件或一堆 .a 这样的编译生成文件添加到暂存区时，这一做法尤其有用。 为达到这一目的，使用 &ndash;cached 选项：</p>

<pre><code>$ git rm --cached README
</code></pre>

<p><code>git rm</code> 命令后面可以列出文件或者目录的名字，也可以使用 <code>glob</code> 模式。 比方说：</p>

<pre><code>$ git rm log/\*.log
</code></pre>

<p>注意到<code>星号 *</code> 之前的<code>反斜杠 \</code>， 因为 <code>Git</code> 有它自己的文件模式扩展匹配方式，所以我们不用 <code>shell</code> 来帮忙展开。 此命令删除 <code>log/</code> 目录下扩展名为 <code>.log</code> 的所有文件。 类似的比如：</p>

<pre><code>$ git rm \*~
</code></pre>

<p>该命令为删除以 <code>~ 结尾</code>的所有文件。</p>

<h4>移动文件</h4>

<pre><code>$ git mv file_from file_to
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> git mv README.md README
</span><span class='line'>$ git status
</span><span class='line'>On branch master
</span><span class='line'>Changes to be committed:
</span><span class='line'>  (use "git reset HEAD &lt;file&gt;..." to unstage)
</span><span class='line'>
</span><span class='line'>    renamed:    README.md -&gt; README</span></code></pre></td></tr></table></div></figure>


<p>其实，运行 git mv 就相当于运行了下面三条命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ mv README.md README
</span><span class='line'>$ git rm README.md
</span><span class='line'>$ git add README</span></code></pre></td></tr></table></div></figure>


<h3>查看提交历史</h3>

<hr />

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git log
</span><span class='line'>commit ca82a6dff817ec66f44342007202690a93763949
</span><span class='line'>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
</span><span class='line'>Date:   Mon Mar 17 21:52:11 2008 -0700
</span><span class='line'>
</span><span class='line'>    changed the version number
</span><span class='line'>
</span><span class='line'>commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
</span><span class='line'>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
</span><span class='line'>Date:   Sat Mar 15 16:40:33 2008 -0700
</span><span class='line'>
</span><span class='line'>    removed unnecessary test
</span><span class='line'>
</span><span class='line'>commit a11bef06a3f659402fe7563abf99ad00de2209e6
</span><span class='line'>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
</span><span class='line'>Date:   Sat Mar 15 10:31:28 2008 -0700
</span><span class='line'>
</span><span class='line'>    first commit</span></code></pre></td></tr></table></div></figure>


<p>  <br/>
默认不用任何参数的话，<code>git log</code> 会按提交时间列出所有的更新，最近的更新排在最上面。 正如你所看到的，这个命令会列出每个提交的 <code>SHA-1</code> 校验和作者的名字和电子邮件地址、提交时间以及提交说明。</p>

<p>一个常用的选项是 <code>-p</code>，用来显示每次提交的内容差异。 你也可以加上 <code>-2</code> 来仅显示最近两次提交。
如果你想看到每次提交的简略的统计信息，你可以使用 <code>--stat</code> 选项，此选项在每次提交的下面列出额所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。 在每次提交的最后还有一个总结。</p>

<p>另外一个常用的选项是 <code>--pretty</code>。 这个选项可以指定使用不同于默认格式的方式展示提交历史。  这个选项有一些内建的子选项供你使用。 比如用 <code>oneline</code> 将每个提交放在一行显示，查看的提交数很大时非常有用。 另外还有 <code>short</code>，<code>full</code> 和 <code>fuller</code> 可以用，展示的信息或多或少有些不同。</p>

<p>最有意思的是 <code>format</code>，可以定制要显示的记录格式。 这样的输出对后期提取分析格外有用 — 因为你知道输出的格式不会随着 <code>Git</code> 的更新而发生改变：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git log --pretty=format:"%h - %an, %ar : %s"
</span><span class='line'>ca82a6d - Scott Chacon, 6 years ago : changed the version number
</span><span class='line'>085bb3b - Scott Chacon, 6 years ago : removed unnecessary test
</span><span class='line'>a11bef0 - Scott Chacon, 6 years ago : first commit</span></code></pre></td></tr></table></div></figure>


<ul>
<li><code>git log --pretty=format</code> 常用的选项</li>
</ul>


<table>
<thead>
<tr>
<th>选项  </th>
<th>  说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>%H      </td>
<td> 提交对象（commit）的完整哈希字串</td>
</tr>
<tr>
<td>%h      </td>
<td> 提交对象的简短哈希字串</td>
</tr>
<tr>
<td>%T      </td>
<td> 树对象（tree）的完整哈希字串</td>
</tr>
<tr>
<td>%t      </td>
<td> 树对象的简短哈希字串</td>
</tr>
<tr>
<td>%P      </td>
<td> 父对象（parent）的完整哈希字串</td>
</tr>
<tr>
<td>%p      </td>
<td> 父对象的简短哈希字串</td>
</tr>
<tr>
<td>%an     </td>
<td> 作者（author）的名字</td>
</tr>
<tr>
<td>%ae     </td>
<td> 作者的电子邮件地址</td>
</tr>
<tr>
<td>%ad     </td>
<td> 作者修订日期（可以用 &ndash;date= 选项定制格式）</td>
</tr>
<tr>
<td>%ar     </td>
<td> 作者修订日期，按多久以前的方式显示</td>
</tr>
<tr>
<td>%cn     </td>
<td> 提交者(committer)的名字</td>
</tr>
<tr>
<td>%ce     </td>
<td> 提交者的电子邮件地址</td>
</tr>
<tr>
<td>%cd     </td>
<td> 提交日期</td>
</tr>
<tr>
<td>%cr     </td>
<td> 提交日期，按多久以前的方式显示</td>
</tr>
<tr>
<td>%s      </td>
<td> 提交说明</td>
</tr>
</tbody>
</table>


<p>作者 和 提交者 之间究竟有何差别， 其实作者指的是实际作出修改的人，提交者指的是最后将此工作成果提交到仓库的人。</p>

<p>当 <code>oneline</code> 或 <code>format</code> 与另一个 <code>log</code> 选项 <code>--graph</code> 结合使用时尤其有用。 这个选项添加了一些<code>ASCII</code>字符串来形象地展示你的分支、合并历史：</p>

<h4>限制输出长度</h4>

<p><code>git log</code> 还有许多非常实用的限制输出长度的选项，也就是只输出部分提交信息。
另外还有按照时间作限制的选项，比如 <code>--since</code> 和 <code>--until</code> 也很有用。 例如，下面的命令列出所有最近两周内的提交：</p>

<pre><code>$ git log --since=2.weeks
</code></pre>

<p>另一个非常有用的筛选选项是 <code>-S</code>，可以列出那些添加或移除了某些字符串的提交。 比如说，你想找出添加或移除了某一个特定函数的引用的提交，你可以这样使用：</p>

<pre><code>$ git log -Sfunction_name   
</code></pre>

<p><code>限制 git log 输出的选项</code></p>

<table>
<thead>
<tr>
<th>选项  </th>
<th>   说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-(n)    </td>
<td> 仅显示最近的 n 条提交</td>
</tr>
<tr>
<td>&ndash;since, &ndash;after    </td>
<td> 仅显示指定时间之后的提交。</td>
</tr>
<tr>
<td>&ndash;until, &ndash;before   </td>
<td>   仅显示指定时间之前的提交。</td>
</tr>
<tr>
<td>&ndash;author    </td>
<td> 仅显示指定作者相关的提交。</td>
</tr>
<tr>
<td>&ndash;committer </td>
<td> 仅显示指定提交者相关的提交。</td>
</tr>
<tr>
<td>&ndash;grep  </td>
<td> 仅显示含指定关键字的提交</td>
</tr>
<tr>
<td>-S  </td>
<td> 仅显示添加或移除了某个关键字的提交</td>
</tr>
</tbody>
</table>


<p>来看一个实际的例子，如果要查看 Git 仓库中，2008 年 10 月期间，Junio Hamano 提交的但未合并的测试文件，可以用下面的查询命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git log --pretty="%h - %s" --author=gitster --since="2008-10-01" \
</span><span class='line'>   --before="2008-11-01" --no-merges -- t/
</span><span class='line'>5610e3b - Fix testcase failure when extended attributes are in use
</span><span class='line'>acd3b9e - Enhance hold_lock_file_for_{update,append}() API
</span><span class='line'>f563754 - demonstrate breakage of detached checkout with symbolic link HEAD
</span><span class='line'>d1a43f2 - reset --hard/read-tree --reset -u: remove unmerged new paths
</span><span class='line'>51a94af - Fix "checkout --track -b newbranch" on detached HEAD
</span><span class='line'>b0ad11e - pull: allow "git pull origin $something:$current_branch" into an unborn branch</span></code></pre></td></tr></table></div></figure>


<h3>撤消操作</h3>

<hr />

<pre><code>$ git commit --amend
</code></pre>

<p>这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息。</p>

<p>例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git commit -m 'initial commit'
</span><span class='line'>$ git add forgotten_file
</span><span class='line'>$ git commit --amend</span></code></pre></td></tr></table></div></figure>


<p> <br/>
最终你只会有一个提交 - 第二次提交将代替第一次提交的结果。</p>

<h5>取消暂存的文件</h5>

<p>使用 <code>git reset HEAD &lt;file&gt;...</code>来取消暂存。 所以，我们可以这样来取消暂存 <code>CONTRIBUTING.md</code> 文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git reset HEAD CONTRIBUTING.md
</span><span class='line'>Unstaged changes after reset:
</span><span class='line'>M CONTRIBUTING.md
</span><span class='line'>$ git status
</span><span class='line'>On branch master
</span><span class='line'>Changes to be committed:
</span><span class='line'>  (use "git reset HEAD &lt;file&gt;..." to unstage)
</span><span class='line'>
</span><span class='line'>    renamed:    README.md -&gt; README
</span><span class='line'>
</span><span class='line'>Changes not staged for commit:
</span><span class='line'>  (use "git add &lt;file&gt;..." to update what will be committed)
</span><span class='line'>  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)
</span><span class='line'>
</span><span class='line'>    modified:   CONTRIBUTING.md
</span></code></pre></td></tr></table></div></figure>


<p><code>提示</code></p>

<p>虽然在调用时加上 <code>--hard</code> 选项可以令 <code>git reset</code> 成为一个危险的命令（译注：可能导致工作目录中所有当前进度丢失！），但本例中工作目录内的文件并不会被修改。 不加选项地调用 <code>git reset</code> 并不危险 — 它只会修改暂存区域。</p>

<h5>撤消对文件的修改</h5>

<p>撤消之前所做的修改</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git checkout -- CONTRIBUTING.md
</span><span class='line'>$ git status
</span><span class='line'>On branch master
</span><span class='line'>Changes to be committed:
</span><span class='line'>  (use "git reset HEAD &lt;file&gt;..." to unstage)
</span><span class='line'>
</span><span class='line'>    renamed:    README.md -&gt; README</span></code></pre></td></tr></table></div></figure>


<p><code>危险</code></p>

<p>你需要知道 <code>git checkout -- [file]</code> 是一个危险的命令，这很重要。 你对那个文件做的任何修改都会消失 - 你只是拷贝了另一个文件来覆盖它。 除非你确实清楚不想要那个文件了，否则不要使用这个命令。</p>

<p><code>记住</code></p>

<p>在 <code>Git</code> 中任何 已提交的 东西几乎总是可以恢复的。 甚至那些被删除的分支中的提交或使用 <code>--amend</code> 选项覆盖的提交也可以恢复。 然而，任何你未提交的东西丢失后很可能再也找不到了</p>

<h3>远程仓库的使用</h3>

<hr />

<h5>查看远程仓库</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git clone https://github.com/schacon/ticgit
</span><span class='line'>Cloning into 'ticgit'...
</span><span class='line'>remote: Reusing existing pack: 1857, done.
</span><span class='line'>remote: Total 1857 (delta 0), reused 0 (delta 0)
</span><span class='line'>Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.
</span><span class='line'>Resolving deltas: 100% (772/772), done.
</span><span class='line'>Checking connectivity... done.
</span><span class='line'>$ cd ticgit
</span><span class='line'>$ git remote
</span><span class='line'>origin</span></code></pre></td></tr></table></div></figure>


<p>你也可以指定选项 <code>-v</code>，会显示需要读写远程仓库使用的 <code>Git</code> 保存的简写与其对应的 <code>URL</code>。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git remote -v
</span><span class='line'>origin    https://github.com/schacon/ticgit (fetch)
</span><span class='line'>origin    https://github.com/schacon/ticgit (push)</span></code></pre></td></tr></table></div></figure>


<h5>添加远程仓库</h5>

<p>运行 <code>git remote add &lt;shortname&gt; &lt;url&gt;</code> 添加一个新的远程 <code>Git</code> 仓库，同时指定一个你可以轻松引用的简写</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git remote
</span><span class='line'>origin
</span><span class='line'>$ git remote add pb https://github.com/paulboone/ticgit
</span><span class='line'>$ git remote -v
</span><span class='line'>origin    https://github.com/schacon/ticgit (fetch)
</span><span class='line'>origin    https://github.com/schacon/ticgit (push)
</span><span class='line'>pb    https://github.com/paulboone/ticgit (fetch)
</span><span class='line'>pb    https://github.com/paulboone/ticgit (push)</span></code></pre></td></tr></table></div></figure>


<p>现在你可以在命令行中使用字符串 pb 来代替整个 URL。 例如，如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行 <code>git fetch pb</code>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git fetch pb
</span><span class='line'>remote: Counting objects: 43, done.
</span><span class='line'>remote: Compressing objects: 100% (36/36), done.
</span><span class='line'>remote: Total 43 (delta 10), reused 31 (delta 5)
</span><span class='line'>Unpacking objects: 100% (43/43), done.
</span><span class='line'>From https://github.com/paulboone/ticgit
</span><span class='line'> * [new branch]      master     -&gt; pb/master
</span><span class='line'> * [new branch]      ticgit     -&gt; pb/ticgit</span></code></pre></td></tr></table></div></figure>


<h5>从远程仓库中抓取与拉取</h5>

<pre><code>$ git fetch [remote-name]
</code></pre>

<p>这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。</p>

<p>如果你使用 <code>clone</code> 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 <code>origin</code> 为简写。 所以，<code>git fetch origin</code> 会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意 <code>git fetch</code> 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。</p>

<p>如果你有一个分支设置为跟踪一个远程分支，可以使用 <code>git pull</code> 命令来自动的抓取然后合并远程分支到当前分支。 这对你来说可能是一个更简单或更舒服的工作流程；默认情况下，<code>git clone</code> 命令会自动设置本地 <code>master</code> 分支跟踪克隆的远程仓库的 <code>master</code> 分支（或不管是什么名字的默认分支）。 运行 <code>git pull</code> 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。</p>

<h5>推送到远程仓库</h5>

<p><code>git push [remote-name] [branch-name]</code> 当你想要将 <code>master</code> 分支推送到 <code>origin</code> 服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字），那么运行这个命令就可以将你所做的备份到服务器：</p>

<pre><code>$ git push origin master
</code></pre>

<h5>查看远程仓库</h5>

<p>使用 <code>git remote show [remote-name]</code> 命令，查看某一个远程仓库的更多信息。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git remote show origin
</span><span class='line'>* remote origin
</span><span class='line'>  Fetch URL: https://github.com/schacon/ticgit
</span><span class='line'>  Push  URL: https://github.com/schacon/ticgit
</span><span class='line'>  HEAD branch: master
</span><span class='line'>  Remote branches:
</span><span class='line'>    master                               tracked
</span><span class='line'>    dev-branch                           tracked
</span><span class='line'>  Local branch configured for 'git pull':
</span><span class='line'>    master merges with remote master
</span><span class='line'>  Local ref configured for 'git push':
</span><span class='line'>    master pushes to master (up to date)</span></code></pre></td></tr></table></div></figure>


<h5>远程仓库的移除与重命名</h5>

<p>如果想要重命名引用的名字可以运行 <code>git remote rename</code> 去修改一个远程仓库的简写名。 例如，想要将 <code>pb</code> 重命名为 <code>paul</code>，可以用 <code>git remote rename</code> 这样做：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git remote rename pb paul
</span><span class='line'>$ git remote
</span><span class='line'>origin
</span><span class='line'>paul</span></code></pre></td></tr></table></div></figure>


<p>如果因为一些原因想要移除一个远程仓库 - 你已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者某一个贡献者不再贡献了 - 可以使用 <code>git remote rm</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git remote rm paul
</span><span class='line'>$ git remote
</span><span class='line'>origin</span></code></pre></td></tr></table></div></figure>


<h3>打标签</h3>

<hr />

<p>像其他版本控制系统（VCS）一样，Git 可以给历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。</p>

<h5>列出标签</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git tag
</span><span class='line'>v0.1
</span><span class='line'>v1.3</span></code></pre></td></tr></table></div></figure>


<p>这个命令以字母顺序列出标签；但是它们出现的顺序并不重要。</p>

<h5>创建标签</h5>

<p>Git 使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。</p>

<p>一个轻量标签很像一个不会改变的分支 - 它只是一个特定提交的引用。然而，附注标签是存储在 Git 数据库中的一个完整对象。它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证。 通常建议创建附注标签，这样你可以拥有以上所有信息；但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的。</p>

<h5>附注标签</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git tag -a v1.4 -m 'my version 1.4'
</span><span class='line'>$ git tag
</span><span class='line'>v0.1
</span><span class='line'>v1.3
</span><span class='line'>v1.4
</span></code></pre></td></tr></table></div></figure>


<p>通过使用 git show 命令可以看到标签信息与对应的提交信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git show v1.4
</span><span class='line'>tag v1.4
</span><span class='line'>Tagger: Ben Straub &lt;ben@straub.cc&gt;
</span><span class='line'>Date:   Sat May 3 20:19:12 2014 -0700
</span><span class='line'>
</span><span class='line'>my version 1.4
</span><span class='line'>
</span><span class='line'>commit ca82a6dff817ec66f44342007202690a93763949
</span><span class='line'>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
</span><span class='line'>Date:   Mon Mar 17 21:52:11 2008 -0700
</span><span class='line'>
</span><span class='line'>  changed the version number</span></code></pre></td></tr></table></div></figure>


<h4>轻量标签</h4>

<p>轻量标签本质上是将提交校验和存储到一个文件中 - 没有保存任何其他信息。 创建轻量标签，不需要使用 -a、-s 或 -m 选项，只需要提供标签名字：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git tag v1.4-lw
</span><span class='line'>$ git tag
</span><span class='line'>v0.1
</span><span class='line'>v1.3
</span><span class='line'>v1.4
</span><span class='line'>v1.4-lw
</span><span class='line'>v1.5</span></code></pre></td></tr></table></div></figure>


<p>这时，如果在标签上运行 git show，你不会看到额外的标签信息。 命令只会显示出提交信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git show v1.4-lw
</span><span class='line'>commit ca82a6dff817ec66f44342007202690a93763949
</span><span class='line'>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
</span><span class='line'>Date:   Mon Mar 17 21:52:11 2008 -0700
</span><span class='line'>
</span><span class='line'>    changed the version number</span></code></pre></td></tr></table></div></figure>


<h4>后期打标签</h4>

<p>你也可以对过去的提交打标签。 假设提交历史是这样的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git log --pretty=oneline
</span><span class='line'>15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch 'experiment'
</span><span class='line'>a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support
</span><span class='line'>0d52aaab4479697da7686c15f77a3d64d9165190 one more thing
</span><span class='line'>6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch 'experiment'
</span><span class='line'>0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function
</span><span class='line'>4682c3261057305bdd616e23b64b0857d832627b added a todo file
</span><span class='line'>166ae0c4d3f420721acbb115cc33848dfcc2121a started write support
</span><span class='line'>9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile
</span><span class='line'>964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo
</span><span class='line'>8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme</span></code></pre></td></tr></table></div></figure>


<p>现在，假设在 <code>v1.2</code> 时你忘记给项目打标签，也就是在 <code>updated rakefile</code> 提交。 你可以在之后补上标签。 要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）:</p>

<pre><code>$ git tag -a v1.2 9fceb02
</code></pre>

<p>可以看到你已经在那次提交上打上标签了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git tag
</span><span class='line'>v0.1
</span><span class='line'>v1.2
</span><span class='line'>v1.3
</span><span class='line'>v1.4
</span><span class='line'>v1.4-lw
</span><span class='line'>v1.5
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>$ git show v1.2
</span><span class='line'>tag v1.2
</span><span class='line'>Tagger: Scott Chacon &lt;schacon@gee-mail.com&gt;
</span><span class='line'>Date:   Mon Feb 9 15:32:16 2009 -0800
</span><span class='line'>
</span><span class='line'>version 1.2
</span><span class='line'>commit 9fceb02d0ae598e95dc970b74767f19372d61af8
</span><span class='line'>Author: Magnus Chacon &lt;mchacon@gee-mail.com&gt;
</span><span class='line'>Date:   Sun Apr 27 20:43:35 2008 -0700
</span><span class='line'>
</span><span class='line'>    updated rakefile
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<h4>共享标签</h4>

<p>默认情况下，<code>git push</code> 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样 - 你可以运行 <code>git push origin [tagname]</code>。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git push origin v1.5
</span><span class='line'>Counting objects: 14, done.
</span><span class='line'>Delta compression using up to 8 threads.
</span><span class='line'>Compressing objects: 100% (12/12), done.
</span><span class='line'>Writing objects: 100% (14/14), 2.05 KiB | 0 bytes/s, done.
</span><span class='line'>Total 14 (delta 3), reused 0 (delta 0)
</span><span class='line'>To git@github.com:schacon/simplegit.git
</span><span class='line'> * [new tag]         v1.5 -&gt; v1.5</span></code></pre></td></tr></table></div></figure>


<p>如果想要一次性推送很多标签，也可以使用带有 &ndash;tags 选项的 git push 命令。 这将会把所有不在远程仓库服务器上的标签全部传送到那里。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git push origin --tags
</span><span class='line'>Counting objects: 1, done.
</span><span class='line'>Writing objects: 100% (1/1), 160 bytes | 0 bytes/s, done.
</span><span class='line'>Total 1 (delta 0), reused 0 (delta 0)
</span><span class='line'>To git@github.com:schacon/simplegit.git
</span><span class='line'> * [new tag]         v1.4 -&gt; v1.4
</span><span class='line'> * [new tag]         v1.4-lw -&gt; v1.4-lw</span></code></pre></td></tr></table></div></figure>


<h4>检出标签</h4>

<p>在 Git 中你并不能真的检出一个标签，因为它们并不能像分支一样来回移动。 如果你想要工作目录与仓库中特定的标签版本完全一样，可以使用 git checkout -b [branchname] [tagname] 在特定的标签上创建一个新分支：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git checkout -b version2 v2.0.0
</span><span class='line'>Switched to a new branch 'version2'</span></code></pre></td></tr></table></div></figure>


<p>当然，如果在这之后又进行了一次提交，version2 分支会因为改动向前移动了，那么 version2 分支就会和 v2.0.0 标签稍微有些不同，这时就应该当心了。</p>

<h3>Git 别名</h3>

<hr />

<p>Git 并不会在你输入部分命令时自动推断出你想要的命令。 如果不想每次都输入完整的 Git 命令，可以通过 git config 文件来轻松地为每一个命令设置一个别名。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git config --global alias.co checkout
</span><span class='line'>$ git config --global alias.br branch
</span><span class='line'>$ git config --global alias.ci commit
</span><span class='line'>$ git config --global alias.st status</span></code></pre></td></tr></table></div></figure>


<p>这意味着，当要输入 git commit时，只需要输入 git ci。 随着你继续不断地使用 Git，可能也会经常使用其他命令，所以创建别名时不要犹豫。</p>

<p>在创建你认为应该存在的命令时这个技术会很有用。 例如，为了解决取消暂存文件的易用性问题，可以向 Git 中添加你自己的取消暂存别名：</p>

<pre><code>$ git config --global alias.unstage 'reset HEAD --'
</code></pre>

<p>这会使下面的两个命令等价：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git unstage fileA
</span><span class='line'>$ git reset HEAD -- fileA</span></code></pre></td></tr></table></div></figure>


<p>这样看起来更清楚一些。 通常也会添加一个 last 命令，像这样：</p>

<pre><code>$ git config --global alias.last 'log -1 HEAD'
</code></pre>

<p>这样，可以轻松地看到最后一次提交：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git last
</span><span class='line'>commit 66938dae3329c7aebe598c2246a8e6af90d04646
</span><span class='line'>Author: Josh Goebel &lt;dreamer3@example.com&gt;
</span><span class='line'>Date:   Tue Aug 26 19:48:51 2008 +0800
</span><span class='line'>
</span><span class='line'>    test for current head
</span><span class='line'>
</span><span class='line'>    Signed-off-by: Scott Chacon &lt;schacon@example.com&gt;</span></code></pre></td></tr></table></div></figure>

]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[最近情况]]></title>
        <link href="http://swplzj.github.io/blog/2015/11/05/zui-jin-qing-kuang/"/>
        <updated>2015-11-05T18:44:27+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/11/05/zui-jin-qing-kuang</id>
        <content type="html"><![CDATA[<p>最近的情况是：忙 - 盲 - 茫，一言难尽啊，这些经历都是有必要记录下来，以便回顾自己走过的路，方便总结自己的成长得失。</p>

<!--more-->


<p>今年3月份辞职，有了一次重新选择公司的机会，这次较以前还是比较慎重的，总后拿到了几个 Offer，权衡之后来到了选择这家公司，当时几个公司的情形是这样的：</p>

<ul>
<li>墨迹天气面试通过了，但是，进入之后感觉公司没有一个很好的公司氛围（其实是和798旁边的视界核心比较的了），没有然后了；</li>
<li>视界核心，这是一个令我很向往的公司，一个极客的天堂，各方面都很满意，也过了初试、复试，但到最后的时候，公司还是没有要我，真残忍啊。印象：团队小而精悍，产品都具有互联网思维，融入了极客精神，产品设计和用到的技术都是一流的，很赞；</li>
<li>魔漫相机：其实，我在那里呆了一天，团队虽只有五六十人，但其产品用户足有两亿多，可见其产品设计之成功，不符合自己的职业价值观，拒绝了；</li>
<li>租车公司：忘记了名字了，离家近，最后工资没有达成一致，公司方向也不是我想从事的，放弃；</li>
<li>纷享销客：这是我最难做出取舍的公司，团队特别棒，一路面试，总裁是微软出身的，最后，还是咬牙舍弃，人生的选择没有对与错，路是自己走出来的；</li>
<li>现公司：互联网金融，我很看好这个方向，因为自己也算是这个需求的用户，之前做过农行的e购天街，建行的微银行，算是金融产品出身；</li>
</ul>


<p>这些就是我今年年初的经历，说这些也算是回顾一下，因为这些也是反思，不知道自己的路选择的正确与否。目前来到公司做了三个项目，项目之间也有复用模块，做这项目也都倾注了自己所有的努力，结果是残忍的：</p>

<ul>
<li>项目一，因为公司战略问题，不了了之，已经到了上线的阶段，不理解。</li>
<li>项目二，复用了一些模块，添加了一些新功能，紧急上线了，也用到了实际门店，算是欣慰；</li>
<li>项目三，到了冒烟测试阶段，接到上级通知，战略调整，暂时放弃&hellip;</li>
</ul>


<p>这也是我为什么回顾今年历程的原因了，反思自己在这里成长得失，寻找接下来努力和选择的方向，对自己的要求，尽自己最大的努力去做好眼前的事情，我不想到年底总结的时候，自己回顾一年的努力，都是徒劳，于公：没有为公司带来实际效益，于私：技术没有大幅提升，也没有人力管理、时间管理等方面的实践和成长，这样的工作是很失败的，个人认为只有做到对自己负责的人，才有资格为他人负责，为公司负责，才有机会担当更重的责任。</p>

<p>唠叨了这么多，接下来还是要有目标的去提升自己，规划自己的职业道路。
分享今天看到的一句话：要想成为牛逼的人，就要去吃成为牛逼人所要吃的苦。</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[如何下载和安装CocoaPods]]></title>
        <link href="http://swplzj.github.io/blog/2015/09/04/ru-he-xia-zai-he-an-zhuang-cocoapods/"/>
        <updated>2015-09-04T14:16:46+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/09/04/ru-he-xia-zai-he-an-zhuang-cocoapods</id>
        <content type="html"><![CDATA[<h3>CocoaPods安装和使用教程</h3>

<hr />

<h4>CocoaPods是什么？</h4>

<p>CocoaPods是iOS第三方开源类库管理工具。</p>

<h4>如何下载和安装CocoaPods？</h4>

<pre><code>sudo gem install cocoapods
</code></pre>

<p>GFW阻挡了cocoapods.org,</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ gem sources --remove https://rubygems.org/
</span><span class='line'>//等有反应之后再敲入以下命令
</span><span class='line'>$ gem sources -a http://ruby.taobao.org/</span></code></pre></td></tr></table></div></figure>


<p>验证Ruby镜像</p>

<pre><code>$ gem sources -l
</code></pre>

<p>运行后出现</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>*** CURRENT SOURCES ***
</span><span class='line'>
</span><span class='line'>http://ruby.taobao.org/   </span></code></pre></td></tr></table></div></figure>


<p>安装</p>

<pre><code>$ sudo gem install cocoapods
</code></pre>

<h4>如何使用CocoaPods？</h4>

<p>两种使用场景来具体说明如何使用CocoaPods。</p>

<h5>利用CocoaPods，在项目中导入AFNetworking类库</h5>

<pre><code>$ pod search AFNetworking
</code></pre>

<p>先利用Xcode创建一个名字CocoaPodsDemo的项目，
有个文件来控制CocoaPods该下载什么。这个文件就叫做“Podfile”（注意，一定得是这个文件名，而且没有后缀）。你创建一个Podfile文件，然后在里面添加你需要下载的类库，每个项目只需要一个Podfile文件。</p>

<p>在终端中进入（cd命令）你项目所在目录，然后在当前目录下，利用vim创建Podfile，运行：</p>

<pre><code>$ vim Podfile
</code></pre>

<p>然后在Podfile文件中输入以下文字：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>platform :ios, '7.0'
</span><span class='line'>pod "AFNetworking", "~&gt; 2.0"</span></code></pre></td></tr></table></div></figure>


<p>然后保存退出。vim环境下，保存退出命令是：</p>

<pre><code>:wq
</code></pre>

<p>你会发现你的项目目录中，出现一个名字为<code>Podfile</code>的文件，而且文件内容就是你刚刚输入的内容。注意，<code>Podfile</code>文件应该和你的工程文件<code>.xcodeproj</code>在同一个目录下。</p>

<pre><code>$ pod install 
</code></pre>

<p>注意：以后打开项目就用 <code>CocoaPodsDemo.xcworkspace</code> 打开，而不是之前的<code>.xcodeproj</code>文件。</p>

<h5>如何正确编译运行一个包含CocoPods类库的项目</h5>

<p>打开终端，进入<code>UAAppReviewManagerExample</code>所在的目录，也就是和<code>Podfile</code>在同一目录下，和场景1一样，输入以下命令（由于已经有<code>Podfile</code>，所以不需要再创建<code>Podfile</code>）：</p>

<pre><code>$ pod update
</code></pre>

<p>这时候，再回到UAAppReviewManagerExample文件夹看一看，会看到多了一个文件UAAppReviewManagerExample.xcworkspace：</p>

<p>注意，这里有个小问题，如果刚刚你不是输入<code>$ pod update</code>，而是输入<code>$ pod install</code>，会发现类库导入不成功，并且终端出现下面提示：</p>

<p><code>$ pod install</code>只会按照<code>Podfile</code>的要求来请求类库，如果类库版本号有变化，那么将获取失败。但是 <code>$ pod update</code>会更新所有的类库，获取最新版本的类库。而且你会发现，如果用了 <code>$ pod update</code>，再用 <code>$ pod install</code> 就成功了。</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[iOS - VPN强烈推荐]]></title>
        <link href="http://swplzj.github.io/blog/2015/08/19/ios-vpnqiang-lie-tui-jian/"/>
        <updated>2015-08-19T18:58:02+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/08/19/ios-vpnqiang-lie-tui-jian</id>
        <content type="html"><![CDATA[<p>之前推荐过 Mac 上的 VPN 使用，今天推荐两款 iOS 端比价好用的 VPN 应用，真的用起来很方便。无需注册，轻松翻墙。</p>

<ol>
<li><code>ArkVPN</code>：优点：方便，速度快，免费，不限流量。缺点：不订阅的话需要每天领取时长，不过免费时长够用了。</li>
<li><code>Shadowsocks</code>：优点：方便，免费，开源，不限流量，不限时长。缺点：有些慢，有广告。</li>
</ol>


<!--more-->


<h3>ArkVPN</h3>

<ul>
<li><p>安装</p>

<p> <a href="https://itunes.apple.com/cn/app/arkvpn-wu-xian-liu-liang-mian/id909977824?mt=8">ArkVPN 下载地址</a></p></li>
<li><p>每天领取免费时长</p>

<p>  <img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_vpn_id1.PNG" title="\" ></p></li>
<li><p>只要一次点击，连接整个世界</p>

<p>  <img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_vpn_id2.PNG" title="\" ></p>

<p>  <img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_vpn_id3.PNG" title="\" ></p>

<p>  <img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_vpn_id4.PNG" title="\" ></p></li>
<li><p>国外服务器列表</p>

<p>  <img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_vpn_id5.PNG" title="\" ></p></li>
</ul>


<h3>Shadowsocks</h3>

<ul>
<li><p>简介
Shadowsocks 是一个开源项目，同时提供多个平台使用，你也可<a href="https://github.com/shadowsocks/shadowsocks">下载源码</a>进行研究。iOS客户端类似于一个封闭的浏览器，这这里可以翻墙浏览任何你想浏览的页面了。</p></li>
<li><p>安装</p></li>
</ul>


<p><a href="https://github.com/shadowsocks/shadowsocks-csharp">Windows</a> / <a href="https://github.com/shadowsocks/shadowsocks-iOS/wiki/Shadowsocks-for-OSX-Help">OS X</a></p>

<p><a href="https://github.com/shadowsocks/shadowsocks-android">Android</a> / <a href="https://github.com/shadowsocks/shadowsocks-iOS/wiki/Help">iOS</a></p>

<p><a href="https://github.com/shadowsocks/openwrt-shadowsocks">OpenWRT</a></p>

<ul>
<li><p>使用</p>

<p>  <img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_vpn_id6.PNG" title="\" ><br/>
  <img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_vpn_id7.PNG" title="\" ></p></li>
</ul>


<p>Have fun！</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[正则表达式学习]]></title>
        <link href="http://swplzj.github.io/blog/2015/08/19/zheng-ze-biao-da-shi-xue-xi/"/>
        <updated>2015-08-19T11:45:54+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/08/19/zheng-ze-biao-da-shi-xue-xi</id>
        <content type="html"><![CDATA[<p>项目中经常使用到一些校验，比如有效手机号，身份证号码，邮箱，银行卡号码&hellip;假如说都是简单的使用位数来做校验，容易造成特殊字符输入乱码，还有可能在数据库中写入脏数据，所以使用正则表达式来进行校验匹配是很有必要的，当然，我们学习它就要知道它有哪些作用，正则表达式的用途基本有以下三种：</p>

<ul>
<li>校验数据</li>
<li>查询数据</li>
<li>替换数据</li>
</ul>


<p>学习正则表达式的最好方法是从例子开始，理解例子之后再自己对例子进行修改。下面开始学习之旅：</p>

<!--more-->


<h3>语法</h3>

<p><code>.</code> 是元字符，匹配除了换行符以外的任意字符。</p>

<p><code>*</code> 是元字符，不过它代表的不是字符，也不是位置，而是数量——它指定 <code>*</code> 前边的内容可以连续重复使用任意次以使整个表达式得到匹配。</p>

<p><code>.*</code> 连在一起就意味着任意数量的不包含换行的字符。</p>

<p><code>+</code> 重复一次或更多次</p>

<p><code>?</code> 重复零次或一次</p>

<p><code>{n}</code> 重复n次</p>

<p><code>{n,}</code>  重复n次或更多次</p>

<p><code>{n,m}</code> 重复n到m次</p>

<p><code>[]</code> 指定一个字符范围，比如，<strong>[aeiou]</strong>就匹配任何一个英文元音字母，<code>[0-9]</code>代表的含意与\d就是完全一致的。
<code>()</code> 小括号来指定子表达式(也叫做分组),比如：<strong>(\d{1,3}.){3}\d{1,3}</strong> 是一个简单的IP地址匹配表达式。</p>

<p><code>\b</code> 是正则表达式规定的一个特殊代码（也叫它元字符，metacharacter），代表着单词的开头或结尾，也就是单词的分界处。虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是<code>\b</code>并不匹配这些单词分隔字符中的任何一个，它只匹配一个位置。比如:在一段文本中查询<code>Leo</code>，就可以这样写：<strong>\bLeo\b</strong> 。</p>

<p><code>\B</code>    匹配不是单词开头或结束的位置</p>

<p><code>\d</code> 匹配一位数字，比如匹配大陆手机号码： <strong>1\d{10}</strong> ，{10} 意思是重复匹配10次。</p>

<p><code>\D</code>    匹配任意非数字的字符</p>

<p><code>\s</code> 匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等。</p>

<p><code>\S</code>    匹配任意不是空白符的字符</p>

<p><code>\w</code> 匹配字母或数字或下划线或汉字等。</p>

<p><code>\W</code>    匹配任意不是字母，数字，下划线，汉字的字符</p>

<p><code>[^x]</code>  匹配除了x以外的任意字符</p>

<p><code>[^aeiou]</code>  匹配除了aeiou这几个字母以外的任意字符</p>

<p><code>^</code> 匹配字符串的开始，或者是行的开始处</p>

<p><code>$</code> 匹配字符串的结束，或者是行的结束处</p>

<p><code>|</code> 分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配。</p>

<p><code>\</code> 为转义字符，比如匹配网址：使用 <code>swplzj\.github\.io</code> 来匹配 <code>swplzj.github.io</code> 。</p>

<h3>后向引用</h3>

<h4>捕获</h4>

<p>(exp):  匹配exp,并捕获文本到自动命名的组里</p>

<p>(?<name>exp):   匹配exp,并捕获文本到名称为name的组里，也可以写成(?&lsquo;name'exp)</p>

<p>(?:exp):    匹配exp,不捕获匹配的文本，也不给此分组分配组号</p>

<h4>零宽断言</h4>

<p>(?=exp):    匹配exp前面的位置</p>

<p>(?&lt;=exp):   匹配exp后面的位置</p>

<p>(?!exp):    匹配后面跟的不是exp的位置</p>

<h4>注释</h4>

<p>(?#comment):    这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读</p>

<h3>实例</h3>

<p>从下面文本中查询出以<code>[]</code>包含的内容，包括<code>[]</code></p>

<pre><code>The Tasmanian tiger, also known as the Thylacine, has been announced extinct many years ago. Now many geneticists assert that they are capable of recreating a [sid=13_1] from DNA extracted from its bone specimen. \n\nTasmanian tigers belong to marsupials that have a [sid=13_2] in common. They looked like big dogs with over 15 dark stripes on the body. When chasing their preys, these animals primarily depended on [sid=13_3] to prevail. Their stomach could inflate so they could eat large amount of food each time to [sid=13_4] a period lack of food.  
</code></pre>

<p>我们发现要查询的内容是以<code>[</code>开头，以 <code>]</code> 结束的，所以首先可以肯定的是  <code>\[\]</code>，注意需要转义字符<code>\</code>，然后<code>[]</code>之前包含的可能是 数字、空格、大小写字母、符号，但是不能包含<code>]</code>,所以我们可以写出 <code>\[[^\]]+\]</code></p>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_regular_express_id1.png" title="/" ></p>

<p>再增加点难度，要检索出<code>[]</code>里面的数据，我们可以先观察规律，因为正则表达式 - Regular Express 本身就是有规律的表达式，所以现发现规律，再写出所对应的正则。</p>

<p><strong>解答</strong></p>

<ul>
<li>以 <code>[</code> 开头，作为规律，可以写出 <code>(?&lt;=\[)([^\]])+</code></li>
</ul>


<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_regular_express_id2.png" title="/" ></p>

<ul>
<li>以<code>]</code> 结束，可以写出<code>[^\[]+(?=\])</code></li>
</ul>


<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_regular_express_id3.png" title="/" ></p>

<h3>iOS中应用</h3>

<p>我们在开发iOS项目过程中，使用到正则表达式的主要场景有两种：</p>

<p><strong>第一</strong> 在应用中用户输入数据时，做正则匹配校验，这类比较常见，这里就不做详述，但是给出一个比较好的建议，就是把需要校验的项，单独创建一个 XML 文件，然后再自定义标签，属性，来进行统一存放项目中所有校验项，如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;?xml version="1.0" encoding="utf-8"?&gt;
</span><span class='line'>&lt;rules&gt;
</span><span class='line'>    &lt;rule type="mobile" pattern="^1\d{10}$" tip="请输入正确的手机号" /&gt;
</span><span class='line'>&lt;/rules&gt;</span></code></pre></td></tr></table></div></figure>


<p>上面是简单校验手机号码位数的正则表达式，这样做的好处：方便维护管理；代码更为规范。</p>

<p><strong>第二</strong> 在使用 <code>UIWebView</code> 来加载文章类的页面时，使用正则表达式可以很好的提升用户体验。那使用正则我们可以做到那些呢？</p>

<ul>
<li><p>使用正则表达式来加载本地 <code>CSS</code> 样式表来自定义 <code>HTML</code> 中的样式；</p>

<ul>
<li>替换 <code>CSS</code> 样式表，这个可以实现 <code>HTML</code> 字体大小的动态调整；</li>
<li>可以实现类似白天、黑夜主题色的更换；</li>
<li>可以对文本进行标注、突出等处理；</li>
</ul>
</li>
<li><p>使用正则表达式获取 <code>HTML</code> 中的图片、视频，以便更友好的操作图片、视频资源；</p>

<ul>
<li>可以更改图片的大小展示；</li>
<li>通过正则匹配获取到图片的属性，比如id，然后进行本地操作，如，对图片添加点击事件，点击之后，进入本地图片浏览器，在图片浏览器中，就可以对图片进行放大、缩小、查看图片备注等操作了。</li>
</ul>
</li>
<li>使用正则表达式来为 <code>HTML</code> 添加元素；

<ul>
<li>可以为添加文章标题、发布时间等操作</li>
</ul>
</li>
</ul>


<p>使用场景已经描述完了，但是怎么样实现呢，下面直接上代码：</p>

<p><strong>加载本地 CSS </strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSRegularExpression *regularexpression = [[NSRegularExpression alloc]
</span><span class='line'>                                              initWithPattern:@"(?i)&lt;\\s*link\\s*href=\"[^\"]+\\.css\""
</span><span class='line'>                                              options:NSRegularExpressionCaseInsensitive
</span><span class='line'>                                              error:nil];
</span><span class='line'>    NSArray *matches = [regularexpression matchesInString:htmlContent options:0 range:NSMakeRange(0, [htmlContent length])];
</span><span class='line'>    NSString *content = htmlContent;
</span><span class='line'>    NSString *replaceStr = [NSString stringWithFormat:@"&lt;link href=\"%@\"",cssFilePath];
</span><span class='line'>    for (NSTextCheckingResult *match in matches){
</span><span class='line'>        NSRange matchRange = [match range];
</span><span class='line'>        content=[regularexpression stringByReplacingMatchesInString:content options:0 range:matchRange withTemplate:replaceStr];
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p><strong>获取图片资源</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> NSMutableArray *imageIds = [NSMutableArray array];
</span><span class='line'>    NSString *str = @"(?i)&lt;div\\s*class\\s*=\\s*\"[^\"]*img\"&gt;\\s*&lt;img\\s*[^&gt;]*id=\\s*\"[^&gt;]*&gt;";
</span><span class='line'> NSRegularExpression *regularexpression = [[NSRegularExpression alloc]
</span><span class='line'>                                              initWithPattern:str
</span><span class='line'>                                              options:NSRegularExpressionCaseInsensitive
</span><span class='line'>                                              error:nil];
</span><span class='line'> NSArray *matches = [regularexpression matchesInString:htmlContent
</span><span class='line'>                                                  options:0
</span><span class='line'>                                                    range:NSMakeRange(0, [htmlContent length])];
</span></code></pre></td></tr></table></div></figure>


<p><strong>对图片进行操作</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> NSString *str = @"(?i)&lt;div\\s*class=\"[^\"]*img\"&gt;\\s*&lt;img\\s*[^&gt;]*id=\\s*\"";
</span><span class='line'>
</span><span class='line'> str = [str stringByAppendingString:imageInfo.image_id];
</span><span class='line'> str = [str stringByAppendingString:@"\"\\s*src=\\s*\"[^\"]*\"[^&gt;]*&gt;"];
</span><span class='line'>
</span><span class='line'> NSString *replacejs = [NSString stringWithFormat:@"&lt;div class=\"img\" id=\"%@\" onclick=\"location.href='picid'+this.id\" style=\"background-color:#999999;width:%fpx;height:%fpx;\" /&gt;",imageInfo.image_id,width,height];
</span><span class='line'>
</span><span class='line'> replacejs = [replacejs stringByAppendingString:[NSString stringWithFormat:@"&lt;img src=\"%@\"  width=\"%fpx\" height=\"%fpx\"/&gt;",imagePath,width,0.0]];
</span><span class='line'> 
</span><span class='line'> replacejs = [replacejs stringByAppendingString:[NSString stringWithFormat:@"&lt;img src=\"%@\" width=\"180px\" height=\"36px\" style=\"margin-left:%fpx;margin-top:%fpx\"/&gt;",logoImagePath,(width / 2 - 90),(height/2 - 34)]];
</span><span class='line'>
</span><span class='line'> NSRegularExpression *regularexpression = [[NSRegularExpression alloc]
</span><span class='line'>                                          initWithPattern:str
</span><span class='line'>                                          options:NSRegularExpressionCaseInsensitive
</span><span class='line'>                                          error:nil];
</span><span class='line'> NSArray *matches = [regularexpression matchesInString:content options:0 range:NSMakeRange(0,  [content length])];
</span><span class='line'>
</span><span class='line'>
</span><span class='line'> for (NSTextCheckingResult *match in matches){
</span><span class='line'>    NSRange matchRange = [match range];
</span><span class='line'>    content=[regularexpression stringByReplacingMatchesInString:content options:0 range:matchRange withTemplate:replacejs];
</span><span class='line'> }
</span><span class='line'>            </span></code></pre></td></tr></table></div></figure>


<p><strong>放大缩小页面中的文本</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> NSString *jsString = [[NSString alloc] initWithFormat:@"document.getElementsByTagName('body')[0].style.webkitTextSizeAdjust= '%@'",textFontScale];
</span><span class='line'>    
</span><span class='line'>[_webView stringByEvaluatingJavaScriptFromString:jsString];</span></code></pre></td></tr></table></div></figure>


<p><strong>扩展 - 在本地HTML中加入JS</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSString *js = @"&lt;script language=\"javascript\" type=\"text/javascript\"&gt;";
</span><span class='line'> //替换css文件
</span><span class='line'>js = [js stringByAppendingString:@"function replacejscssfile(oldfilename, newfilename, filetype){ var targetelement=(filetype==\"js\")? \"script\" : (filetype==\"css\")? \"link\" : \"none\"; var targetattr=(filetype==\"js\")? \"src\" : (filetype==\"css\")? \"href\" : \"none\"; var allsuspects=document.getElementsByTagName(targetelement); for (var i=allsuspects.length; i&gt;=0; i--){ if (allsuspects[i] && allsuspects[i].getAttribute(targetattr)!=null && allsuspects[i].getAttribute(targetattr).indexOf(oldfilename)!=-1){ var newelement=createjscssfile(newfilename, filetype); allsuspects[i].parentNode.replaceChild(newelement, allsuspects[i]);} } return \"sdasds\";}"];
</span><span class='line'>
</span><span class='line'>js = [js stringByAppendingString:@"&lt;/script&gt;&lt;/head&gt;"];
</span><span class='line'>
</span><span class='line'>   NSString *content = [htmlContent stringByReplacingOccurrencesOfString:@"&lt;/head&gt;" withString:js];</span></code></pre></td></tr></table></div></figure>


<h3>常用正则表达式</h3>

<p>网址（URL）：  [a-zA-z]+://[^\s]*</p>

<p>IP地址(IP Address)： ((2[0-4]\d|25[0-5]|[01]?\d\d?).){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)</p>

<p>电子邮件(Email)：  \w+([-+.]\w+)<em>@\w+([-.]\w+)</em>.\w+([-.]\w+)*</p>

<p>QQ号码： [1-9]\d{4,}</p>

<p>HTML标记(包含内容或自闭合)： &lt;(.<em>)(.</em>)>.<em>&lt;\/\1>|&lt;(.</em>) \/></p>

<p>密码(由数字/大写字母/小写字母/标点符号组成，四种都必有，8位以上)：    (?=^.{8,}$)(?=.<em>\d)(?=.</em>\W+)(?=.<em>[A-Z])(?=.</em>[a-z])(?!.<em>\n).</em>$</p>

<p>日期(年-月-日)：  (\d{4}|\d{2})-((1[0-2])|(0?[1-9]))-(([12][0-9])|(3[01])|(0?[1-9]))</p>

<p>日期(月/日/年)：  ((1[0-2])|(0?[1-9]))/(([12][0-9])|(3[01])|(0?[1-9]))/(\d{4}|\d{2})</p>

<p>时间(小时:分钟, 24小时制)：   ((1|0?)[0-9]|2[0-3]):([0-5][0-9])</p>

<p>汉字(字符)：   [\u4e00-\u9fa5]</p>

<p>中文及全角标点符号(字符)：  [\u3000-\u301e\ufe10-\ufe19\ufe30-\ufe44\ufe50-\ufe6b\uff01-\uffee]</p>

<p>中国大陆固定电话号码：   (\d{4}-|\d{3}-)?(\d{8}|\d{7})</p>

<p>中国大陆手机号码： 1\d{10}</p>

<p>中国大陆邮政编码： [1-9]\d{5}</p>

<p>中国大陆身份证号(15位或18位)：  \d{15}(\d\d[0-9xX])?</p>

<p>非负整数(正整数或零)：    \d+</p>

<p>正整数：    [0-9]<em>[1-9][0-9]</em></p>

<p>负整数：    -[0-9]<em>[1-9][0-9]</em></p>

<p>整数：   -?\d+</p>

<p>小数：   (-?\d+)(.\d+)?</p>

<p>不包含abc的单词：    \b((?!abc)\w)+\b</p>

<h3>后记</h3>

<p>整理这篇博文的过程中，当然涉及到的知识不仅仅是正则表达式，还有后面通过 webview 和 JavaScript 进行交互，这是另一方面的知识了，就不在这里介绍了。马上七夕情人节了，大家快乐。就写到这里啦，还没有准备礼物，赶紧准备，不然&hellip;</p>

<p>参考博文：<a href="http://deerchao.net/tutorials/regex/regex.htm">正则表达式30分钟入门教程</a></p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Bash - 趣味Shell]]></title>
        <link href="http://swplzj.github.io/blog/2015/08/14/bash-qu-wei-shell/"/>
        <updated>2015-08-14T11:27:23+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/08/14/bash-qu-wei-shell</id>
        <content type="html"><![CDATA[<p>今天抽闲玩了一下<code>Shell</code>，发现几个比较有意思的，记录一下。</p>

<ul>
<li>终端彩虹字：<code>lolcat</code></li>
<li>图形化文字：<code>figlet</code></li>
<li>幸运人生格言：<code>fortune</code></li>
<li><code>ASCII</code>牛说：<code>Cowsay</code></li>
<li>黑客帝国中瀑布流文字：<code>cmatrix</code></li>
<li>写在最后</li>
</ul>


<p>很有趣的 <code>Shell</code>， 值得一试；</p>

<!--more-->


<h3>lolcat</h3>

<p> <strong>安装</strong></p>

<p>由于 <code>Lolcat</code> 是一个 <code>ruby gem</code> 程序，所以在你的系统中必须安装有最新版本的 <code>ruby</code>。安装<code>ruby</code>过程不再详述；</p>

<p>使用下面命令进行安装<code>lolcat</code></p>

<pre><code>gem install lolcat
</code></pre>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_lolcat.png"></p>

<p><strong>使用</strong></p>

<p><code>lolcat</code>作用是在终端中为文本添加彩虹般的色彩。安装完成之后就可以使用了。</p>

<p>首先看一下<code>lolcat</code>的帮助文档</p>

<pre><code>lolcat --help
</code></pre>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_lolcat_help.png"></p>

<p>接着查看日历</p>

<pre><code>cal | lolcat
</code></pre>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_lolcat_cal.png"></p>

<p><strong>高级技巧</strong></p>

<p>我们还可以给文本赋予彩虹颜色的动画:</p>

<pre><code>echo Hello World | lolcat -a -d 500
</code></pre>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_lolcat_echo.gif"></p>

<p><strong>别名技巧:<code>alias</code></strong></p>

<p>我们发现，假如一个经常使用的打印命令，比如<code>ls</code>，想打印彩虹色彩，我们每次都需要在敲完<code>ls</code>之后再加上<code>lolcat</code>，也就是<code>ls | lolcat</code>，这样很不方便，这时我们就可以想到别名，<code>alias</code>。我们可以设定一些别名：</p>

<pre><code>alias ls="ls | lolcat"
</code></pre>

<p>但是，有一个问题来了，只要把终端这个标签关闭掉或者重启终端，我们设置的别名就失效了，也就是说别名只针对当前标签页有效。所以，接下来我们要设置<code>alias</code>永久有效，我们输入命令<code>cd ~</code>到用户主目录，找到<code>.bash_profile</code>文件，如果没有，我们创建一个</p>

<pre><code>touch .bash_profile
</code></pre>

<p>然后在<code>.bash_profile</code>中加入我们的别名</p>

<pre><code>alias ls="ls | lolcat"  
</code></pre>

<p>保存，关闭，重启<code>Terminal</code>，看一下效果：</p>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_lolcat_ls.png"></p>

<p><strong>BTW</strong></p>

<p>假如你的终端没有设置配色方案，可以选择自带的主题：<code>Silver Aerogel</code>，设置方法:找到<code>.bash_profile</code>文件，添加如下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># for color
</span><span class='line'>export CLICOLOR=1
</span><span class='line'># \h:\W \u\$
</span><span class='line'>export PS1='\[\033[01;33m\]\u@\h\[\033[01;31m\] \W\$\[\033[00m\] '</span></code></pre></td></tr></table></div></figure>


<p>保存，重启终端，就可以看到漂亮的配色方案了。</p>

<h3>figlet</h3>

<p><strong>安装</strong></p>

<p>我们使用 <code>Homebrew</code>来安装此插件，</p>

<pre><code>brew install figlet
</code></pre>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_figlet_install.png"></p>

<p><strong>使用</strong></p>

<ul>
<li>figlet</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lizhenjie@localhost ~$ figlet Leo Lee
</span><span class='line'> _                 _              
</span><span class='line'>| |    ___  ___   | |    ___  ___ 
</span><span class='line'>| |   / _ \/ _ \  | |   / _ \/ _ \
</span><span class='line'>| |__|  __/ (_) | | |__|  __/  __/
</span><span class='line'>|_____\___|\___/  |_____\___|\___|</span></code></pre></td></tr></table></div></figure>


<ul>
<li>figlist：列出所有字体名称</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lizhenjie@localhost ~$ figlist
</span><span class='line'>Default font: standard
</span><span class='line'>Font directory: /usr/local/Cellar/figlet/2.2.5/share/figlet/fonts
</span><span class='line'>Figlet fonts in this directory:
</span><span class='line'>3-d
</span><span class='line'>3x5
</span><span class='line'>5lineoblique
</span><span class='line'>acrobatic
</span><span class='line'>alligator
</span><span class='line'>alligator2
</span><span class='line'>alphabet
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<ul>
<li>showfigfonts：展示每个字体效果！</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lizhenjie@localhost ~$ showfigfonts
</span><span class='line'>3-d :
</span><span class='line'>  ****             **
</span><span class='line'> */// *           /**
</span><span class='line'>/    /*           /**
</span><span class='line'>   ***  *****  ******
</span><span class='line'>  /// */////  **///**
</span><span class='line'> *   /*      /**  /**
</span><span class='line'>/ ****       //******
</span><span class='line'> ////         ////// 
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>3x5 :
</span><span class='line'>            
</span><span class='line'>###     ### 
</span><span class='line'>  # # # #   
</span><span class='line'> ##  #  ### 
</span><span class='line'>  # # #   # 
</span><span class='line'>###     ### 
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<p>只能列两种字体了，太多了。</p>

<p>当然，可以结合上面的 <code>lolcat</code>使用更炫哦。</p>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_figlet_lolcat.png"></p>

<p><strong>Dashboard Figlet</strong></p>

<p>安装过程中，意外发现<code>Figlet</code>也有<code>Dashboard</code>中的插件，可以到<a href="http://www.apple.com/downloads/dashboard/email_messaging/figletwidget.html">苹果官网下载</a>，使用起来也是非常方便的。</p>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_lolcat_dashboard.png"></p>

<h3>fortune</h3>

<p><strong>安装</strong></p>

<pre><code>brew install fortune
</code></pre>

<p><strong>用法</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lizhenjie@localhost ~$ fortune
</span><span class='line'>"To take a significant step forward, you must make a series of finite 
</span><span class='line'>improvements."
</span><span class='line'>-- Donald J. Atwood, General Motors</span></code></pre></td></tr></table></div></figure>


<p>结合<code>lolcat</code>使用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lizhenjie@localhost ~$ fortune | lolcat</span></code></pre></td></tr></table></div></figure>


<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_fortune_lolcat.png"></p>

<h3>Cowsay</h3>

<p><strong>安装</strong></p>

<pre><code>brew install cowsay
</code></pre>

<p><strong>用法</strong></p>

<ul>
<li><code>cowsay</code>可以输出一个在终端用ASCII码组成的小牛，这个小牛会说出你想要它说的话。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lizhenjie@localhost ~$ cowsay God help them who help themselves!
</span><span class='line'> ____________________________________ 
</span><span class='line'>&lt; God help them who help themselves! &gt;
</span><span class='line'> ------------------------------------ 
</span><span class='line'>        \   ^__^
</span><span class='line'>         \  (oo)\_______
</span><span class='line'>            (__)\       )\/\
</span><span class='line'>                ||----w |
</span><span class='line'>                ||     ||
</span><span class='line'>lizhenjie@localhost ~$ 
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>罗列出所有可以画出的动物形状</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lizhenjie@localhost ~$ cowsay -l
</span><span class='line'>Cow files in /usr/local/Cellar/cowsay/3.03/share/cows:
</span><span class='line'>beavis.zen bong bud-frogs bunny cheese cower daemon default dragon
</span><span class='line'>dragon-and-cow elephant elephant-in-snake eyes flaming-sheep ghostbusters
</span><span class='line'>head-in hellokitty kiss kitty koala kosh luke-koala meow milk moofasa moose
</span><span class='line'>mutilated ren satanic sheep skeleton small sodomized stegosaurus stimpy
</span><span class='line'>supermilker surgery telebears three-eyes turkey turtle tux udder vader
</span><span class='line'>vader-koala www</span></code></pre></td></tr></table></div></figure>


<ul>
<li>使用其他动物形状</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lizhenjie@localhost ~$ cowsay -f dragon LEO
</span><span class='line'> _____ 
</span><span class='line'>&lt; LEO &gt;
</span><span class='line'> ----- 
</span><span class='line'>      \                    / \  //\
</span><span class='line'>       \    |\___/|      /   \//  \\
</span><span class='line'>            /0  0  \__  /    //  | \ \    
</span><span class='line'>           /     /  \/_/    //   |  \  \  
</span><span class='line'>           @_^_@'/   \/_   //    |   \   \ 
</span><span class='line'>           //_^_/     \/_ //     |    \    \
</span><span class='line'>        ( //) |        \///      |     \     \
</span><span class='line'>      ( / /) _|_ /   )  //       |      \     _\
</span><span class='line'>    ( // /) '/,_ _ _/  ( ; -.    |    _ _\.-~        .-~~~^-.
</span><span class='line'>  (( / / )) ,-{        _      `-.|.-~-.           .~         `.
</span><span class='line'> (( // / ))  '/\      /                 ~-. _ .-~      .-~^-.  \
</span><span class='line'> (( /// ))      `.   {            }                   /      \  \
</span><span class='line'>  (( / ))     .----~-.\        \-'                 .~         \  `. \^-.
</span><span class='line'>             ///.----..&gt;        \             _ -~             `.  ^-`  ^-_
</span><span class='line'>               ///-._ _ _ _ _ _ _}^ - - - - ~                     ~-- ,.-~
</span><span class='line'>                                                                  /.-~
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>结合<code>fortune</code>使用</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lizhenjie@localhost ~$ fortune | cowsay
</span><span class='line'> _________________________________________ 
</span><span class='line'>/ We are all worms. But I do believe I am \
</span><span class='line'>| a glowworm.                             |
</span><span class='line'>|                                         |
</span><span class='line'>\ -- Winston Churchill                    /
</span><span class='line'> ----------------------------------------- 
</span><span class='line'>        \   ^__^
</span><span class='line'>         \  (oo)\_______
</span><span class='line'>            (__)\       )\/\
</span><span class='line'>                ||----w |
</span><span class='line'>                ||     ||</span></code></pre></td></tr></table></div></figure>


<ul>
<li>结合<code>lolcat</code>使用：</li>
</ul>


<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_cowsay_lolcat.png"></p>

<ul>
<li>结合<code>lolcat + fortune + cowsay</code></li>
</ul>


<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_cowsay_lolcat_forturn.png"></p>

<p>是不是很神奇！！！</p>

<h3>cmatrix</h3>

<p><strong>安装</strong></p>

<p>黑客帝国‘Hacker’风格的桌面的生动画面</p>

<pre><code>brew install cmatrix
</code></pre>

<p><strong>用法</strong></p>

<pre><code>cmatrix 
</code></pre>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_cmatrix.png"></p>

<p>其他用法可以使用 <code>man</code>查看。</p>

<h3>写在最后</h3>

<p>上面的命令可能在实际中对自己没有多大用途，但是，在配置的过程中，学到了不少东西，还增加了对 <code>Shell</code>的了解和兴趣，我们对自己的定位不能只局限与写代码，而是让自己多去了解自己不了解的，时常去走出自己的舒适区，找一些有趣有挑战性的东西去做，总之，保证自己一直在进步，加油！</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Stay Hungry Stay Foolish]]></title>
        <link href="http://swplzj.github.io/blog/2015/08/11/stay-hungry/"/>
        <updated>2015-08-11T22:17:40+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/08/11/stay-hungry</id>
        <content type="html"><![CDATA[<p>今天又看了一遍乔帮主的演讲，每次观看，都能让我重新定位自己，重新审视自己，从自己身上找到答案。</p>

<p>乔布斯对操场上挤的满满的毕业生、校友和家长们说：“你的时间有限，所以最好别把它浪费在模仿别人这种事上。” &ndash;同样地，如果还在学校的话，似乎不应该去模仿退学的牛人们。</p>

<p>You&rsquo;ve got to find what you love,&lsquo; Jobs says
　　</p>

<p>Jobs说，你必须要找到你所爱的东西。
　　</p>

<p>This is the text of the Commencement address by Steve Jobs, CEO of Apple Computer and of Pixar Animation Studios, delivered on June 12, 2005.</p>

<p>这是苹果公司和Pixar动画工作室的CEO Steve Jobs于2005年6月12号在斯坦福大学的毕业典礼上面的演讲稿。</p>

<p>　　<!--more--></p>

<p>I am honored to be with you today at your commencement from one of the finest universities in the world. I never graduated from college. Truth be told, this is the closest I&rsquo;ve ever gotten to a college graduation. Today I want to tell you three stories from my life. That&rsquo;s it. No big deal. Just three stories.</p>

<p>　　我今天很荣幸能和你们一起参加毕业典礼，斯坦福大学是世界上最好的大学之一。我从来没有从大学中毕业。说实话,今天也许是在我的生命中离大学毕业最近的一天了。今天我想向你们讲述我生活中的三个故事。不是什么大不了的事情,只是三个故事而已。
　　</p>

<h3>　　The first story is about connecting the dots.</h3>

<h3>　　第一个故事是关于如何把生命中的点点滴滴串连起来。</h3>

<p>I dropped out of Reed College after the first 6 months, but then stayed around as a drop-in for another 18 months or so before I really quit. So why did I drop out?
　　</p>

<p>我在Reed大学读了六个月之后就退学了,但是在十八个月以后——我真正的作出退学决定之前,我还经常去学校。我为什么要退学呢?</p>

<p>　　It started before I was born. My biological mother was a young, unwed college graduate student, and she decided to put me up for adoption. She felt very strongly that I should be adopted by college graduates, so everything was all set for me to be adopted at birth by a lawyer and his wife. Except that when I popped out they decided at the last minute that they really wanted a girl.
　　</p>

<p>故事从我出生的时候讲起。我的亲生母亲是一个年轻的,没有结婚的大学毕业生。她决定让别人收养我, 她十分想让我被大学毕业生收养。所以在我出生的时候，她已经做好了一切的准备工作，能使得我被一个律师和他的妻子所收养。但是她没有料到,当我出生之后,律师夫妇突然决定他们想要一个女孩。</p>

<p>So my parents, who were on a waiting list, got a call in the middle of the night asking: &ldquo;We have an unexpected baby boy; do you want him?&rdquo; They said: &ldquo;Of course.&rdquo; My biological mother later found out that my mother had never graduated from college and that my father had never graduated from high school. She refused to sign the final adoption papers. She only relented a few months later when my parents promised that I would someday go to college.</p>

<p>所以我的生养父母(他们还在我亲生父母的观察名单上)突然在半夜接到了一个电话:“我们现在这儿有一个不小心生出来的男婴,你们想要他吗?”他们回答道:“当然!”但是我亲生母亲随后发现，我的养母从来没有上过大学,我的父亲甚至从没有读过高中。她拒绝签这个收养合同。只是在几个月以后,我的父母答应她一定要让我上大学,那个时候她才同意。</p>

<p>And 17 years later I did go to college. But I naively chose a college that was almost as expensive as Stanford, and all of my working-class parents' savings were being spent on my college tuition. After six months, I couldn&rsquo;t see the value in it. I had no idea what I wanted to do with my life and no idea how college was going to help me figure it out.</p>

<p>在十七岁那年,我真的上了大学。但是我很愚蠢的选择了一个几乎和你们斯坦福大学一样贵的学校, 我父母还处于蓝领阶层，他们几乎把所有积蓄都花在了我的学费上面。在六个月后, 我已经看不到其中的价值所在。我不知道我想要在生命中做什么,我也不知道大学能帮助我找到怎样的答案。</p>

<p>And here I was spending all of the money my parents had saved their entire life. So I decided to drop out and trust that it would all work out OK. It was pretty scary at the time, but looking back it was one of the best decisions I ever made. The minute I dropped out I could stop taking the required classes that didn&rsquo;t interest me, and begin dropping in on the ones that looked interesting.</p>

<p>但是在这里，我几乎花光了我父母这一辈子的所有积蓄。所以我决定要退学,我觉得这是个正确的决定。不能否认,我当时确实非常的害怕, 但是现在回头看看,那的确是我这一生中最棒的一个决定。在我做出退学决定的那一刻, 我终于可以不必去读那些令我提不起丝毫兴趣的课程了。然后我还可以去修那些看起来有点意思的课程。</p>

<p>It wasn&rsquo;t all romantic. I didn&rsquo;t have a dorm room, so I slept on the floor in friends' rooms, I returned coke bottles for the 5¢ deposits to buy food with, and I would walk the 7 miles across town every Sunday night to get one good meal a week at the Hare Krishna temple. I loved it. And much of what I stumbled into by following my curiosity and intuition turned out to be priceless later on. Let me give you one example:</p>

<p>但是这并不是那么罗曼蒂克。我失去了我的宿舍,所以我只能在朋友房间的地板上面睡觉,我去捡5美分的可乐瓶子，仅仅为了填饱肚子, 在星期天的晚上,我需要走七英里的路程，穿过这个城市到Hare Krishna寺庙(注：位于纽约Brooklyn下城),只是为了能吃上饭——这个星期唯一一顿好一点的饭。但是我喜欢这样。我跟着我的直觉和好奇心走, 遇到的很多东西,此后被证明是无价之宝。让我给你们举一个例子吧：</p>

<p>　　Reed College at that time offered perhaps the best calligraphy instruction in the country. Throughout the campus every poster, every label on every drawer, was beautifully hand calligraphed. Because I had dropped out and didn&rsquo;t have to take the normal classes, I decided to take a calligraphy class to learn how to do this.</p>

<p>Reed大学在那时提供也许是全美最好的美术字课程。在这个大学里面的每个海报, 每个抽屉的标签上面全都是漂亮的美术字。因为我退学了, 没有受到正规的训练, 所以我决定去参加这个课程，去学学怎样写出漂亮的美术字。</p>

<p>　　I learned about serif and san serif typefaces, about varying the amount of space between different letter combinations, about what makes great typography great. It was beautiful, historical, artistically subtle in a way that science can&rsquo;t capture, and I found it fascinating.
　　</p>

<p>我学到了san serif 和serif字体, 我学会了怎么样在不同的字母组合之中改变空格的长度, 还有怎么样才能作出最棒的印刷式样。那是一种科学永远不能捕捉到的、美丽的、真实的艺术精妙, 我发现那实在是太美妙了。</p>

<p>　　None of this had even a hope of any practical application in my life. But ten years later, when we were designing the first Macintosh computer, it all came back to me. And we designed it all into the Mac. It was the first computer with beautiful typography. If I had never dropped in on that single course in college, the Mac would have never had multiple typefaces or proportionally spaced fonts.
　　</p>

<p>当时看起来这些东西在我的生命中，好像都没有什么实际应用的可能。但是十年之后,当我们在设计第一台Macintosh电脑的时候,就不是那样了。我把当时我学的那些家伙全都设计进了Mac。那是第一台使用了漂亮的印刷字体的电脑。</p>

<p>　　And since Windows just copied the Mac, its likely that no personal computer would have them. If I had never dropped out, I would have never dropped in on this calligraphy class, and personal computers might not have the wonderful typography that they do. Of course it was impossible to connect the dots looking forward when I was in college. But it was very, very clear looking backwards ten years later.
　　</p>

<p>如果我当时没有退学, 就不会有机会去参加这个我感兴趣的美术字课程, Mac就不会有这么多丰富的字体，以及赏心悦目的字体间距。那么现在个人电脑就不会有现在这么美妙的字型了。当然我在大学的时候，还不可能把从前的点点滴滴串连起来,但是当我十年后回顾这一切的时候,真的豁然开朗了。</p>

<p>　　Again, you can&rsquo;t connect the dots looking forward; you can only connect them looking backwards. So you have to trust that the dots will somehow connect in your future. You have to trust in something - your gut, destiny, life, karma, whatever. This approach has never let me down, and it has made all the difference in my life.
　　</p>

<p>再次说明的是,你在向前展望的时候不可能将这些片断串连起来;你只能在回顾的时候将点点滴滴串连起来。所以你必须相信这些片断会在你未来的某一天串连起来。你必须要相信某些东西：你的勇气、目的、生命、因缘。这个过程从来没有令我失望(let me down),只是让我的生命更加地与众不同而已。</p>

<h3>　　My second story is about love and loss.</h3>

<h3>　　我的第二个故事是关于爱和损失的。</h3>

<p>　　I was lucky – I found what I loved to do early in life. Woz and I started Apple in my parents garage when I was 20. We worked hard, and in 10 years Apple had grown from just the two of us in a garage into a billion company with over 4000 employees. We had just released our finest creation - the Macintosh - a year earlier, and I had just turned 30.
　　</p>

<p>我非常幸运, 因为我在很早的时候就找到了我钟爱的东西。Woz和我在二十岁的时候就在父母的车库里面开创了苹果公司。我们工作得很努力, 十年之后, 这个公司从那两个车库中的穷光蛋发展到了超过四千名的雇员、价值超过二十亿的大公司。在公司成立的第九年,我们刚刚发布了最好的产品,那就是Macintosh。我也快要到三十岁了。</p>

<p>　　And then I got fired. How can you get fired from a company you started? Well, as Apple grew we hired someone who I thought was very talented to run the company with me, and for the first year or so things went well. But then our visions of the future began to diverge and eventually we had a falling out. When we did, our Board of Directors sided with him. So at 30 I was out. And very publicly out. What had been the focus of my entire adult life was gone, and it was devastating.
　　</p>

<p>在那一年, 我被炒了鱿鱼。你怎么可能被你自己创立的公司炒了鱿鱼呢? 嗯,在苹果快速成长的时候，我们雇用了一个很有天分的家伙和我一起管理这个公司, 在最初的几年,公司运转的很好。但是后来我们对未来的看法发生了分歧, 最终我们吵了起来。当争吵不可开交的时候, 董事会站在了他的那一边。所以在三十岁的时候, 我被炒了。在这么多人的眼皮下我被炒了。在而立之年，我生命的全部支柱离自己远去, 这真是毁灭性的打击。</p>

<p>I really didn&rsquo;t know what to do for a few months. I felt that I had let the previous generation of entrepreneurs down - that I had dropped the baton as it was being passed to me. I met with David Packard and Bob Noyce and tried to apologize for screwing up so badly.</p>

<p>在最初的几个月里，我真是不知道该做些什么。我把从前的创业激情给丢了, 我觉得自己让与我一同创业的人都很沮丧。我和David Pack和Bob Boyce见面，并试图向他们道歉。</p>

<p>　　I was a very public failure, and I even thought about running away from the valley. But something slowly began to dawn on me – I still loved what I did. The turn of events at Apple had not changed that one bit. I had been rejected, but I was still in love. And so I decided to start over.
　　</p>

<p>我把事情弄得糟糕透顶了。但是我渐渐发现了曙光, 我仍然喜爱我从事的这些东西。苹果公司发生的这些事情丝毫的没有改变这些, 一点也没有。我被驱逐了,但是我仍然钟爱它。所以我决定从头再来。</p>

<p>　　I didn&rsquo;t see it then, but it turned out that getting fired from Apple was the best thing that could have ever happened to me. The heaviness of being successful was replaced by the lightness of being a beginner again, less sure about everything. It freed me to enter one of the most creative periods of my life.
　　</p>

<p>我当时没有觉察, 但是事后证明, 从苹果公司被炒是我这辈子发生的最棒的事情。因为，作为一个成功者的极乐感觉被作为一个创业者的轻松感觉所重新代替: 对任何事情都不那么特别看重。这让我觉得如此自由, 进入了我生命中最有创造力的一个阶段。</p>

<p>　　During the next five years, I started a company named NeXT, another company named Pixar, and fell in love with an amazing woman who would become my wife. Pixar went on to create the worlds first computer animated feature film, Toy Story, and is now the most successful animation studio in the world.
　　</p>

<p>在接下来的五年里, 我创立了一个名叫NeXT的公司, 还有一个叫Pixar的公司, 然后和一个后来成为我妻子的优雅女人相识。Pixar 制作了世界上第一个用电脑制作的动画电影——“”玩具总动员”,Pixar现在也是世界上最成功的电脑制作工作室。</p>

<p>　　In a remarkable turn of events, Apple bought NeXT, I retuned to Apple, and the technology we developed at NeXT is at the heart of Apple&rsquo;s current renaissance. And Laurene and I have a wonderful family together.
　　</p>

<p>在后来的一系列运转中,Apple收购了NeXT, 然后我又回到了Apple公司。我们在NeXT发展的技术在Apple的复兴之中发挥了关键的作用。我还和Laurence 一起建立了一个幸福的家庭。</p>

<p>　　I&rsquo;m pretty sure none of this would have happened if I hadn&rsquo;t been fired from Apple. It was awful tasting medicine, but I guess the patient needed it. Sometimes life hits you in the head with a brick. Don&rsquo;t lose faith. I&rsquo;m convinced that the only thing that kept me going was that I loved what I did. You&rsquo;ve got to find what you love.
　　</p>

<p>我可以非常肯定,如果我不被Apple开除的话, 这其中一件事情也不会发生的。这个良药的味道实在是太苦了,但是我想病人需要这个药。有些时候, 生活会拿起一块砖头向你的脑袋上猛拍一下。不要失去信心。我很清楚唯一使我一直走下去的，就是我做的事情令我无比钟爱。你需要去找到你所爱的东西</p>

<p>　　And that is as true for your work as it is for your lovers. Your work is going to fill a large part of your life, and the only way to be truly satisfied is to do what you believe is great work. And the only way to do great work is to love what you do. If you haven&rsquo;t found it yet, keep looking. Don&rsquo;t settle. As with all matters of the heart, you&rsquo;ll know when you find it. And, like any great relationship, it just gets better and better as the years roll on. So keep looking until you find it. Don&rsquo;t settle.
　　</p>

<p>对于工作是如此, 对于你的爱人也是如此。你的工作将会占据生活中很大的一部分。你只有相信自己所做的是伟大的工作, 你才能怡然自得。如果你现在还没有找到, 那么继续找、不要停下来、全心全意的去找, 当你找到的时候你就会知道的。就像任何真诚的关系, 随着岁月的流逝只会越来越紧密。所以继续找，直到你找到它，不要停下来!</p>

<h3>　　My third story is about death.</h3>

<h3>　　我的第三个故事是关于死亡的。</h3>

<p>　　When I was 17, I read a quote that went something like: &ldquo;If you live each day as if it was your last, someday you&rsquo;ll most certainly be right.&rdquo; It made an impression on me, and since then, for the past 33 years, I have looked in the mirror every morning and asked myself: &ldquo;If today were the last day of my life, would I want to do what I am about to do today?&rdquo; And whenever the answer has been &ldquo;No&rdquo; for too many days in a row, I know I need to change something.
　　</p>

<p>当我十七岁的时候, 我读到了一句话:“如果你把每一天都当作生命中最后一天去生活的话,那么有一天你会发现你是正确的。”这句话给我留下了深刻的印象。从那时开始,过了33年,我在每天早晨都会对着镜子问自己:“如果今天是我生命中的最后一天, 你会不会完成你今天想做的事情呢?”当答案连续很多次被给予“不是”的时候, 我知道自己需要改变某些事情了。</p>

<p>　　Remembering that I&rsquo;ll be dead soon is the most important tool I&rsquo;ve ever encountered to help me make the big choices in life. Because almost everything – all external expectations, all pride, all fear of embarrassment or failure - these things just fall away in the face of death, leaving only what is truly important. Remembering that you are going to die is the best way I know to avoid the trap of thinking you have something to lose. You are already naked. There is no reason not to follow your heart.
　　</p>

<p>“记住你即将死去”是我一生中遇到的最重要箴言。它帮我指明了生命中重要的选择。因为几乎所有的事情, 包括所有的荣誉、所有的骄傲、所有对难堪和失败的恐惧,这些在死亡面前都会消失。我看到的是留下的真正重要的东西。你有时候会思考你将会失去某些东西,“记住你即将死去”是我知道的避免这些想法的最好办法。你已经赤身裸体了, 你没有理由不去跟随自己的心一起跳动。</p>

<p>　　About a year ago I was diagnosed with cancer. I had a scan at 7:30 in the morning, and it clearly showed a tumor on my pancreas. I didn&rsquo;t even know what a pancreas was. The doctors told me this was almost certainly a type of cancer that is incurable, and that I should expect to live no longer than three to six months. My doctor advised me to go home and get my affairs in order, which is doctor&rsquo;s code for prepare to die. It means to try to tell your kids everything you thought you&rsquo;d have the next 10 years to tell them in just a few months. It means to make sure everything is buttoned up so that it will be as easy as possible for your family. It means to say your goodbyes.
　　</p>

<p>大概一年以前, 我被诊断出癌症。我在早晨七点半做了一个检查, 检查清楚的显示在我的胰腺有一个肿瘤。我当时都不知道胰腺是什么东西。医生告诉我那很可能是一种无法治愈的癌症, 我还有三到六个月的时间活在这个世界上。我的医生叫我回家, 然后整理好我的一切, 那就是医生准备死亡的程序。那意味着你将要把未来十年对你小孩说的话在几个月里面说完.;那意味着把每件事情都搞定, 让你的家人会尽可能轻松的生活;那意味着你要说“再见了”。</p>

<p>　　I lived with that diagnosis all day. Later that evening I had a biopsy, where they stuck an endoscope down my throat, through my stomach and into my intestines, put a needle into my pancreas and got a few cells from the tumor. I was sedated, but my wife, who was there, told me that when they viewed the cells under a microscope the doctors started crying because it turned out to be a very rare form of pancreatic cancer that is curable with surgery. I had the surgery and I&rsquo;m fine now.
　　</p>

<p>我整天和那个诊断书一起生活。后来有一天早上我作了一个活切片检查，医生将一个内窥镜从我的喉咙伸进去,通过我的胃, 然后进入我的肠子, 用一根针在我的胰腺上的肿瘤上取了几个细胞。我当时很镇静,因为我被注射了镇定剂。但是我的妻子在那里, 后来告诉我，当医生在显微镜地下观察这些细胞的时候他们开始尖叫, 因为这些细胞最后竟然是一种非常罕见的可以用手术治愈的胰腺癌症。我做了这个手术, 现在我痊愈了。</p>

<p>　　This was the closest I&rsquo;ve been to facing death, and I hope its the closest I get for a few more decades. Having lived through it, I can now say this to you with a bit more certainty than when death was a useful but purely intellectual concept:</p>

<p>那是我最接近死亡的时候, 我还希望这也是以后的几十年最接近的一次。从死亡线上又活了过来, 死亡对我来说，只是一个有用但是纯粹是知识上的概念的时候，我可以更肯定一点地对你们说：</p>

<p>　　No one wants to die. Even people who want to go to heaven don&rsquo;t want to die to get there. And yet death is the destination we all share. No one has ever escaped it. And that is as it should be, because Death is very likely the single best invention of Life. It is Life&rsquo;s change agent. It clears out the old to make way for the new. Right now the new is you, but someday not too long from now, you will gradually become the old and be cleared away. Sorry to be so dramatic, but it is quite true.
　　</p>

<p>没有人愿意死, 即使人们想上天堂, 人们也不会为了去那里而死。但是死亡是我们每个人共同的终点。从来没有人能够逃脱它。也应该如此。 因为死亡就是生命中最好的一个发明。它将旧的清除以便给新的让路。你们现在是新的, 但是从现在开始不久以后, 你们将会逐渐的变成旧的然后被清除。我很抱歉这很戏剧性, 但是这十分的真实。</p>

<p>　　Your time is limited, so don&rsquo;t waste it living someone else&rsquo;s life. Don&rsquo;t be trapped by dogma - which is living with the results of other people&rsquo;s thinking. Don&rsquo;t let the noise of other&rsquo;s opinions drown out your own inner voice. And most important, have the courage to follow your heart and intuition. They somehow already know what you truly want to become. Everything else is secondary.
　　</p>

<p>When I was young, there was an amazing publication called The Whole Earth Catalog, which was one of the bibles of my generation. It was created by a fellow named Stewart Brand not far from here in Menlo Park, and he brought it to life with his poetic touch. This was in the late 1960&rsquo;s, before personal computers and desktop publishing, so it was all made with typewriters, scissors, and polaroid cameras. It was sort of like Google in paperback form, 35 years before Google came along: it was idealistic, and overflowing with neat tools and great notion</p>

<p>　　Stewart and his team put out several issues of The Whole Earth Catalog, and then when it had run its course, they put out a final issue. It was the mid-1970s, and I was your age. On the back cover of their final issue was a photograph of an early morning country road, the kind you might find yourself hitchhiking on if you were so adventurous. Beneath it were the words: &ldquo;Stay Hungry. Stay Foolish.&rdquo; It was their farewell message as they signed off. Stay Hungry. Stay Foolish. And I have always wished that for myself. And now, as you graduate to begin anew, I wish that for you.
　　</p>

<p>Stay Hungry. Stay Foolish.</p>

<p>Thank you all very much.</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Mac - Navicat Premium 11.0.16 破解记录]]></title>
        <link href="http://swplzj.github.io/blog/2015/08/06/mac-navicat-premium-11-dot-0-16-po-jie-ji-lu/"/>
        <updated>2015-08-06T16:13:08+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/08/06/mac-navicat-premium-11-dot-0-16-po-jie-ji-lu</id>
        <content type="html"><![CDATA[<p>今天在测试聚信立相关接口时候，需要改变用户在数据库中聚信立认证状态，需要后台人员频繁帮忙修改改数据库中的值，有些麻烦。同事之前给推荐的数据库管理软件又过了试用期，只能重新安装，自己动手，丰衣足食。这是我安装 <code>Navicat Premium</code> 并破解的记录，供大家参考。</p>

<!--more-->


<p>1、安装 <code>Navicat Premium</code></p>

<p>2、打开注册机(若注册机无法打开，右击-显示简介-选中以32位模式打开)</p>

<p>3、（默认选择）点击 <code>Generate</code> 获取激活码</p>

<p>4、点击 <code>Activata</code>，弹出选择程序的窗口，选择 <code>Navicat Premium</code>，操作系统支持10.10（本人系统是Yosimite 10.10.3）</p>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_06_my_os_version.png"></p>

<p>5、点击 <code>patched</code> 又弹出选择程序的窗口，选择 <code>Navicat Premium</code></p>

<p>6、恭喜注册成功</p>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_06_crack_success.png"></p>

<p><code>注意</code>　　
　　</p>

<p>如果还不能激活请在终端运行以下命令（非常重要）：
　　</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>rm -Rf ~/Library/Application\ Support/PremiumSoft\ CyberTech/Navicat*
</span><span class='line'>
</span><span class='line'>rm -Rf ~/Library/Caches/com.prect.NavicatPremium 
</span><span class='line'>
</span><span class='line'>rm -Rf ~/Library/Preferences/com.prect.NavicatPremium.plist
</span><span class='line'>
</span><span class='line'>sudo rm -Rf /Applications/Navicat\ Premium.app/
</span></code></pre></td></tr></table></div></figure>


<p>执行完成后重启（一定要重启）再安装 <code>Navicat Premium</code>，并再次执行破解过程！</p>

<p>附破解注册机及 <code>navicat Premimum11.0.16</code> <a href="http://pan.baidu.com/s/1eQmwQky">安装包下载地址</a></p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Objective-C 规范整理]]></title>
        <link href="http://swplzj.github.io/blog/2015/08/06/objective-c-gui-fan-zheng-li/"/>
        <updated>2015-08-06T09:54:19+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/08/06/objective-c-gui-fan-zheng-li</id>
        <content type="html"><![CDATA[<p>这份规范参考了一些主流公司的代码规范，也结合自己实战中的操作整理而成，也是我们 iOS 团队的代码约定，为了减少项目维护成本，大家可以参照。</p>

<h2>目录</h2>

<ul>
<li><a href="#%E5%85%B3%E4%BA%8EView%E7%9A%84%E5%B8%83%E5%B1%80">关于View的布局</a></li>
<li><a href="#%E7%82%B9%E8%AF%AD%E6%B3%95">点语法</a></li>
<li><a href="#%E9%97%B4%E8%B7%9D">间距</a></li>
<li><a href="#%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD">条件判断</a>

<ul>
<li><a href="#%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6">三目运算符</a></li>
</ul>
</li>
<li><a href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">错误处理</a></li>
<li><a href="#%E6%96%B9%E6%B3%95">方法</a></li>
<li><a href="#%E5%8F%98%E9%87%8F">变量</a></li>
<li><a href="#%E5%91%BD%E5%90%8D">命名</a></li>
<li><a href="#%E6%B3%A8%E9%87%8A">注释</a></li>
<li><a href="#init-%E5%92%8C-dealloc">Init 和 Dealloc</a></li>
<li><a href="#%E5%AD%97%E9%9D%A2%E9%87%8F">字面量</a></li>
<li><a href="#CGRect-%E5%87%BD%E6%95%B0">CGRect 函数</a></li>
<li><a href="#%E5%B8%B8%E9%87%8F">常量</a></li>
<li><a href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B">枚举类型</a></li>
<li><a href="#%E4%BD%8D%E6%8E%A9%E7%A0%81">位掩码</a></li>
<li><a href="#%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7">私有属性</a></li>
<li><a href="#%E5%9B%BE%E7%89%87%E5%91%BD%E5%90%8D">图片命名</a></li>
<li><a href="#%E5%B8%83%E5%B0%94">布尔</a></li>
<li><a href="#%E5%8D%95%E4%BE%8B">单例</a></li>
<li><a href="#%E5%AF%BC%E5%85%A5">导入</a></li>
<li><a href="#Xcode-%E5%B7%A5%E7%A8%8B">Xcode 工程</a></li>
</ul>


<!--more-->


<h2>关于View的布局</h2>

<p>应该 <strong>始终</strong> 使用纯代码自动布局来实现视图展示</p>

<h2>点语法</h2>

<p>应该 <strong>始终</strong> 使用点语法来访问或者修改属性，访问其他实例时首选括号。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>view.backgroundColor = [UIColor orangeColor];
</span><span class='line'>[UIApplication sharedApplication].delegate;</span></code></pre></td></tr></table></div></figure>


<p><strong>反对：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[view setBackgroundColor:[UIColor orangeColor]];
</span><span class='line'>UIApplication.sharedApplication.delegate;</span></code></pre></td></tr></table></div></figure>


<h2>间距</h2>

<ul>
<li>一个缩进使用 4 个空格，永远不要使用制表符（tab）缩进。请确保在 Xcode 中设置了此偏好。</li>
<li>使用 Xcode 中 re-indent 功能定期对代码格式进行整理。</li>
<li>方法的大括号和其他的大括号（<code>if</code>/<code>else</code>/<code>switch</code>/<code>while</code> 等等）始终和声明在同一行开始，在新的一行结束。</li>
</ul>


<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (user.isHappy) {
</span><span class='line'>// Do something
</span><span class='line'>}
</span><span class='line'>else {
</span><span class='line'>// Do something else
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>方法之间应该正好空一行，这有助于视觉清晰度和代码组织性。在方法中的功能块之间应该使用空白分开，但往往可能应该创建一个新的方法。</li>
<li><code>@synthesize</code> 和 <code>@dynamic</code> 在实现中每个都应该占一个新行。</li>
</ul>


<h2>条件判断</h2>

<p>条件判断主体部分应该始终使用大括号括住来防止出错，即使它可以不用大括号（例如它只需要一行）。这些错误包括添加第二行（代码）并希望它是 if 语句的一部分时。还有另外一种更危险的，当 if 语句里面的一行被注释掉，下一行就会在不经意间成为了这个 if 语句的一部分。此外，这种风格也更符合所有其他的条件判断，因此也更容易检查。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (!error) {
</span><span class='line'>    return success;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><strong>反对：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (!error)
</span><span class='line'>    return success;</span></code></pre></td></tr></table></div></figure>


<p>或</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (!error) return success;</span></code></pre></td></tr></table></div></figure>


<h3>三目运算符</h3>

<p>三目运算符，? ，只有当它可以增加代码清晰度或整洁时才使用。单一的条件都应该优先考虑使用。多条件时通常使用 if 语句会更易懂，或者重构为实例变量。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>result = a &gt; b ? x : y;</span></code></pre></td></tr></table></div></figure>


<p><strong>反对：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>result = a &gt; b ? x = c &gt; d ? c : d : y;</span></code></pre></td></tr></table></div></figure>


<h2>错误处理</h2>

<p>当引用一个返回错误参数（error parameter）的方法时，应该针对返回值，而非错误变量。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSError *error;
</span><span class='line'>if (![self trySomethingWithError:&error]) {
</span><span class='line'>    // 处理错误
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><strong>反对：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSError *error;
</span><span class='line'>[self trySomethingWithError:&error];
</span><span class='line'>if (error) {
</span><span class='line'>    // 处理错误
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>一些苹果的 API 在成功的情况下会写一些垃圾值给错误参数（如果非空），所以针对错误变量可能会造成虚假结果（以及接下来的崩溃）。</p>

<h2>方法</h2>

<p>在方法签名中，在 -/+ 符号后应该有一个空格。方法片段之间也应该有一个空格。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)setExampleText:(NSString *)text image:(UIImage *)image;</span></code></pre></td></tr></table></div></figure>


<p><strong>对方法进行分组</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#pragma mark - View Life Cycle //视图生命周期
</span><span class='line'>#pragma mark - AutoLayout Methods//适配
</span><span class='line'>#pragma mark - Private Methods//私有方法
</span><span class='line'>#pragma mark - UITableView Delegate
</span><span class='line'>#pragma mark - UITableView Datasource
</span><span class='line'>#pragma mark - Event Response//事件处理
</span><span class='line'>#pragma mark - Getter And Setter//放到下面
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<h2>变量</h2>

<p>变量名应该尽可能命名为描述性的。除了 <code>for()</code> 循环外，其他情况都应该避免使用单字母的变量名。
星号表示指针属于变量，例如：<code>NSString *text</code> 不要写成 <code>NSString* text</code> 或者 <code>NSString * text</code> ，常量除外。
尽量定义属性来代替直接使用实例变量。除了初始化方法（<code>init</code>， <code>initWithCoder:</code>，等）， <code>dealloc</code> 方法和自定义的 setters 和 getters 内部，应避免直接访问实例变量。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface UCSection: NSObject
</span><span class='line'>
</span><span class='line'>@property (nonatomic) NSString *headline;
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p><strong>反对：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface UCSection : NSObject {
</span><span class='line'>    NSString *headline;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>变量限定符</h4>

<p>当涉及到在 ARC 中被引入变量限定符时，
限定符 (<code>__strong</code>, <code>__weak</code>, <code>__unsafe_unretained</code>, <code>__autoreleasing</code>) 应该位于星号和变量名之间，如：<code>NSString * __weak text</code>。</p>

<h2>命名</h2>

<p>尽可能遵守苹果的命名约定，尤其那些涉及到内存管理规则的。</p>

<p>长的和描述性的方法名和变量名都不错。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIButton *settingsButton;</span></code></pre></td></tr></table></div></figure>


<p><strong>反对：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIButton *setBut;</span></code></pre></td></tr></table></div></figure>


<p>类名和常量应该始终使用项目前缀（例如 UCredit <code>UC</code>），但 Core Data 实体名称可以省略。为了代码清晰，常量应该使用相关类的名字作为前缀并使用驼峰命名法。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static const NSTimeInterval UCHomeViewControllerNavigationFadeAnimationDuration = 0.3;</span></code></pre></td></tr></table></div></figure>


<p><strong>反对：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static const NSTimeInterval fadetime = 1.7;</span></code></pre></td></tr></table></div></figure>


<p>属性和局部变量应该使用驼峰命名法并且首字母小写。</p>

<p>为了保持一致，实例变量应该使用驼峰命名法命名，并且首字母小写，以下划线为前缀。这与 LLVM 自动合成的实例变量相一致。</p>

<p>项目相关的类：使用项目中自定义的前缀，使用UC作前缀</p>

<p><strong>推荐</strong></p>

<pre><code>UCHomeViewController
</code></pre>

<p><strong>后缀要求</strong></p>

<ul>
<li>ViewController：使用ViewController作后缀</li>
<li>View：使用View作后缀</li>
<li>UITableCell：使用Cell作后缀</li>
<li>Protocol：使用Delegate或DataSource作后缀</li>
</ul>


<p><strong>宏命名</strong></p>

<p>全大写，单词间用 _ 分隔</p>

<pre><code>eg：#define THIS_IS_AN_MACRO @"THIS_IS_AN_MACRO"   
</code></pre>

<h2>注释</h2>

<p>当需要的时候，注释应该被用来解释 <strong>为什么</strong> 特定代码做了某些事情。所使用的任何注释必须保持最新否则就删除掉。</p>

<p>通常应该避免一大块注释，代码就应该尽量作为自身的文档，只需要隔几行写几句说明。这并不适用于那些用来生成文档的注释。注释需要与代码同步更新。</p>

<h2>init 和 dealloc</h2>

<p><code>dealloc</code> 方法应该放在实现文件的最上面，并且刚好在 <code>@synthesize</code> 和 <code>@dynamic</code> 语句的后面。在任何类中，<code>init</code> 都应该直接放在 <code>dealloc</code> 方法的下面。</p>

<p><code>init</code> 方法的结构应该像这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (instancetype)init {
</span><span class='line'>    self = [super init]; // 或者调用指定的初始化方法
</span><span class='line'>    if (self) {
</span><span class='line'>        // Custom initialization
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    return self;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>字面量</h2>

<p>每当创建 <code>NSString</code>， <code>NSDictionary</code>， <code>NSArray</code>，和 <code>NSNumber</code> 类的不可变实例时，都应该使用字面量。要注意 <code>nil</code> 值不能传给 <code>NSArray</code> 和 <code>NSDictionary</code> 字面量，这样做会导致崩溃。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSArray *names = @[@"Brian", @"Matt", @"Chris", @"Alex", @"Steve", @"Paul"];
</span><span class='line'>NSDictionary *productManagers = @{@"iPhone" : @"Kate", @"iPad" : @"Kamal", @"Mobile Web" : @"Bill"};
</span><span class='line'>NSNumber *shouldUseLiterals = @YES;
</span><span class='line'>NSNumber *buildingZIPCode = @10018;</span></code></pre></td></tr></table></div></figure>


<p><strong>反对：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSArray *names = [NSArray arrayWithObjects:@"Brian", @"Matt", @"Chris", @"Alex", @"Steve", @"Paul", nil];
</span><span class='line'>NSDictionary *productManagers = [NSDictionary dictionaryWithObjectsAndKeys: @"Kate", @"iPhone", @"Kamal", @"iPad", @"Bill", @"Mobile Web", nil];
</span><span class='line'>NSNumber *shouldUseLiterals = [NSNumber numberWithBool:YES];
</span><span class='line'>NSNumber *buildingZIPCode = [NSNumber numberWithInteger:10018];</span></code></pre></td></tr></table></div></figure>


<h2>CGRect 函数</h2>

<p>当访问一个 <code>CGRect</code> 的 <code>x</code>， <code>y</code>， <code>width</code>， <code>height</code> 时，应该使用<code>CGGeometry</code> 函数代替直接访问结构体成员。苹果的 <code>CGGeometry</code> 参考中说到：</p>

<blockquote><p>All functions described in this reference that take CGRect data structures as inputs implicitly standardize those rectangles before calculating their results. For this reason, your applications should avoid directly reading and writing the data stored in the CGRect data structure. Instead, use the functions described here to manipulate rectangles and to retrieve their characteristics.</p></blockquote>

<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CGRect frame = self.view.frame;
</span><span class='line'>
</span><span class='line'>CGFloat x = CGRectGetMinX(frame);
</span><span class='line'>CGFloat y = CGRectGetMinY(frame);
</span><span class='line'>CGFloat width = CGRectGetWidth(frame);
</span><span class='line'>CGFloat height = CGRectGetHeight(frame);</span></code></pre></td></tr></table></div></figure>


<p><strong>反对：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CGRect frame = self.view.frame;
</span><span class='line'>
</span><span class='line'>CGFloat x = frame.origin.x;
</span><span class='line'>CGFloat y = frame.origin.y;
</span><span class='line'>CGFloat width = frame.size.width;
</span><span class='line'>CGFloat height = frame.size.height;</span></code></pre></td></tr></table></div></figure>


<h2>常量</h2>

<p>常量首选内联字符串字面量或数字，因为常量可以轻易重用并且可以快速改变而不需要查找和替换。常量应该声明为 <code>static</code> 常量而不是 <code>#define</code> ，除非非常明确地要当做宏来使用。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static NSString * const UCAboutViewControllerCompanyName = @"The UCredit Company";
</span></code></pre></td></tr></table></div></figure>


<p><strong>反对：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define CompanyName @"The UCredit Company"</span></code></pre></td></tr></table></div></figure>


<h2>枚举类型</h2>

<p>当使用 <code>enum</code> 时，建议使用新的基础类型规范，因为它具有更强的类型检查和代码补全功能。现在 SDK 包含了一个宏来鼓励使用使用新的基础类型 - <code>NS_ENUM()</code></p>

<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef NS_ENUM(NSInteger,UCAdRequestState) {
</span><span class='line'>      UCAdRequestStateInactive,
</span><span class='line'>    UCAdRequestStateLoading
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<h2>位掩码</h2>

<p>当用到位掩码时，使用 <code>NS_OPTIONS</code> 宏。</p>

<p><strong>举例：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef NS_OPTIONS(NSUInteger, UCAdCategory) {
</span><span class='line'>UCAdCategoryAutos      = 1 &lt;&lt; 0,
</span><span class='line'>UCAdCategoryJobs       = 1 &lt;&lt; 1,
</span><span class='line'>UCAdCategoryRealState  = 1 &lt;&lt; 2,
</span><span class='line'>UCAdCategoryTechnology = 1 &lt;&lt; 3
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<h2>私有属性</h2>

<p>私有属性应该声明在类实现文件的延展（匿名的类目）中。有名字的类目（例如 <code>UCPrivate</code> 或 <code>private</code>）永远都不应该使用，除非要扩展其他类。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface UCAdvertisement ()
</span><span class='line'>
</span><span class='line'>@property (nonatomic, strong) GADBannerView *googleAdView;
</span><span class='line'>@property (nonatomic, strong) ADBannerView *iAdView;
</span><span class='line'>@property (nonatomic, strong) UIWebView *adXWebView;
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<h2>图片命名</h2>

<p>为了便于图片资源的管理和维护，图片统一使用Image.xcassets，图片名称应该被统一命名以保持组织的完整。它们应该被命名为一个说明它们用途的带下划线字符串，其次是自定义类或属性的无前缀名字（如果有的话），然后进一步说明颜色 和/或 展示位置，最后是它们的状态。</p>

<p><strong>推荐：</strong></p>

<ul>
<li><code>smile_tab_default_selected@2x</code> / <code>smile_tab_default_selected@3x</code></li>
<li><code>sidebar_bg_mask_white@2x</code> / <code>sidebar_bg_mask_white@3x</code></li>
</ul>


<p>图片目录中被用于类似目的的图片应归入各自的组中。</p>

<h2>布尔</h2>

<p>因为 <code>nil</code> 解析为 <code>NO</code>，所以没有必要在条件中与它进行比较。永远不要直接和 <code>YES</code> 进行比较，因为 <code>YES</code> 被定义为 1，而 <code>BOOL</code> 可以多达 8 位。</p>

<p>这使得整个文件有更多的一致性和更大的视觉清晰度。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (!someObject) {
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><strong>反对：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (someObject == nil) {
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<hr />

<p><strong>对于 <code>BOOL</code> 来说, 这有两种用法:</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (isAwesome)
</span><span class='line'>if (![someObject boolValue])</span></code></pre></td></tr></table></div></figure>


<p><strong>反对：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if ([someObject boolValue] == NO)
</span><span class='line'>if (isAwesome == YES) // 永远别这么做</span></code></pre></td></tr></table></div></figure>


<hr />

<p>如果一个 <code>BOOL</code> 属性名称是一个形容词，属性可以省略 “is” 前缀，但为 get 访问器指定一个惯用的名字，例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@property (assign, getter=isEditable) BOOL editable;</span></code></pre></td></tr></table></div></figure>


<p>内容和例子来自 Cocoa 命名指南。</p>

<h2>单例</h2>

<p>单例对象应该使用线程安全的模式创建共享的实例。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (instancetype)sharedInstance {
</span><span class='line'>   static id sharedInstance = nil;
</span><span class='line'>
</span><span class='line'>   static dispatch_once_t onceToken;
</span><span class='line'>   dispatch_once(&onceToken, ^{
</span><span class='line'>      sharedInstance = [[self alloc] init];
</span><span class='line'>   });
</span><span class='line'>
</span><span class='line'>   return sharedInstance;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这将会预防有时可能产生的许多崩溃。</p>

<h2>导入</h2>

<p>如果有一个以上的 import 语句，就对这些语句进行分组。每个分组的注释是可选的。 <br/>
注：对于模块使用 @import 语法。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Frameworks
</span><span class='line'>@import QuartzCore;
</span><span class='line'>
</span><span class='line'>// Models
</span><span class='line'>#import "UCUser.h"
</span><span class='line'>
</span><span class='line'>// Views
</span><span class='line'>#import "UCButton.h"
</span><span class='line'>#import "UCUserView.h"</span></code></pre></td></tr></table></div></figure>


<p></p>

<h2>Xcode 工程</h2>

<p>为了避免文件杂乱，物理文件应该保持和 Xcode 项目文件同步。Xcode 创建的任何组（group）都必须在文件系统有相应的映射。为了更清晰，代码不仅应该按照类型进行分组，也可以根据功能进行分组。</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[iOS - '#'引发的思考]]></title>
        <link href="http://swplzj.github.io/blog/2015/08/04/ios-number-yin-fa-de-si-kao/"/>
        <updated>2015-08-04T18:37:45+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/08/04/ios-number-yin-fa-de-si-kao</id>
        <content type="html"><![CDATA[<p>在代码中使用 <code>Autolayout</code> 时，大家都会使用 <code>NSDictionaryOfVariableBindings</code> 这个宏，这个宏可以生成一个变量名到变量值映射的 <code>Dictionary</code>。比如 <code>NSDictionaryOfVariableBindings(button1, button2)</code> 将会生成一个<code>{ @"button1" = button1, @"button2 = button2 }</code> 的 <code>Dictionary</code>。它是怎么做到的呢？我们来看看这个宏的定义：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define NSDictionaryOfVariableBindings(...) _NSDictionaryOfVariableBindings(@"" # __VA_ARGS__, __VA_ARGS__, nil)</span></code></pre></td></tr></table></div></figure>


<p>这个宏定义中有3个参数，后两个参数不难理解，但第一个参数中间有个 <code>#</code> 符号，语法上看起来比较怪异，这个是什么呢？以前在做越狱的 <code>mobilesubstrate</code> 开发时，其中定义的一堆宏频繁使用了这个符号，下面就来揭开 <code>#</code> 这个符号在宏定义中的迷雾。</p>

<!--more-->


<h3>预编译的一些知识</h3>

<p>我们的代码在 <code>build</code> 时并不是直接进行编译的，在编译之前还进行了预编译处理。预编译会把 <code>include</code> 或 <code>import</code> 的文件导入到文件中，同时会将代码中用到的宏进行替换。注意宏是直接在代码中替换成宏的定义的，如果有嵌套也会逐层替换。</p>

<h3>“#”指示一些预编译命令</h3>

<p>预编译命令一般都是以 <code>#</code> 开头的，比如 <code>#include</code>、<code>#import</code>、<code>#if</code> 等，在这里就不一一说明了，本文主要说明一下 <code>#</code> 在宏定义里面的一些作用。</p>

<h3>宏参数字符串化</h3>

<p>在一个参数前加一个<code>#</code>，预处理时将会变成这个参数名的字符串常量，即字符串化（<code>stringify</code>）。比如:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define GET_NAME(X) #X
</span><span class='line'>int a = 0;
</span><span class='line'>NSLog(@"%s",GET_NAME(a));      //output: "a"
</span><span class='line'>NSLog(@"%s",GET_NAME(a+3));    //output: "a+3"</span></code></pre></td></tr></table></div></figure>


<p>将会得到以下输出：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a
</span><span class='line'>a+3</span></code></pre></td></tr></table></div></figure>


<p>可以看出<code>#</code>，将参数原样转换成字符串常量，如果参数是一个表达式，那么输出这个表达式的原样字符串常量。</p>

<p>回头再看看<code>NSDictionaryOfVariableBindings</code>的定义：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define NSDictionaryOfVariableBindings(...) _NSDictionaryOfVariableBindings(@"" # __VA_ARGS__, __VA_ARGS__, nil)</span></code></pre></td></tr></table></div></figure>


<p>如果这样生成两个<code>button</code>的映射：</p>

<pre><code>NSDictionaryOfVariableBindings(button1, button2);
</code></pre>

<p>那么预编译时就会转换成：</p>

<pre><code>_NSDictionaryOfVariableBindings(@"""button1, button2", button1, button2, nil);
</code></pre>

<p>由于两个常量字符串放在一起就是字符串常量串联，将变成两个字符串常量组合在一起的字符串常量，也就是上面是一个空字符串<code>""</code>和<code>"button1, button2"</code>串联，所以上面的代码等价于：</p>

<pre><code>_NSDictionaryOfVariableBindings(@"button1, button2", button1, button2, nil);
</code></pre>

<p>那么<code>_NSDictionaryOfVariableBindings</code>函数就可以将它的第一个参数按逗号,分割开作为<code>key</code>，后面就是各个<code>key</code>对应的值了。因此这段代码就创建了一个内容为<code>{ @"button1" = button1, @"button2 = button2 }</code>的<code>Dictionary</code>。</p>

<h3>命名的串联</h3>

<p><code>#</code>在宏定义中的另一个作用就是用于命名的串联，用<code>##</code>就可以串联它左右两边的命名，比如以下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define CONCAT(X, Y) X ## Y
</span><span class='line'>NSString *helloworld = @"Hello, world!";
</span><span class='line'>NSLog(@"%@",CONCAT(hello, world)); //output: "Hello, world"</span></code></pre></td></tr></table></div></figure>


<p><code>CONCAT(hello, world)</code>实际被转换成<code>helloworld</code>。注意一下，因为宏是预编译阶段进行展开的，就是说在编译之前，因此代码中的<code>hello</code>和<code>world</code>即使没有定义其实也是没问题的，预编译处理后，这两个命名是不存在的。</p>

<h3>可选可变参数</h3>

<p><code>##</code>在宏定义中可以放在<code>__VA_ARGS__</code>之前表示可变参数可以为空，否则的话可变参数至少为一个了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define MYLOG(format, ...) NSLog(format, ##__VA_ARGS__)
</span><span class='line'>MYLOG(@"Don't make an error!");</span></code></pre></td></tr></table></div></figure>


<p>上面代码中<code>MLOG</code>中只有一个参数，如果不加<code>##</code>，则<code>MLOG</code>至少需要两个参数，在<code>Xcode</code>里将会出现编译错误。</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Mac - 截屏功能高级篇]]></title>
        <link href="http://swplzj.github.io/blog/2015/08/04/mac-jie-ping-gong-neng-gao-ji-pian/"/>
        <updated>2015-08-04T16:29:59+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/08/04/mac-jie-ping-gong-neng-gao-ji-pian</id>
        <content type="html"><![CDATA[<p>截屏在平常应该是最常用的功能了，虽然说有一些工具可以提供截屏，比如 QQ 带的截屏功能，但是默认的快捷键可能与系统自定义冲突，或者使用鼠标不方便。其实，系统本身所提供的截屏功能，足够我们使用，你真的认为你掌握了截屏功能？那进来看看吧。</p>

<!--more-->


<h3>最常用的截屏：</h3>

<ol>
<li>command + shift + 3  &ndash; 截取全屏</li>
<li>command + shift + 4  &ndash; 自定义大小截屏</li>
<li>command + shift + 4 + space &ndash; 截取特定区域</li>
</ol>


<h3>高级功能 - 在 command + shift + 4 之后</h3>

<ol>
<li>长按空格 &ndash; 移动截屏区域；</li>
<li>长按 shift &ndash; 固定高度（宽度），调整截取区域宽度（高度）；</li>
<li>长按 option &ndash; 以中心点为中心宽度（高度）同时增加；</li>
<li>同时长按 shift + option 固定高度（宽度），以中心点为中心调整截取区域宽度（高度）；</li>
<li>command + shift + control &ndash; 把截图 copy 到剪贴板</li>
</ol>

]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[博客升级了]]></title>
        <link href="http://swplzj.github.io/blog/2015/07/31/bo-ke-sheng-ji-liao/"/>
        <updated>2015-07-31T19:17:56+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/07/31/bo-ke-sheng-ji-liao</id>
        <content type="html"><![CDATA[<p>博客其实早就搭建了，中间发布过一些文章，可是博客一直没有升级，现在针对以下几个功能进行了添加及优化。</p>

<ul>
<li>更换主题</li>
<li>添加站长统计</li>
<li>添加多说评论</li>
<li>添加七牛云图片存储服务</li>
<li>自动为图片添加url前缀</li>
<li>写在最后</li>
</ul>


<!--more-->


<h3>更换主题</h3>

<p>搭建完博客之后，接着就要更换为自己喜欢的主题了，选择的主题是 <a href="http://sofreshandsogreen.herokuapp.com">So Fresh and So Green</a>，喜欢这种带有活力的色调。具体设置步骤如下：</p>

<p><code>Step 1</code></p>

<p>使用命令安装主题；</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git clone https://github.com/johnkeith/sofreshandsogreen.git .themes/sofreshandsogreen
</span><span class='line'>  
</span><span class='line'>$ bundle exec rake install['sofreshandsogreen']</span></code></pre></td></tr></table></div></figure>


<p><code>Step 2</code></p>

<p>更改博客配置文件  <code>_config.yml</code>，需要移除默认主题的侧边栏，</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>default_asides: []
</span><span class='line'>sidebar: collapse</span></code></pre></td></tr></table></div></figure>


<p><code>Step 3</code></p>

<p>在首页显示显示圆形头像，首先到 <code>source/images</code>目录下面，使用你选择的头像替换掉 <code>portrait.jpg</code>, 然后再配置文件 <code>_config.yml</code> 中，添加下面一句代码：</p>

<pre><code>portrait: true
</code></pre>

<p>（BTW：我选择的头像使我们几个朋友一起亲手绘画的梵高的向日葵，色调与博客主题色调完美搭配，赞一个~~）</p>

<p>至此，博客主题安装完成。</p>

<h3>添加站长统计</h3>

<p>博客搭建完成之后，需要看自己博客被访问次数，访问页面，访问速度，页面停留时间&hellip;等等，都需要借助第三方的统计工具来完成的，类似于移动端 App 使用的友盟统计一样，这个还要简单只需要注册相应的账号，然后，在自己博客中添加官方提供的 JS 代码。我选择的是国内使用很广的 <a href="http://www.cnzz.com">CNZZ</a>，注册后，添加并验证你的网站就可以添加统计代码了，选好自己喜欢的样式，获得代码，可添加到 <code>source/_includes/custom/footer.html</code> 中。即可查看每天你的博客的流量，进行相应的优化了。</p>

<pre><code>&lt;script type="text/javascript"&gt;var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1255930196'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1255930196%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));&lt;/script&gt;
</code></pre>

<h3>添加多说评论</h3>

<p>Octopress默认自带了 <code>DISQUS</code> ，但是对于国内不是很好用，于是选择了多说作为评论插件，这个还是很接地气的。多说官网账号无需注册，我是使用的百度账号来进行设置，添加站点，获取站点 <code>short_name</code>。这个</p>

<p>在配置文件 <code>_config.yml</code> 中，添加以下代码：</p>

<pre><code>duoshuo_comments: true
duoshuo_short_name: yoursite (多说二级域名 yoursite.duoshuo.com)(yoursite是你在多说中添加的站点名称)
</code></pre>

<p>在 <code>source/_layouts/post.html</code> 中 <code>disqus</code> 代码下方添加<a href="https://github.com/swplzj/swplzj.github.io/blob/source/source/_layouts/post.html">多说代码本想粘贴出代码，但是一直显示不全只能留源文件地址了。</a></p>

<p>然后，在路径 <code>source/_includes/post</code>下创建一个 <code>duoshuo.html</code>, <a href="https://github.com/swplzj/swplzj.github.io/blob/source/source/_includes/post/duoshuo.html">直接上文件地址</a></p>

<p>到此为止，添加多说评论完成。</p>

<h3>添加七牛云存储作为图床</h3>

<p>博客其实已经可以正常发布博文，展示，数据统计，评论，归档等功能了，但是一直有个特殊情景，在困扰着我，假如我想发布一篇博文，博文中包含很多图片，大家都知道在 Markdown 语言中添加一张图片，是很简单的，直接使用语法，发一个图片地址就可以了。但是这个图片放到本地，然后随博客同步到 GitHub 上的话，就会造成两个主要问题，第一，在国内由于网络问题，加载图片特别缓慢；第二，GitHub 免费存储是固定的，用来当做图床，不是明智之举，鉴于此，就寻找国内比较稳定优秀的图床。最终选择了七牛云存储，优点：访问速度极快，支持日志、防盗链和水印。然后有了图床，就解决了图片存储的问题，流程就是，先把博文中所要使用的图片，先上传到七牛上，然后拿到获取此资源的链接，写到博文中，就可以了。</p>

<h3>自动为图片添加url前缀</h3>

<p>我把图片资源都放在了七牛云存储上，写博客时候就是用七牛的外链。但是这样有几个问题：
每次写博客插入图片外链地址时候都很麻烦，需要给每张图片都添加七牛外链地址url前缀；
如果以后更换了存储，那就麻烦了，需要依次编辑替换每个图片的url前缀
现在我们就使用一种灵活的方式来配置并自动生成图片的url前缀：</p>

<p>1.修改 <code>/plugins/image_tag.rb</code> 文件，在</p>

<pre><code>@img['class'].gsub!(/"/, '') if @img['class']
</code></pre>

<p>后添加下面一行代码：</p>

<pre><code>@img['src'] = Jekyll.configuration({})['static_file_prefix'] + @img['src'] if @img['src'][0] == '/'
</code></pre>

<p>2.再修改根目录下的 <code>_config.yml</code> 文件，添加如下配置：</p>

<pre><code>static_file_prefix: http://7u2i08.com1.z0.glb.clouddn.com
</code></pre>

<p>这样在生成文章的时候，以 <code>/</code> 开头的图片会自动加上 <code>http://7u2i08.com1.z0.glb.clouddn.com</code> 前缀。</p>

<p>3.我们在插入图片的时候要记住不能再使用 Markdown 语法来写了，要使用 Ocotpress 自定义的 <code>Image Tag</code> 来插入图片。</p>

<p>4.使用 <a href="http://developer.qiniu.com/docs/v6/tools/qrsync.html"><code>qrsync</code></a> 同步图片资源。<code>qrsync</code> 是一个根据七牛云存储API实现的简易命令行辅助上传同步工具，支持断点续上传，增量同步，它可将用户本地的某目录的文件同步到七牛云存储中，同步或上传几百GB甚至上TB的文件毫无鸭梨。
下载对应的命令行辅助同步工具，我使用的Mac，下载完成后，解压出命令执行文件，放到 <code>/usr/local/bin</code> 目录下。</p>

<p>5.创建一个配置文件（<a href="http://json.org/json-zh.html">JSON格式</a>）,可以命名为 <code>qrsync.json</code>,输入以下配置</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "debug_level" : 1,
</span><span class='line'>  "deletable" : 0,
</span><span class='line'>  "dest" : "qiniu:access_key=yourAccessKey&secret_key=yourSecretKey&bucket=yourSpaceName",
</span><span class='line'>  "src" : "/Users/yourname/octopress/source/images"
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>其中，<code>AccessKey</code> 和 <code>SecretKey</code> 就是之前咱们在七牛云存储平台上申请的。如图所示：</p>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_03_qi_niu_key.png"></p>

<table>
<thead>
<tr>
<th>参数              </th>
<th> 备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>debug_level     </td>
<td>  日志输出等级（通常设置1，只输出必要的日志）</td>
</tr>
<tr>
<td>deletable       </td>
<td> 是否同步删除七牛云上的文件（通常设置0，当本地文件删除时并不删除存储在七牛的对应文件）</td>
</tr>
<tr>
<td>src             </td>
<td> 本地源目录路径（本地需要同步上传目录的完整的绝对路径）</td>
</tr>
<tr>
<td>bucket          </td>
<td> 目标空间名称</td>
</tr>
</tbody>
</table>


<p>这样就可以使用七牛的资源同步辅助命令了。
本地预览先 <code>rake generate</code> 后 <code>rake preview</code> ，这样插入图片就灵活方便多了。</p>

<p><code>注意1</code></p>

<p>在 <code>rake generate</code> 时，我这里遇到一个错误，报错如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Configuration file: /Users/lizhenjie/octopress/_config.yml
</span><span class='line'>  Liquid Exception: undefined method `+' for nil:NilClass in _posts/2015-07-30-test.markdown/#excerpt
</span><span class='line'>jekyll 2.5.3 | Error:  undefined method `+' for nil:NilClass</span></code></pre></td></tr></table></div></figure>


<p>经过搜索，发现如果要把两个字符串连接在一起。如</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a = “abc”
</span><span class='line'>b = a + “de”</span></code></pre></td></tr></table></div></figure>


<p>此时b的值为 <code>abcde</code>
但如果 <code>a = nil</code> 时，就会抛出未定义“+”的异常，因为此时a为nil。仔细检查发现修改完 <code>/plugins/image_tag.rb</code> 文件后，没有做保存，没有关闭文件，造成的问题，还好我没有放弃，O(∩_∩)O哈哈~</p>

<p><code>注意2</code></p>

<p>我们在插入图片的时候要记住不能再使用 Markdown 语法来写了，要使用 Ocotpress 自定义的 <a href="http://octopress.org/docs/plugins/image-tag/">Image Tag</a> 来插入图片。
然后在发布博文之前，先同步自己的图片，</p>

<pre><code>qrsync qrsync.json 
</code></pre>

<p>然后，生成博文，发布博文</p>

<pre><code>rake generate
rake deploy
</code></pre>

<h3>写在最后</h3>

<p>终于大功告成，通过设置博客，也看到了很多优秀的博客，也看到自己与优秀极客的差距，这也更加坚定了我写博客，记录自己学习的点点滴滴的决心。希望能帮助到你们。有什么问题可以反馈。 Have fun！</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[iOS - UIWebView 动态载入/删除/更新外部 JavaScript/CSS 文件]]></title>
        <link href="http://swplzj.github.io/blog/2015/03/12/ios-uiwebview-dong-tai-zai-ru-slash-shan-chu-slash-geng-xin-wai-bu-javascript-slash-css-wen-jian/"/>
        <updated>2015-03-12T19:59:54+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/03/12/ios-uiwebview-dong-tai-zai-ru-slash-shan-chu-slash-geng-xin-wai-bu-javascript-slash-css-wen-jian</id>
        <content type="html"><![CDATA[<h5>动态载入 JavaScript/CSS 文件</h5>

<p>传统加载外部 <code>JavaScript(*.js)</code> 或者 <code>CSS(*.css)</code> 文件的方法是直接在 <code>&lt;head&gt;</code> 标签里面进行添加:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;head&gt; 
</span><span class='line'>&lt;script type="text/javascript" src="myscript.js"&gt;&lt;/script&gt; 
</span><span class='line'>&lt;link rel="stylesheet" type="text/css" href="main.css" /&gt; 
</span><span class='line'>&lt;/head&gt; </span></code></pre></td></tr></table></div></figure>




<!--more-->


<p>这些文件用这种方式会同步加载到当前这个页面。</p>

<h5>用动态的方式载入 JavaScript/CSS 文件：</h5>

<p>用 DOM createElement 方法创建一个 “script” 或者 ”link” 元素
设置相应的属性
使用 appendChild 方法, 把创建的元素插入到 head 标签的末尾</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function loadjscssfile(filename, filetype){ 
</span><span class='line'>//如果文件类型为 .js ,则创建 script 标签，并设置相应属性 
</span><span class='line'>if (filetype=="js"){ 
</span><span class='line'>var fileref=document.createElement('script'); 
</span><span class='line'>fileref.setAttribute("type","text/javascript"); 
</span><span class='line'>fileref.setAttribute("src", filename); 
</span><span class='line'>} 
</span><span class='line'>//如果文件类型为 .css ,则创建 script 标签，并设置相应属性 
</span><span class='line'>else if (filetype=="css"){ 
</span><span class='line'>var fileref=document.createElement("link"); 
</span><span class='line'>fileref.setAttribute("rel", "stylesheet"); 
</span><span class='line'>fileref.setAttribute("type", "text/css"); 
</span><span class='line'>fileref.setAttribute("href", filename); 
</span><span class='line'>} 
</span><span class='line'>if (typeof fileref!="undefined") 
</span><span class='line'>document.getElementsByTagName("head")[0].appendChild(fileref); 
</span><span class='line'>} 
</span><span class='line'>//动态添加一个.js 文件 
</span><span class='line'>loadjscssfile("myscript.js", "js"); 
</span><span class='line'>//像添加.js文件一样，动态添加一个.php文件 
</span><span class='line'>loadjscssfile("javascript.php", "js"); 
</span><span class='line'>//动态一个.css文件 
</span><span class='line'>loadjscssfile("mystyle.css", "css"); </span></code></pre></td></tr></table></div></figure>


<h5>为了防止多次载入同一个js/css文件， 添加以下判断（这只是粗略检测）</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//临时载入的文件名 
</span><span class='line'>var filesadded=""; 
</span><span class='line'>function checkloadjscssfile(filename, filetype){ 
</span><span class='line'>if (filesadded.indexOf("["+filename+"]")==-1){ 
</span><span class='line'>loadjscssfile(filename, filetype); 
</span><span class='line'>//把 [filename] 存入 filesadded 
</span><span class='line'>filesadded+="["+filename+"]"; 
</span><span class='line'>} 
</span><span class='line'>else{ 
</span><span class='line'>alert("file already added!"); 
</span><span class='line'>} 
</span><span class='line'>//第一次载入 
</span><span class='line'>checkloadjscssfile("myscript.js", "js"); 
</span><span class='line'>//重复载入同一个文件， 失败 
</span><span class='line'>checkloadjscssfile("myscript.js", "js"); </span></code></pre></td></tr></table></div></figure>


<h5>动态删除 JavaScript/Csss 文件</h5>

<p>注意：ie6/7 下动态删除样式时有bug. 2种解决方案：1.样式表里不要有import的样式表 2.把link的type属性设置为空值， 然后再修改 href 的地， 或者直接设置href为空， 最后再把type值设置成”text/css” 强制让ie解释新的样式表。</p>

<p>取得相应的 DOM 元素
根据 文件名&amp;文件类型 定位元素
用 DOM removeChild 删除一个 “script” 或者 ”link” 元素</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function removejscssfile(filename, filetype){ 
</span><span class='line'>//判断文件类型 
</span><span class='line'>var targetelement=(filetype=="js")? "script" : (filetype=="css")? "link" : "none"; 
</span><span class='line'>//判断文件名 
</span><span class='line'>var targetattr=(filetype=="js")? "src" : (filetype=="css")? "href" : "none"; 
</span><span class='line'>var allsuspects=document.getElementsByTagName(targetelement); 
</span><span class='line'>//遍历元素， 并删除匹配的元素 
</span><span class='line'>for (var i=allsuspects.length; i&gt;=0; i--){ 
</span><span class='line'>if (allsuspects[i] && allsuspects[i].getAttribute(targetattr)!=null && allsuspects[i].getAttribute(targetattr).indexOf(filename)!=-1) 
</span><span class='line'>allsuspects[i].parentNode.removeChild(allsuspects[i]); 
</span><span class='line'>} 
</span><span class='line'>} 
</span><span class='line'>removejscssfile("somescript.js", "js"); 
</span><span class='line'>removejscssfile("somestyle.css", "css"); </span></code></pre></td></tr></table></div></figure>


<h5>动态更新 JavaScript/Csss 文件</h5>

<p>使用 createElement 创建 要更新的 JavaScript/Css 元素
查找要被替换的元素
用 replaceChild 替换元素</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function createjscssfile(filename, filetype){ 
</span><span class='line'>if (filetype=="js"){ //if filename is a external JavaScript file 
</span><span class='line'>var fileref=document.createElement('script') 
</span><span class='line'>fileref.setAttribute("type","text/javascript") 
</span><span class='line'>fileref.setAttribute("src", filename) 
</span><span class='line'>} 
</span><span class='line'>else if (filetype=="css"){ //if filename is an external CSS file 
</span><span class='line'>var fileref=document.createElement("link") 
</span><span class='line'>fileref.setAttribute("rel", "stylesheet") 
</span><span class='line'>fileref.setAttribute("type", "text/css") 
</span><span class='line'>fileref.setAttribute("href", filename) 
</span><span class='line'>} 
</span><span class='line'>return fileref 
</span><span class='line'>} 
</span><span class='line'>
</span><span class='line'>function replacejscssfile(oldfilename, newfilename, filetype){ 
</span><span class='line'>var targetelement=(filetype=="js")? "script" : (filetype=="css")? "link" : "none"; 
</span><span class='line'>var targetattr=(filetype=="js")? "src" : (filetype=="css")? "href" : "none"; 
</span><span class='line'>var allsuspects=document.getElementsByTagName(targetelement); 
</span><span class='line'>for (var i=allsuspects.length; i&gt;=0; i--){ 
</span><span class='line'>if (allsuspects[i] && allsuspects[i].getAttribute(targetattr)!=null && allsuspects[i].getAttribute(targetattr).indexOf(oldfilename)!=-1){ 
</span><span class='line'>var newelement=createjscssfile(newfilename, filetype); 
</span><span class='line'>allsuspects[i].parentNode.replaceChild(newelement, allsuspects[i]); 
</span><span class='line'>} 
</span><span class='line'>} 
</span><span class='line'>} 
</span><span class='line'>//用 "newscript.js" 替换 "oldscript.js" 
</span><span class='line'>replacejscssfile("oldscript.js", "newscript.js", "js")； 
</span><span class='line'>//用 "newscript.css" 替换 "oldscript.css" 
</span><span class='line'>replacejscssfile("oldstyle.css", "newscript.css","css"); </span></code></pre></td></tr></table></div></figure>

]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Mac翻墙技巧]]></title>
        <link href="http://swplzj.github.io/blog/2015/03/08/macfan-qiang-ji-qiao/"/>
        <updated>2015-03-08T10:57:41+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/03/08/macfan-qiang-ji-qiao</id>
        <content type="html"><![CDATA[<h4>困扰</h4>

<p>自己一直在寻找Mac上的免费翻墙工具，尝试过很多，但最终都没办法实现，对自己也造成了一些影响，比如需要在国外网站查询一些资料，下载一些应用，观看Youtube视频，刷Facebook，最要命的就是最近自己的Gmail也收不到邮件了，不想购买VPN，那只能尝试找免费翻墙工具了。</p>

<p>终于找到免费翻墙的工具了</p>

<p>不敢独享，故贴出来和大家分享一下。</p>

<!--more-->


<h4>终于等到你，还好我没放弃</h4>

<h5>这种翻墙方法的优点：</h5>

<ul>
<li>免费</li>
<li>无需下载任何软件</li>
<li>配置门槛低，简单</li>
</ul>


<h5>工具使用方法</h5>

<p><code>工具网址</code></p>

<p>首先打开网站：<a href="http://vcup.in/nyve">VPNCUP</a></p>

<p><code>使用方法</code></p>

<h6>注册账号</h6>

<p>在这个网站上注册一个账号。</p>

<h6>设置VPN登录密码</h6>

<p>因为在配置网络的时候，都会使用到VPN的登录密码来进行验证，这个密码不是你的账号登录密码，你需要在我的账户里面来开启，并进行设置。</p>

<p>1、进入<code>我的账户</code>中的<code>VPN账户</code>;</p>

<p>2、将<code>VPN账户状态</code>设置为<code>开放</code>;</p>

<p>3、设置<code>VPN登录密码</code>;</p>

<h6>配置电脑网络设置</h6>

<p>关于如何配置电脑的网络设置，在官网有详细的说明，下面给出相应的链接，大家跟着说明一步步做就好了</p>

<ul>
<li><a href="https://www.vcup136.com/config/windows-xp">Windows XP设置登录VPN服务器图文介绍</a></li>
<li><a href="https://www.vcup136.com/config/iphone-l2tp">Apple Iphone和Apple iTouch设置登录VPN服务器图文介绍(L2TP模式)</a></li>
<li><a href="https://www.vcup136.com/config/iphone">Apple Iphone和Apple iTouch设置登录VPN服务器图文介绍(PPTP模式)</a></li>
<li><a href="https://www.vcup136.com/config/macosx">mac系统下的配置指南</a></li>
<li><a href="https://www.vcup136.com/config/ubuntu">Ubuntu设置VPN</a></li>
<li><a href="https://www.vcup136.com/config/windows">windows系统下的配置指南</a></li>
<li><a href="https://www.vcup136.com/config/android">Android系统设置VPN</a></li>
</ul>


<h4>总结</h4>

<p>设置完成了，大家可以享受墙外的世界了，希望能帮助到你。</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[面向 iOS 开发的优秀 XCode 插件]]></title>
        <link href="http://swplzj.github.io/blog/2015/02/13/mian-xiang-ios-kai-fa-de-you-xiu-xcode-cha-jian/"/>
        <updated>2015-02-13T21:05:50+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/02/13/mian-xiang-ios-kai-fa-de-you-xiu-xcode-cha-jian</id>
        <content type="html"><![CDATA[<p>一套理想的插件架构几乎能够决定整个集成开发环境的差异与特性。Sublime Text与TextMate就是很好的实例。但大家可能不了解的是，Xcode也支持插件。哈哈，如果各位真的前所未闻，我也不会感到惊讶，毕竟苹果并没有把太多精力用在Xcode的宣传之上。事实上，我们几乎找不到多少用于指导Xcode创建的说明文档。</p>

<p>幸运的是，这并没有妨碍开发人员在Xcode这片土地上耕耘并构建自己的插件果实。目前市面上存在大量插件，能够让我们的Xcode使用之旅更加平坦也更富乐趣，甚至足以弥合苹果在其中留下的所有沟壑。在今天的文章中，我将向大家展示自己在日常工作中频繁用到的几款优秀插件。</p>

<!--more-->


<h5>Alcatraz</h5>

<p>过去，安装Xcode插件往往令人抓狂不已，但Alcatraz的出现彻底改写了这一历史。今年早些时候，Alcatraz迎来了发展道路上的里程碑——1.0版本，现在如今已经可以与Xcode 5相兼容。如果大家还没有安装Alcatraz，我建议大家首先完成这项工作。</p>

<p>官方网站：<a href="http://alcatraz.io/">http://alcatraz.io/</a></p>

<h5>XToDo</h5>

<p>这款插件不仅能够着力强调TODO、FIXME、？？？以及！！！注释，同时可以按住 control + T 可以快速查看专用列表，并且可以自定义一些标签。</p>

<p><img src="http://s9.51cto.com/wyfs02/M00/46/84/wKioL1Pyvc2iUbyMAABLbcwVzmM494.jpg" alt="id1" /></p>

<p>官方网站：<a href="https://github.com/trawor/XToDo">https://github.com/trawor/XToDo</a></p>

<h5>Dash for Xcode</h5>

<p>Dash是一款用于浏览文档的优秀软件，我每天都会反复加以运用。更让人喜出望外的是，它现在已经与Xcode相集成，这要归功于其Xcode插件。大家可能知道，我们可以在Xcode编辑器中按住Option键同时点击以直接前往对应文档。不过我对于Xcode自带来的文档浏览器评价不高，在这种情况下Dash插件就成了最理想的解决方案。</p>

<p><img src="http://s2.51cto.com/wyfs02/M00/46/83/wKiom1PyvYOBTuZFAACLZqMVukQ768.jpg" alt="id2" /></p>

<p>该插件能够在我们按住Option并点击对应文档后利用Dash而非Xcode自带文档浏览器将其打开。Dash不仅运行速度极快，同时还能与CocoaDocs相集成。举例来说，如果大家用这种方式点击AFNetworking库中的一个方法，那么Dash将显示出该方法的说明文档。我超爱这项功能。</p>

<p>官方网站：<a href="http://kapeli.com/dash">http://kapeli.com/dash</a></p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[即时通讯类移动APP开发要点]]></title>
        <link href="http://swplzj.github.io/blog/2015/02/06/ji-shi-tong-xun-lei-yi-dong-appkai-fa-yao-dian/"/>
        <updated>2015-02-06T16:05:06+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/02/06/ji-shi-tong-xun-lei-yi-dong-appkai-fa-yao-dian</id>
        <content type="html"><![CDATA[<p>即时通讯（IM）软件作为满足人们沟通需求的工具，十几年来一直长盛不衰，并随着移动时代的到来迎来了新的增长。如在国内广泛使用的微信，在北美广泛使用的Whatsapp、Kik，在亚洲广泛使用的Line、KakaoTalk。另外还有其他一些以独特视角切入移动IM市场的APP，主打阅后即焚、私密消息等。</p>

<p>试着从技术的角度来总结这一类应用的开发要点，或者说是相比桌面版的IM软件，移动IM应用开发需要注意的地方，欢迎指正和补充。</p>

<!--more-->


<h5>网络</h5>

<h6>移动APP经常随着移动设备在不同的网络之间切换，所以处理好网络切换、断网、重连就至关重要。</h6>

<p>解决这个问题的办法，就是要求移动APP能以尽量少的通讯量、尽快的速度重新注册服务器。</p>

<p>比如不再从服务器获取配置信息、联系人信息和联系人状态等。</p>

<p>但是如果这段时间服务器端有变化发生，就需要服务器有推送变化信息的能力。</p>

<p>同时，服务器对客户端重连间隔要保持宽容态度，不要因为客户端在给定的较短时间内没有重连上就移除这个会话。要知道，在移动环境下，客户端断掉连接只是不得已，一有机会，它就会努力重连上来的。</p>

<p>另外，由于网络的不稳定性，消息的发送方和接受方一定要有确认机制，不管这种确认机制是端对端的的还是通过服务器中转，以避免客户端突然掉线，而服务器还未及时知晓的情况。</p>

<h5>电池</h5>

<h6>移动APP必须尽量减少电池的消耗。</h6>

<p>以iOS为例，它以三个规则来强制APP最小化电池消耗：</p>

<ol>
<li><p>APP在后台是不能主动运行的，特定功能的APP可以设置timer唤醒，但最频繁也只能每10分钟运行若干秒。</p></li>
<li><p>APP在后台被唤醒的次数有严格限制，不能在300秒内被唤醒超过15次，否则被系统终止。</p></li>
<li><p>APP即使申请后台任务，最多也只有60秒的运行时间。</p></li>
</ol>


<p>满足这些要求的最好办法，就是不要试图让移动IM应用在后台运行。而把网络监听这样的任务，在APP进入后台的时候转交给iOS系统来完成。</p>

<p>而服务器则要有灵活的过滤机制，不管是主动还是被动的，过滤掉绝大多数试图发给客户端的网络通讯，以保持客户端睡眠的状态。而仅仅把必要的信息，如即时消息，推送给客户端。</p>

<h5>内存</h5>

<h6>移动APP要尽量减少内存消耗。</h6>

<p>以iOS为例，系统会保持尽可能多的APP在内存中，但是内存不足时它就会终止已被挂起的APP来回收内存。这种情况下，首先被回收的就是占内存多的后台APP。</p>

<p>解决这个问题的一个办法，就是在内存消耗较多的模块，通常是模型层的组件，提供持久化机制。当APP切换到后台的时候保存大多数暂时不会用到的数据到文件系统，等回到前台的时候再重建这些数据结构。</p>

<p>比如所有联系人的详细信息就适合这么做。</p>

<h5>系统资源</h5>

<h6>移动APP要尽量减少对系统资源的占有。</h6>

<p>应该以最少使用时间为原则来使用系统资源，以iOS为例，在APP切换到后台之前就要放弃对地址簿的访问。</p>

<h5>后台运行</h5>

<p>以上几点都跟APP在后台运行有关，其实这也是移动IM应用的一大特点。所谓养兵千日、用兵一时，移动IM应用绝大多数时间都躺在后台，所以处理好后台运行就处理好了移动IM应用的大部分。</p>
]]></content>
    </entry>
    
</feed>

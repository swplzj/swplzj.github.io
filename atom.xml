<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    
    <title><![CDATA[Leo Lee]]></title>
    <link href="http://swplzj.github.io/atom.xml" rel="self"/>
    <link href="http://swplzj.github.io/"/>
    <updated>2015-11-09T11:50:14+08:00</updated>
    <id>http://swplzj.github.io/</id>
    <author>
        <name><![CDATA[Leo Lee]]></name>
        <email><![CDATA[swplzj@126.com]]></email>
    </author>
    <generator uri="http://octopress.org/">Octopress</generator>
    
    
    <entry>
        <title type="html"><![CDATA[Git 在项目中的基本使用]]></title>
        <link href="http://swplzj.github.io/blog/2015/11/09/git-zai-xiang-mu-zhong-de-ji-ben-shi-yong/"/>
        <updated>2015-11-09T11:36:49+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/11/09/git-zai-xiang-mu-zhong-de-ji-ben-shi-yong</id>
        <content type="html"><![CDATA[<h3>Git 基础</h3>

<hr />

<h4>直接记录快照，而非差异比较</h4>

<p>Git 和其它版本控制系统（包括 Subversion 和近似工具）的主要差别在于 Git 对待数据的方法。 概念上来区分，其它大部分系统以文件变更列表的方式存储信息。 这类系统（CVS、Subversion、Perforce、Bazaar 等等）将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。</p>

<p><code>存储每个文件与初始版本的差异</code></p>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_11_06_svn_work_flow.png"></p>

<p>Git 不按照以上方式对待或保存数据。 反之，Git 更像是把数据看作是对小型文件系统的一组快照。 每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 快照流。</p>

<p><code>存储项目随时间改变的快照</code></p>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_11_06_git_screenshot.png"></p>

<h4>近乎所有操作都是本地执行</h4>

<p>在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。
要浏览项目的历史，Git 不需外连到服务器去获取历史，然后再显示出来——它只需直接从本地数据库中读取。 你能立即看到项目历史。 如果你想查看当前版本与一个月前的版本之间引入的修改，Git 会查找到一个月前的文件做一次本地的差异计算，而不是由远程服务器处理或从远程服务器拉回旧版本文件再来本地处理。</p>

<h4>Git 保证完整性</h4>

<p>Git 中所有数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。 这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。 若你在传送过程中丢失信息或损坏文件，Git 就能发现。</p>

<p>Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来。 SHA-1 哈希看起来是这样：</p>

<pre><code>24b9da6552252987aa493b52f8696cd6d3b00373
</code></pre>

<p>Git 中使用这种哈希值的情况很多，你将经常看到这种哈希值。 实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。</p>

<h4>Git 一般只添加数据</h4>

<p>你执行的 Git 操作，几乎只往 Git 数据库中增加数据。 很难让 Git 执行任何不可逆操作，或者让它以任何方式清除数据。 同别的 VCS 一样，未提交更新时有可能丢失或弄乱修改的内容；但是一旦你提交快照到 Git 中，就难以再丢失数据，特别是如果你定期的推送数据库到其它仓库的话。</p>

<h4>三种状态</h4>

<p>Git 有三种状态，你的文件可能处于其中之一：已提交（committed）、已修改（modified）和已暂存（staged）。 已提交表示数据已经安全的保存在本地数据库中。 已修改表示修改了文件，但还没保存到数据库中。 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</p>

<p>由此引入 Git 项目的三个工作区域的概念：Git 仓库、工作目录以及暂存区域。</p>

<p><code>工作目录、暂存区域以及 Git 仓库</code></p>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_11_06_git_areas.png"></p>

<p>Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。</p>

<p>工作目录是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</p>

<p>暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。 有时候也被称作“索引”，不过一般说法还是叫暂存区域。</p>

<p>基本的 Git 工作流程如下：</p>

<ol>
<li><p>在工作目录中修改文件。</p></li>
<li><p>暂存文件，将文件的快照放入暂存区域。</p></li>
<li><p>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。</p></li>
</ol>


<h3>获取 Git 仓库</h3>

<hr />

<pre><code>$ git init
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git add *.c
</span><span class='line'>$ git add LICENSE
</span><span class='line'>$ git commit -m 'initial project version'</span></code></pre></td></tr></table></div></figure>


<h5>克隆现有的仓库</h5>

<pre><code>$ git clone https://github.com/libgit2/libgit2


$ git clone https://github.com/libgit2/libgit2 mylibgit
</code></pre>

<p>这将执行与上一个命令相同的操作，不过在本地创建的仓库名字变为 mylibgit。</p>

<h3>记录每次更新到仓库</h3>

<p>使用 Git 时文件的生命周期如下：</p>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_11_06_git_file_life_cycle.png"></p>

<h5>检查当前文件状态</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git status
</span><span class='line'>On branch master
</span><span class='line'>nothing to commit, working directory clean</span></code></pre></td></tr></table></div></figure>


<h5>跟踪新文件</h5>

<pre><code>$ git add README
</code></pre>

<h5>暂存已修改文件</h5>

<p> 要暂存这次更新，需要运行 git add 命令。 这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。</p>

<h5>状态简览</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git status -s
</span><span class='line'> M README
</span><span class='line'>MM Rakefile
</span><span class='line'>A  lib/git.rb
</span><span class='line'>M  lib/simplegit.rb
</span><span class='line'>?? LICENSE.txt</span></code></pre></td></tr></table></div></figure>


<p>新添加的未跟踪文件前面有 <code>??</code> 标记，新添加到暂存区中的文件前面有 <code>A</code> 标记，修改过的文件前面有 <code>M</code> 标记。 你可能注意到了 <code>M</code> 有两个可以出现的位置，出现在右边的 <code>M</code> 表示该文件被修改了但是还没放入暂存区，出现在靠左边的 <code>M</code> 表示该文件被修改了并放入了暂存区。</p>

<h5>忽略文件</h5>

<p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cat .gitignore
</span><span class='line'>*.[oa]
</span><span class='line'>*~</span></code></pre></td></tr></table></div></figure>


<p>第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。 第二行告诉 Git 忽略所有以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。 此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。 要养成一开始就设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。</p>

<p>文件 .gitignore 的格式规范如下：</p>

<pre><code>所有空行或者以 ＃ 开头的行都会被 Git 忽略。

可以使用标准的 glob 模式匹配。

匹配模式可以以（/）开头防止递归。

匹配模式可以以（/）结尾指定目录。

要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。
</code></pre>

<p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>星号（*）匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。 使用两个星号（*) 表示匹配任意中间目录，比如a/**/z 可以匹配 a/z, a/b/z 或 a/b/c/z等。</span></code></pre></td></tr></table></div></figure>


<p><code>Tip</code></p>

<p><code>GitHub</code> 有一个十分详细的针对数十种项目及语言的 <code>.gitignore</code> 文件列表，你可以在 <a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a> 找到它.</p>

<h5>查看已暂存和未暂存的修改</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git diff
</span><span class='line'>diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
</span><span class='line'>index 8ebb991..643e24f 100644
</span><span class='line'>--- a/CONTRIBUTING.md
</span><span class='line'>+++ b/CONTRIBUTING.md
</span><span class='line'>@@ -65,7 +65,8 @@ branch directly, things can get messy.
</span><span class='line'> Please include a nice description of your changes when you submit your PR;
</span><span class='line'> if we have to read the whole diff to figure out why you're contributing
</span><span class='line'> in the first place, you're less likely to get feedback and have your change
</span><span class='line'>-merged in.
</span><span class='line'>+merged in. Also, split your changes into comprehensive chunks if you patch is
</span><span class='line'>+longer than a dozen lines.
</span><span class='line'>
</span><span class='line'> If you are starting to work on a particular area, feel free to submit a PR
</span><span class='line'> that highlights your work in progress (and note in the PR title that it's</span></code></pre></td></tr></table></div></figure>


<p>git diff 将通过文件补丁的格式显示具体哪些行发生了改变。
此命令比较的是工作目录中当前文件和暂存区域快照之间的差异， 也就是修改之后还没有暂存起来的变化内容。</p>

<p>若要查看已暂存的将要添加到下次提交里的内容，可以用 git diff &ndash;cached 命令。（Git 1.6.1 及更高版本还允许使用 git diff &ndash;staged，效果是相同的，但更好记些。）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git diff --staged
</span><span class='line'>diff --git a/README b/README
</span><span class='line'>new file mode 100644
</span><span class='line'>index 0000000..03902a1
</span><span class='line'>--- /dev/null
</span><span class='line'>+++ b/README
</span><span class='line'>@@ -0,0 +1 @@
</span><span class='line'>+My Project</span></code></pre></td></tr></table></div></figure>


<h5>提交更新</h5>

<p>默认的提交消息包含最后一次运行 git status 的输出，放在注释行里，另外开头还有一空行，供你输入提交说明。 退出编辑器时，Git 会丢掉注释行，用你输入提交附带信息生成一次提交。
另外，你也可以在 commit 命令后添加 -m 选项，将提交信息与命令放在同一行。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git commit -m "Story 182: Fix benchmarks for speed"
</span><span class='line'>[master 463dc4f] Story 182: Fix benchmarks for speed
</span><span class='line'> 2 files changed, 2 insertions(+)
</span><span class='line'> create mode 100644 README
</span><span class='line'> ```
</span><span class='line'> 
</span><span class='line'>#####  跳过使用暂存区域
</span><span class='line'>Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤：
</span></code></pre></td></tr></table></div></figure>


<p>$ git status
On branch master
Changes not staged for commit:
  (use &ldquo;git add <file>&hellip;&rdquo; to update what will be committed)
  (use &ldquo;git checkout &ndash; <file>&hellip;&rdquo; to discard changes in working directory)</p>

<pre><code>modified:   CONTRIBUTING.md
</code></pre>

<p>no changes added to commit (use &ldquo;git add&rdquo; and/or &ldquo;git commit -a&rdquo;)
$ git commit -a -m &lsquo;added new benchmarks&rsquo;
[master 83e38c7] added new benchmarks
 1 file changed, 5 insertions(+), 0 deletions(-)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>##### 移除文件
</span><span class='line'>
</span><span class='line'>要从 `Git` 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 可以用 `git rm` 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。
</span><span class='line'>
</span><span class='line'>如果只是简单地从工作目录中手工删除文件，运行 `git status` 时就会在 “Changes not staged for commit” 部分（也就是 未暂存清单）看到：
</span></code></pre></td></tr></table></div></figure>


<p>$ rm PROJECTS.md
$ git status
On branch master
Your branch is up-to-date with &lsquo;origin/master&rsquo;.
Changes not staged for commit:
  (use &ldquo;git add/rm <file>&hellip;&rdquo; to update what will be committed)
  (use &ldquo;git checkout &ndash; <file>&hellip;&rdquo; to discard changes in working directory)</p>

<pre><code>    deleted:    PROJECTS.md
</code></pre>

<p>no changes added to commit (use &ldquo;git add&rdquo; and/or &ldquo;git commit -a&rdquo;)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>然后再运行 git rm 记录此次移除文件的操作：
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>$ git rm PROJECTS.md
rm &lsquo;PROJECTS.md&rsquo;
$ git status
On branch master
Changes to be committed:
  (use &ldquo;git reset HEAD <file>&hellip;&rdquo; to unstage)</p>

<pre><code>deleted:    PROJECTS.md
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>下一次提交时，该文件就不再纳入版本管理了。 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f（译注：即 force 的首字母）。 这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被 Git 恢复。
</span><span class='line'>
</span><span class='line'>另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。 换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。 当你忘记添加 .gitignore 文件，不小心把一个很大的日志文件或一堆 .a 这样的编译生成文件添加到暂存区时，这一做法尤其有用。 为达到这一目的，使用 --cached 选项：
</span><span class='line'>
</span><span class='line'>  $ git rm --cached README
</span><span class='line'>  
</span><span class='line'>`git rm` 命令后面可以列出文件或者目录的名字，也可以使用 `glob` 模式。 比方说：
</span><span class='line'>
</span><span class='line'>  $ git rm log/\*.log
</span><span class='line'>  
</span><span class='line'>注意到`星号 *` 之前的`反斜杠 \`， 因为 `Git` 有它自己的文件模式扩展匹配方式，所以我们不用 `shell` 来帮忙展开。 此命令删除 `log/` 目录下扩展名为 `.log` 的所有文件。 类似的比如：
</span><span class='line'>
</span><span class='line'>  $ git rm \*~
</span><span class='line'>  
</span><span class='line'>该命令为删除以 `~ 结尾`的所有文件。
</span><span class='line'>
</span><span class='line'>  
</span><span class='line'>
</span><span class='line'>#### 移动文件
</span><span class='line'>
</span><span class='line'>  $ git mv file_from file_to
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p> git mv README.md README
$ git status
On branch master
Changes to be committed:
  (use &ldquo;git reset HEAD <file>&hellip;&rdquo; to unstage)</p>

<pre><code>renamed:    README.md -&gt; README
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>其实，运行 git mv 就相当于运行了下面三条命令：
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>$ mv README.md README
$ git rm README.md
$ git add README</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>### 查看提交历史
</span><span class='line'>------------
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>$ git log
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#x73;&#99;&#104;&#97;&#x63;&#x6f;&#x6e;&#x40;&#103;&#x65;&#x65;&#x2d;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;">&#x73;&#x63;&#x68;&#x61;&#x63;&#111;&#110;&#64;&#x67;&#101;&#x65;&#45;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;</a>
Date:   Mon Mar 17 21:52:11 2008 -0700</p>

<pre><code>changed the version number
</code></pre>

<p>commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#x61;&#x63;&#x6f;&#110;&#64;&#x67;&#101;&#101;&#x2d;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;">&#115;&#x63;&#104;&#x61;&#99;&#x6f;&#110;&#64;&#x67;&#101;&#101;&#x2d;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#x6d;</a>
Date:   Sat Mar 15 16:40:33 2008 -0700</p>

<pre><code>removed unnecessary test
</code></pre>

<p>commit a11bef06a3f659402fe7563abf99ad00de2209e6
Author: Scott Chacon <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#115;&#x63;&#x68;&#x61;&#x63;&#111;&#x6e;&#x40;&#x67;&#x65;&#x65;&#x2d;&#109;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;">&#x73;&#x63;&#x68;&#x61;&#99;&#111;&#x6e;&#x40;&#x67;&#101;&#101;&#x2d;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;</a>
Date:   Sat Mar 15 10:31:28 2008 -0700</p>

<pre><code>first commit
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>默认不用任何参数的话，`git log` 会按提交时间列出所有的更新，最近的更新排在最上面。 正如你所看到的，这个命令会列出每个提交的 `SHA-1` 校验和作者的名字和电子邮件地址、提交时间以及提交说明。
</span><span class='line'>
</span><span class='line'>一个常用的选项是 `-p`，用来显示每次提交的内容差异。 你也可以加上 `-2` 来仅显示最近两次提交。
</span><span class='line'>如果你想看到每次提交的简略的统计信息，你可以使用 `--stat` 选项，此选项在每次提交的下面列出额所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。 在每次提交的最后还有一个总结。
</span><span class='line'>
</span><span class='line'>另外一个常用的选项是 `--pretty`。 这个选项可以指定使用不同于默认格式的方式展示提交历史。  这个选项有一些内建的子选项供你使用。 比如用 `oneline` 将每个提交放在一行显示，查看的提交数很大时非常有用。 另外还有 `short`，`full` 和 `fuller` 可以用，展示的信息或多或少有些不同。
</span><span class='line'>
</span><span class='line'>最有意思的是 `format`，可以定制要显示的记录格式。 这样的输出对后期提取分析格外有用 — 因为你知道输出的格式不会随着 `Git` 的更新而发生改变：
</span></code></pre></td></tr></table></div></figure>


<p>$ git log &ndash;pretty=format:&ldquo;%h - %an, %ar : %s&rdquo;
ca82a6d - Scott Chacon, 6 years ago : changed the version number
085bb3b - Scott Chacon, 6 years ago : removed unnecessary test
a11bef0 - Scott Chacon, 6 years ago : first commit</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>
</span><span class='line'>* `git log --pretty=format` 常用的选项
</span><span class='line'>
</span><span class='line'>选项    |  说明 
</span><span class='line'>------    | ------
</span><span class='line'>%H        | 提交对象（commit）的完整哈希字串
</span><span class='line'>%h        | 提交对象的简短哈希字串
</span><span class='line'>%T        | 树对象（tree）的完整哈希字串
</span><span class='line'>%t        | 树对象的简短哈希字串
</span><span class='line'>%P        | 父对象（parent）的完整哈希字串
</span><span class='line'>%p        | 父对象的简短哈希字串
</span><span class='line'>%an       | 作者（author）的名字
</span><span class='line'>%ae       | 作者的电子邮件地址
</span><span class='line'>%ad       | 作者修订日期（可以用 --date= 选项定制格式）
</span><span class='line'>%ar       | 作者修订日期，按多久以前的方式显示
</span><span class='line'>%cn       | 提交者(committer)的名字
</span><span class='line'>%ce       | 提交者的电子邮件地址
</span><span class='line'>%cd       | 提交日期
</span><span class='line'>%cr       | 提交日期，按多久以前的方式显示
</span><span class='line'>%s        | 提交说明
</span><span class='line'>
</span><span class='line'>作者 和 提交者 之间究竟有何差别， 其实作者指的是实际作出修改的人，提交者指的是最后将此工作成果提交到仓库的人。 
</span><span class='line'>
</span><span class='line'>当 `oneline` 或 `format` 与另一个 `log` 选项 `--graph` 结合使用时尤其有用。 这个选项添加了一些`ASCII`字符串来形象地展示你的分支、合并历史：
</span><span class='line'>
</span><span class='line'>####   限制输出长度
</span><span class='line'>
</span><span class='line'>`git log` 还有许多非常实用的限制输出长度的选项，也就是只输出部分提交信息。
</span><span class='line'>另外还有按照时间作限制的选项，比如 `--since` 和 `--until` 也很有用。 例如，下面的命令列出所有最近两周内的提交：
</span><span class='line'>
</span><span class='line'>  $ git log --since=2.weeks
</span><span class='line'>
</span><span class='line'>另一个非常有用的筛选选项是 `-S`，可以列出那些添加或移除了某些字符串的提交。 比如说，你想找出添加或移除了某一个特定函数的引用的提交，你可以这样使用：
</span><span class='line'>
</span><span class='line'>  $ git log -Sfunction_name   
</span><span class='line'>  
</span><span class='line'>  
</span><span class='line'>  
</span><span class='line'>`限制 git log 输出的选项`
</span><span class='line'>
</span><span class='line'>选项    |   说明
</span><span class='line'>------    |   ---------
</span><span class='line'>-(n)  | 仅显示最近的 n 条提交
</span><span class='line'>--since, --after  | 仅显示指定时间之后的提交。
</span><span class='line'>--until, --before |   仅显示指定时间之前的提交。
</span><span class='line'>--author  | 仅显示指定作者相关的提交。
</span><span class='line'>--committer   | 仅显示指定提交者相关的提交。
</span><span class='line'>--grep    | 仅显示含指定关键字的提交
</span><span class='line'>-S    | 仅显示添加或移除了某个关键字的提交   
</span><span class='line'>
</span><span class='line'>来看一个实际的例子，如果要查看 Git 仓库中，2008 年 10 月期间，Junio Hamano 提交的但未合并的测试文件，可以用下面的查询命令：
</span></code></pre></td></tr></table></div></figure>


<p>$ git log &ndash;pretty=&ldquo;%h - %s&rdquo; &ndash;author=gitster &ndash;since=&ldquo;2008-10-01&rdquo; \
   &ndash;before=&ldquo;2008-11-01&rdquo; &ndash;no-merges &ndash; t/
5610e3b - Fix testcase failure when extended attributes are in use
acd3b9e - Enhance hold_lock_file_for_{update,append}() API
f563754 - demonstrate breakage of detached checkout with symbolic link HEAD
d1a43f2 - reset &ndash;hard/read-tree &ndash;reset -u: remove unmerged new paths
51a94af - Fix &ldquo;checkout &ndash;track -b newbranch&rdquo; on detached HEAD
b0ad11e - pull: allow &ldquo;git pull origin $something:$current_branch&rdquo; into an unborn branch</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>### 撤消操作
</span><span class='line'>-----------
</span><span class='line'>
</span><span class='line'>  $ git commit --amend
</span><span class='line'>
</span><span class='line'>这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息。
</span><span class='line'>
</span><span class='line'>例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>$ git commit -m &lsquo;initial commit&rsquo;
$ git add forgotten_file
$ git commit &ndash;amend</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>最终你只会有一个提交 - 第二次提交将代替第一次提交的结果。
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>##### 取消暂存的文件
</span><span class='line'>
</span><span class='line'>使用 `git reset HEAD &lt;file&gt;... `来取消暂存。 所以，我们可以这样来取消暂存 `CONTRIBUTING.md` 文件：
</span></code></pre></td></tr></table></div></figure>


<p>$ git reset HEAD CONTRIBUTING.md
Unstaged changes after reset:
M   CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use &ldquo;git reset HEAD <file>&hellip;&rdquo; to unstage)</p>

<pre><code>renamed:    README.md -&gt; README
</code></pre>

<p>Changes not staged for commit:
  (use &ldquo;git add <file>&hellip;&rdquo; to update what will be committed)
  (use &ldquo;git checkout &ndash; <file>&hellip;&rdquo; to discard changes in working directory)</p>

<pre><code>modified:   CONTRIBUTING.md
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>`提示`
</span><span class='line'>
</span><span class='line'>虽然在调用时加上 `--hard` 选项可以令 `git reset` 成为一个危险的命令（译注：可能导致工作目录中所有当前进度丢失！），但本例中工作目录内的文件并不会被修改。 不加选项地调用 `git reset` 并不危险 — 它只会修改暂存区域。
</span><span class='line'>
</span><span class='line'>##### 撤消对文件的修改
</span><span class='line'>
</span><span class='line'>撤消之前所做的修改
</span></code></pre></td></tr></table></div></figure>


<p>$ git checkout &ndash; CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use &ldquo;git reset HEAD <file>&hellip;&rdquo; to unstage)</p>

<pre><code>renamed:    README.md -&gt; README
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>`危险`
</span><span class='line'>
</span><span class='line'>你需要知道 `git checkout -- [file]` 是一个危险的命令，这很重要。 你对那个文件做的任何修改都会消失 - 你只是拷贝了另一个文件来覆盖它。 除非你确实清楚不想要那个文件了，否则不要使用这个命令。
</span><span class='line'>
</span><span class='line'>`记住`
</span><span class='line'>
</span><span class='line'>在 `Git` 中任何 已提交的 东西几乎总是可以恢复的。 甚至那些被删除的分支中的提交或使用 `--amend` 选项覆盖的提交也可以恢复。 然而，任何你未提交的东西丢失后很可能再也找不到了
</span><span class='line'>
</span><span class='line'>### 远程仓库的使用
</span><span class='line'>--------
</span><span class='line'>
</span><span class='line'>##### 查看远程仓库
</span></code></pre></td></tr></table></div></figure>


<p>$ git clone <a href="https://github.com/schacon/ticgit">https://github.com/schacon/ticgit</a>
Cloning into &lsquo;ticgit&rsquo;&hellip;
remote: Reusing existing pack: 1857, done.
remote: Total 1857 (delta 0), reused 0 (delta 0)
Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.
Resolving deltas: 100% (772/772), done.
Checking connectivity&hellip; done.
$ cd ticgit
$ git remote
origin</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>你也可以指定选项 `-v`，会显示需要读写远程仓库使用的 `Git` 保存的简写与其对应的 `URL`。
</span></code></pre></td></tr></table></div></figure>


<p>$ git remote -v
origin  <a href="https://github.com/schacon/ticgit">https://github.com/schacon/ticgit</a> (fetch)
origin  <a href="https://github.com/schacon/ticgit">https://github.com/schacon/ticgit</a> (push)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>##### 添加远程仓库
</span><span class='line'>
</span><span class='line'>运行 `git remote add &lt;shortname&gt; &lt;url&gt;` 添加一个新的远程 `Git` 仓库，同时指定一个你可以轻松引用的简写
</span></code></pre></td></tr></table></div></figure>


<p>$ git remote
origin
$ git remote add pb <a href="https://github.com/paulboone/ticgit">https://github.com/paulboone/ticgit</a>
$ git remote -v
origin  <a href="https://github.com/schacon/ticgit">https://github.com/schacon/ticgit</a> (fetch)
origin  <a href="https://github.com/schacon/ticgit">https://github.com/schacon/ticgit</a> (push)
pb  <a href="https://github.com/paulboone/ticgit">https://github.com/paulboone/ticgit</a> (fetch)
pb  <a href="https://github.com/paulboone/ticgit">https://github.com/paulboone/ticgit</a> (push)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>现在你可以在命令行中使用字符串 pb 来代替整个 URL。 例如，如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行 `git fetch pb`：
</span></code></pre></td></tr></table></div></figure>


<p>$ git fetch pb
remote: Counting objects: 43, done.
remote: Compressing objects: 100% (36/36), done.
remote: Total 43 (delta 10), reused 31 (delta 5)
Unpacking objects: 100% (43/43), done.
From <a href="https://github.com/paulboone/ticgit">https://github.com/paulboone/ticgit</a>
 * [new branch]      master     -> pb/master
 * [new branch]      ticgit     -> pb/ticgit</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>##### 从远程仓库中抓取与拉取
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>  $ git fetch [remote-name]
</span><span class='line'>  
</span><span class='line'>这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>如果你使用 `clone` 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 `origin` 为简写。 所以，`git fetch origin` 会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意 `git fetch` 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。
</span><span class='line'>
</span><span class='line'>如果你有一个分支设置为跟踪一个远程分支，可以使用 `git pull` 命令来自动的抓取然后合并远程分支到当前分支。 这对你来说可能是一个更简单或更舒服的工作流程；默认情况下，`git clone` 命令会自动设置本地 `master` 分支跟踪克隆的远程仓库的 `master` 分支（或不管是什么名字的默认分支）。 运行 `git pull` 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>##### 推送到远程仓库
</span><span class='line'>
</span><span class='line'>`git push [remote-name] [branch-name]` 当你想要将 `master` 分支推送到 `origin` 服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字），那么运行这个命令就可以将你所做的备份到服务器：
</span><span class='line'>
</span><span class='line'>  $ git push origin master
</span><span class='line'>
</span><span class='line'>##### 查看远程仓库
</span><span class='line'>
</span><span class='line'>使用 `git remote show [remote-name]` 命令，查看某一个远程仓库的更多信息。
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>$ git remote show origin
* remote origin
  Fetch URL: <a href="https://github.com/schacon/ticgit">https://github.com/schacon/ticgit</a>
  Push  URL: <a href="https://github.com/schacon/ticgit">https://github.com/schacon/ticgit</a>
  HEAD branch: master
  Remote branches:
    master                               tracked
    dev-branch                           tracked
  Local branch configured for &lsquo;git pull&rsquo;:
    master merges with remote master
  Local ref configured for &lsquo;git push&rsquo;:
    master pushes to master (up to date)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>
</span><span class='line'>##### 远程仓库的移除与重命名
</span><span class='line'>
</span><span class='line'>如果想要重命名引用的名字可以运行 `git remote rename` 去修改一个远程仓库的简写名。 例如，想要将 `pb` 重命名为 `paul`，可以用 `git remote rename` 这样做：
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>$ git remote rename pb paul
$ git remote
origin
paul</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>如果因为一些原因想要移除一个远程仓库 - 你已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者某一个贡献者不再贡献了 - 可以使用 `git remote rm`
</span></code></pre></td></tr></table></div></figure>


<p>$ git remote rm paul
$ git remote
origin</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>### 打标签
</span><span class='line'>-----
</span><span class='line'>
</span><span class='line'>像其他版本控制系统（VCS）一样，Git 可以给历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。
</span><span class='line'>
</span><span class='line'>##### 列出标签
</span></code></pre></td></tr></table></div></figure>


<p>$ git tag
v0.1
v1.3</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>这个命令以字母顺序列出标签；但是它们出现的顺序并不重要。
</span><span class='line'>
</span><span class='line'>##### 创建标签
</span><span class='line'>
</span><span class='line'>Git 使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。
</span><span class='line'>
</span><span class='line'>一个轻量标签很像一个不会改变的分支 - 它只是一个特定提交的引用。然而，附注标签是存储在 Git 数据库中的一个完整对象。它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证。 通常建议创建附注标签，这样你可以拥有以上所有信息；但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的。
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>##### 附注标签
</span></code></pre></td></tr></table></div></figure>


<p>$ git tag -a v1.4 -m &lsquo;my version 1.4&rsquo;
$ git tag
v0.1
v1.3
v1.4</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>通过使用 git show 命令可以看到标签信息与对应的提交信息：
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>$ git show v1.4
tag v1.4
Tagger: Ben Straub <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#98;&#x65;&#x6e;&#64;&#x73;&#116;&#x72;&#97;&#117;&#x62;&#x2e;&#x63;&#99;">&#98;&#101;&#x6e;&#x40;&#x73;&#x74;&#114;&#x61;&#x75;&#98;&#46;&#x63;&#x63;</a>
Date:   Sat May 3 20:19:12 2014 -0700</p>

<p>my version 1.4</p>

<p>commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#x73;&#99;&#104;&#x61;&#99;&#111;&#110;&#x40;&#x67;&#x65;&#101;&#x2d;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;">&#115;&#x63;&#x68;&#x61;&#99;&#111;&#x6e;&#x40;&#x67;&#101;&#101;&#45;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;</a>
Date:   Mon Mar 17 21:52:11 2008 -0700</p>

<p>  changed the version number</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>#### 轻量标签
</span><span class='line'>
</span><span class='line'>轻量标签本质上是将提交校验和存储到一个文件中 - 没有保存任何其他信息。 创建轻量标签，不需要使用 -a、-s 或 -m 选项，只需要提供标签名字：
</span></code></pre></td></tr></table></div></figure>


<p>$ git tag v1.4-lw
$ git tag
v0.1
v1.3
v1.4
v1.4-lw
v1.5</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>这时，如果在标签上运行 git show，你不会看到额外的标签信息。 命令只会显示出提交信息：
</span></code></pre></td></tr></table></div></figure>


<p>$ git show v1.4-lw
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#115;&#99;&#104;&#97;&#99;&#x6f;&#110;&#x40;&#x67;&#101;&#x65;&#x2d;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;">&#115;&#99;&#104;&#97;&#x63;&#111;&#110;&#64;&#x67;&#101;&#101;&#45;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#109;</a>
Date:   Mon Mar 17 21:52:11 2008 -0700</p>

<pre><code>changed the version number
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>#### 后期打标签
</span><span class='line'>
</span><span class='line'>你也可以对过去的提交打标签。 假设提交历史是这样的：
</span></code></pre></td></tr></table></div></figure>


<p>$ git log &ndash;pretty=oneline
15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch &lsquo;experiment&rsquo;
a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support
0d52aaab4479697da7686c15f77a3d64d9165190 one more thing
6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch &lsquo;experiment&rsquo;
0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function
4682c3261057305bdd616e23b64b0857d832627b added a todo file
166ae0c4d3f420721acbb115cc33848dfcc2121a started write support
9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile
964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo
8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>现在，假设在 `v1.2` 时你忘记给项目打标签，也就是在 `updated rakefile` 提交。 你可以在之后补上标签。 要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）:
</span><span class='line'>
</span><span class='line'>  $ git tag -a v1.2 9fceb02
</span><span class='line'>  
</span><span class='line'>可以看到你已经在那次提交上打上标签了：
</span></code></pre></td></tr></table></div></figure>


<p>$ git tag
v0.1
v1.2
v1.3
v1.4
v1.4-lw
v1.5</p>

<p>$ git show v1.2
tag v1.2
Tagger: Scott Chacon <a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#58;&#x73;&#99;&#104;&#x61;&#x63;&#111;&#x6e;&#x40;&#x67;&#x65;&#x65;&#45;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;">&#115;&#99;&#x68;&#97;&#99;&#111;&#x6e;&#64;&#103;&#x65;&#101;&#x2d;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;</a>
Date:   Mon Feb 9 15:32:16 2009 -0800</p>

<p>version 1.2
commit 9fceb02d0ae598e95dc970b74767f19372d61af8
Author: Magnus Chacon <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#58;&#109;&#99;&#x68;&#x61;&#99;&#x6f;&#110;&#64;&#103;&#101;&#x65;&#45;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;">&#109;&#x63;&#104;&#97;&#x63;&#111;&#110;&#64;&#103;&#101;&#101;&#45;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;</a>
Date:   Sun Apr 27 20:43:35 2008 -0700</p>

<pre><code>updated rakefile
</code></pre>

<p>&hellip;</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>#### 共享标签
</span><span class='line'>
</span><span class='line'>默认情况下，`git push` 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样 - 你可以运行 `git push origin [tagname]`。
</span></code></pre></td></tr></table></div></figure>


<p>$ git push origin v1.5
Counting objects: 14, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (12/12), done.
Writing objects: 100% (14/14), 2.05 KiB | 0 bytes/s, done.
Total 14 (delta 3), reused 0 (delta 0)
To git@github.com:schacon/simplegit.git
 * [new tag]         v1.5 -> v1.5</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>如果想要一次性推送很多标签，也可以使用带有 --tags 选项的 git push 命令。 这将会把所有不在远程仓库服务器上的标签全部传送到那里。
</span></code></pre></td></tr></table></div></figure>


<p>$ git push origin &ndash;tags
Counting objects: 1, done.
Writing objects: 100% (1/1), 160 bytes | 0 bytes/s, done.
Total 1 (delta 0), reused 0 (delta 0)
To git@github.com:schacon/simplegit.git
 * [new tag]         v1.4 -> v1.4
 * [new tag]         v1.4-lw -> v1.4-lw</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#### 检出标签
</span><span class='line'>
</span><span class='line'>在 Git 中你并不能真的检出一个标签，因为它们并不能像分支一样来回移动。 如果你想要工作目录与仓库中特定的标签版本完全一样，可以使用 git checkout -b [branchname] [tagname] 在特定的标签上创建一个新分支：
</span></code></pre></td></tr></table></div></figure>


<p>$ git checkout -b version2 v2.0.0
Switched to a new branch &lsquo;version2&rsquo;</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>当然，如果在这之后又进行了一次提交，version2 分支会因为改动向前移动了，那么 version2 分支就会和 v2.0.0 标签稍微有些不同，这时就应该当心了。
</span><span class='line'>
</span><span class='line'>### Git 别名
</span><span class='line'>---------
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>Git 并不会在你输入部分命令时自动推断出你想要的命令。 如果不想每次都输入完整的 Git 命令，可以通过 git config 文件来轻松地为每一个命令设置一个别名。
</span></code></pre></td></tr></table></div></figure>


<p>$ git config &ndash;global alias.co checkout
$ git config &ndash;global alias.br branch
$ git config &ndash;global alias.ci commit
$ git config &ndash;global alias.st status</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>这意味着，当要输入 git commit时，只需要输入 git ci。 随着你继续不断地使用 Git，可能也会经常使用其他命令，所以创建别名时不要犹豫。
</span><span class='line'>
</span><span class='line'>在创建你认为应该存在的命令时这个技术会很有用。 例如，为了解决取消暂存文件的易用性问题，可以向 Git 中添加你自己的取消暂存别名：
</span><span class='line'>
</span><span class='line'>  $ git config --global alias.unstage 'reset HEAD --'
</span><span class='line'>
</span><span class='line'>这会使下面的两个命令等价：
</span></code></pre></td></tr></table></div></figure>


<p>$ git unstage fileA
$ git reset HEAD &ndash; fileA</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>这样看起来更清楚一些。 通常也会添加一个 last 命令，像这样：
</span><span class='line'>
</span><span class='line'>  $ git config --global alias.last 'log -1 HEAD'
</span><span class='line'>  
</span><span class='line'>这样，可以轻松地看到最后一次提交：
</span></code></pre></td></tr></table></div></figure>


<p>$ git last
commit 66938dae3329c7aebe598c2246a8e6af90d04646
Author: Josh Goebel <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#100;&#114;&#101;&#97;&#109;&#101;&#114;&#51;&#x40;&#101;&#120;&#97;&#109;&#x70;&#108;&#101;&#x2e;&#99;&#111;&#109;">&#100;&#x72;&#101;&#x61;&#109;&#101;&#x72;&#x33;&#64;&#101;&#x78;&#97;&#x6d;&#x70;&#108;&#x65;&#x2e;&#99;&#111;&#x6d;</a>
Date:   Tue Aug 26 19:48:51 2008 +0800</p>

<pre><code>test for current head

Signed-off-by: Scott Chacon &lt;schacon@example.com&gt;
</code></pre>

<p>```</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[最近情况]]></title>
        <link href="http://swplzj.github.io/blog/2015/11/05/zui-jin-qing-kuang/"/>
        <updated>2015-11-05T18:44:27+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/11/05/zui-jin-qing-kuang</id>
        <content type="html"><![CDATA[<p>最近的情况是：忙 - 盲 - 茫，一言难尽啊，这些经历都是有必要记录下来，以便回顾自己走过的路，方便总结自己的成长得失。</p>

<!--more-->


<p>今年3月份辞职，有了一次重新选择公司的机会，这次较以前还是比较慎重的，总后拿到了几个 Offer，权衡之后来到了选择这家公司，当时几个公司的情形是这样的：</p>

<ul>
<li>墨迹天气面试通过了，但是，进入之后感觉公司没有一个很好的公司氛围（其实是和798旁边的视界核心比较的了），没有然后了；</li>
<li>视界核心，这是一个令我很向往的公司，一个极客的天堂，各方面都很满意，也过了初试、复试，但到最后的时候，公司还是没有要我，真残忍啊。印象：团队小而精悍，产品都具有互联网思维，融入了极客精神，产品设计和用到的技术都是一流的，很赞；</li>
<li>魔漫相机：其实，我在那里呆了一天，团队虽只有五六十人，但其产品用户足有两亿多，可见其产品设计之成功，不符合自己的职业价值观，拒绝了；</li>
<li>租车公司：忘记了名字了，离家近，最后工资没有达成一致，公司方向也不是我想从事的，放弃；</li>
<li>纷享销客：这是我最难做出取舍的公司，团队特别棒，一路面试，总裁是微软出身的，最后，还是咬牙舍弃，人生的选择没有对与错，路是自己走出来的；</li>
<li>现公司：互联网金融，我很看好这个方向，因为自己也算是这个需求的用户，之前做过农行的e购天街，建行的微银行，算是金融产品出身；</li>
</ul>


<p>这些就是我今年年初的经历，说这些也算是回顾一下，因为这些也是反思，不知道自己的路选择的正确与否。目前来到公司做了三个项目，项目之间也有复用模块，做这项目也都倾注了自己所有的努力，结果是残忍的：</p>

<ul>
<li>项目一，因为公司战略问题，不了了之，已经到了上线的阶段，不理解。</li>
<li>项目二，复用了一些模块，添加了一些新功能，紧急上线了，也用到了实际门店，算是欣慰；</li>
<li>项目三，到了冒烟测试阶段，接到上级通知，战略调整，暂时放弃&hellip;</li>
</ul>


<p>这也是我为什么回顾今年历程的原因了，反思自己在这里成长得失，寻找接下来努力和选择的方向，对自己的要求，尽自己最大的努力去做好眼前的事情，我不想到年底总结的时候，自己回顾一年的努力，都是徒劳，于公：没有为公司带来实际效益，于私：技术没有大幅提升，也没有人力管理、时间管理等方面的实践和成长，这样的工作是很失败的，个人认为只有做到对自己负责的人，才有资格为他人负责，为公司负责，才有机会担当更重的责任。</p>

<p>唠叨了这么多，接下来还是要有目标的去提升自己，规划自己的职业道路。
分享今天看到的一句话：要想成为牛逼的人，就要去吃成为牛逼人所要吃的苦。</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[iOS - VPN强烈推荐]]></title>
        <link href="http://swplzj.github.io/blog/2015/08/19/ios-vpnqiang-lie-tui-jian/"/>
        <updated>2015-08-19T18:58:02+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/08/19/ios-vpnqiang-lie-tui-jian</id>
        <content type="html"><![CDATA[<p>之前推荐过 Mac 上的 VPN 使用，今天推荐两款 iOS 端比价好用的 VPN 应用，真的用起来很方便。无需注册，轻松翻墙。</p>

<ol>
<li><code>ArkVPN</code>：优点：方便，速度快，免费，不限流量。缺点：不订阅的话需要每天领取时长，不过免费时长够用了。</li>
<li><code>Shadowsocks</code>：优点：方便，免费，开源，不限流量，不限时长。缺点：有些慢，有广告。</li>
</ol>


<!--more-->


<h3>ArkVPN</h3>

<ul>
<li><p>安装</p>

<p> <a href="https://itunes.apple.com/cn/app/arkvpn-wu-xian-liu-liang-mian/id909977824?mt=8">ArkVPN 下载地址</a></p></li>
<li><p>每天领取免费时长</p>

<p>  <img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_vpn_id1.PNG" title="\" ></p></li>
<li><p>只要一次点击，连接整个世界</p>

<p>  <img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_vpn_id2.PNG" title="\" ></p>

<p>  <img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_vpn_id3.PNG" title="\" ></p>

<p>  <img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_vpn_id4.PNG" title="\" ></p></li>
<li><p>国外服务器列表</p>

<p>  <img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_vpn_id5.PNG" title="\" ></p></li>
</ul>


<h3>Shadowsocks</h3>

<ul>
<li><p>简介
Shadowsocks 是一个开源项目，同时提供多个平台使用，你也可<a href="https://github.com/shadowsocks/shadowsocks">下载源码</a>进行研究。iOS客户端类似于一个封闭的浏览器，这这里可以翻墙浏览任何你想浏览的页面了。</p></li>
<li><p>安装</p></li>
</ul>


<p><a href="https://github.com/shadowsocks/shadowsocks-csharp">Windows</a> / <a href="https://github.com/shadowsocks/shadowsocks-iOS/wiki/Shadowsocks-for-OSX-Help">OS X</a></p>

<p><a href="https://github.com/shadowsocks/shadowsocks-android">Android</a> / <a href="https://github.com/shadowsocks/shadowsocks-iOS/wiki/Help">iOS</a></p>

<p><a href="https://github.com/shadowsocks/openwrt-shadowsocks">OpenWRT</a></p>

<ul>
<li><p>使用</p>

<p>  <img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_vpn_id6.PNG" title="\" ><br/>
  <img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_vpn_id7.PNG" title="\" ></p></li>
</ul>


<p>Have fun！</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[正则表达式学习]]></title>
        <link href="http://swplzj.github.io/blog/2015/08/19/zheng-ze-biao-da-shi-xue-xi/"/>
        <updated>2015-08-19T11:45:54+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/08/19/zheng-ze-biao-da-shi-xue-xi</id>
        <content type="html"><![CDATA[<p>项目中经常使用到一些校验，比如有效手机号，身份证号码，邮箱，银行卡号码&hellip;假如说都是简单的使用位数来做校验，容易造成特殊字符输入乱码，还有可能在数据库中写入脏数据，所以使用正则表达式来进行校验匹配是很有必要的，当然，我们学习它就要知道它有哪些作用，正则表达式的用途基本有以下三种：</p>

<ul>
<li>校验数据</li>
<li>查询数据</li>
<li>替换数据</li>
</ul>


<p>学习正则表达式的最好方法是从例子开始，理解例子之后再自己对例子进行修改。下面开始学习之旅：</p>

<!--more-->


<h3>语法</h3>

<p><code>.</code> 是元字符，匹配除了换行符以外的任意字符。</p>

<p><code>*</code> 是元字符，不过它代表的不是字符，也不是位置，而是数量——它指定 <code>*</code> 前边的内容可以连续重复使用任意次以使整个表达式得到匹配。</p>

<p><code>.*</code> 连在一起就意味着任意数量的不包含换行的字符。</p>

<p><code>+</code> 重复一次或更多次</p>

<p><code>?</code> 重复零次或一次</p>

<p><code>{n}</code> 重复n次</p>

<p><code>{n,}</code>  重复n次或更多次</p>

<p><code>{n,m}</code> 重复n到m次</p>

<p><code>[]</code> 指定一个字符范围，比如，<strong>[aeiou]</strong>就匹配任何一个英文元音字母，<code>[0-9]</code>代表的含意与\d就是完全一致的。
<code>()</code> 小括号来指定子表达式(也叫做分组),比如：<strong>(\d{1,3}.){3}\d{1,3}</strong> 是一个简单的IP地址匹配表达式。</p>

<p><code>\b</code> 是正则表达式规定的一个特殊代码（也叫它元字符，metacharacter），代表着单词的开头或结尾，也就是单词的分界处。虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是<code>\b</code>并不匹配这些单词分隔字符中的任何一个，它只匹配一个位置。比如:在一段文本中查询<code>Leo</code>，就可以这样写：<strong>\bLeo\b</strong> 。</p>

<p><code>\B</code>    匹配不是单词开头或结束的位置</p>

<p><code>\d</code> 匹配一位数字，比如匹配大陆手机号码： <strong>1\d{10}</strong> ，{10} 意思是重复匹配10次。</p>

<p><code>\D</code>    匹配任意非数字的字符</p>

<p><code>\s</code> 匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等。</p>

<p><code>\S</code>    匹配任意不是空白符的字符</p>

<p><code>\w</code> 匹配字母或数字或下划线或汉字等。</p>

<p><code>\W</code>    匹配任意不是字母，数字，下划线，汉字的字符</p>

<p><code>[^x]</code>  匹配除了x以外的任意字符</p>

<p><code>[^aeiou]</code>  匹配除了aeiou这几个字母以外的任意字符</p>

<p><code>^</code> 匹配字符串的开始，或者是行的开始处</p>

<p><code>$</code> 匹配字符串的结束，或者是行的结束处</p>

<p><code>|</code> 分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配。</p>

<p><code>\</code> 为转义字符，比如匹配网址：使用 <code>swplzj\.github\.io</code> 来匹配 <code>swplzj.github.io</code> 。</p>

<h3>后向引用</h3>

<h4>捕获</h4>

<p>(exp):  匹配exp,并捕获文本到自动命名的组里</p>

<p>(?<name>exp):   匹配exp,并捕获文本到名称为name的组里，也可以写成(?&lsquo;name'exp)</p>

<p>(?:exp):    匹配exp,不捕获匹配的文本，也不给此分组分配组号</p>

<h4>零宽断言</h4>

<p>(?=exp):    匹配exp前面的位置</p>

<p>(?&lt;=exp):   匹配exp后面的位置</p>

<p>(?!exp):    匹配后面跟的不是exp的位置</p>

<h4>注释</h4>

<p>(?#comment):    这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读</p>

<h3>实例</h3>

<p>从下面文本中查询出以<code>[]</code>包含的内容，包括<code>[]</code></p>

<pre><code>The Tasmanian tiger, also known as the Thylacine, has been announced extinct many years ago. Now many geneticists assert that they are capable of recreating a [sid=13_1] from DNA extracted from its bone specimen. \n\nTasmanian tigers belong to marsupials that have a [sid=13_2] in common. They looked like big dogs with over 15 dark stripes on the body. When chasing their preys, these animals primarily depended on [sid=13_3] to prevail. Their stomach could inflate so they could eat large amount of food each time to [sid=13_4] a period lack of food.  
</code></pre>

<p>我们发现要查询的内容是以<code>[</code>开头，以 <code>]</code> 结束的，所以首先可以肯定的是  <code>\[\]</code>，注意需要转义字符<code>\</code>，然后<code>[]</code>之前包含的可能是 数字、空格、大小写字母、符号，但是不能包含<code>]</code>,所以我们可以写出 <code>\[[^\]]+\]</code></p>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_regular_express_id1.png" title="/" ></p>

<p>再增加点难度，要检索出<code>[]</code>里面的数据，我们可以先观察规律，因为正则表达式 - Regular Express 本身就是有规律的表达式，所以现发现规律，再写出所对应的正则。</p>

<p><strong>解答</strong></p>

<ul>
<li>以 <code>[</code> 开头，作为规律，可以写出 <code>(?&lt;=\[)([^\]])+</code></li>
</ul>


<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_regular_express_id2.png" title="/" ></p>

<ul>
<li>以<code>]</code> 结束，可以写出<code>[^\[]+(?=\])</code></li>
</ul>


<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_regular_express_id3.png" title="/" ></p>

<h3>iOS中应用</h3>

<p>我们在开发iOS项目过程中，使用到正则表达式的主要场景有两种：</p>

<p><strong>第一</strong> 在应用中用户输入数据时，做正则匹配校验，这类比较常见，这里就不做详述，但是给出一个比较好的建议，就是把需要校验的项，单独创建一个 XML 文件，然后再自定义标签，属性，来进行统一存放项目中所有校验项，如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;?xml version="1.0" encoding="utf-8"?&gt;
</span><span class='line'>&lt;rules&gt;
</span><span class='line'>    &lt;rule type="mobile" pattern="^1\d{10}$" tip="请输入正确的手机号" /&gt;
</span><span class='line'>&lt;/rules&gt;</span></code></pre></td></tr></table></div></figure>


<p>上面是简单校验手机号码位数的正则表达式，这样做的好处：方便维护管理；代码更为规范。</p>

<p><strong>第二</strong> 在使用 <code>UIWebView</code> 来加载文章类的页面时，使用正则表达式可以很好的提升用户体验。那使用正则我们可以做到那些呢？</p>

<ul>
<li><p>使用正则表达式来加载本地 <code>CSS</code> 样式表来自定义 <code>HTML</code> 中的样式；</p>

<ul>
<li>替换 <code>CSS</code> 样式表，这个可以实现 <code>HTML</code> 字体大小的动态调整；</li>
<li>可以实现类似白天、黑夜主题色的更换；</li>
<li>可以对文本进行标注、突出等处理；</li>
</ul>
</li>
<li><p>使用正则表达式获取 <code>HTML</code> 中的图片、视频，以便更友好的操作图片、视频资源；</p>

<ul>
<li>可以更改图片的大小展示；</li>
<li>通过正则匹配获取到图片的属性，比如id，然后进行本地操作，如，对图片添加点击事件，点击之后，进入本地图片浏览器，在图片浏览器中，就可以对图片进行放大、缩小、查看图片备注等操作了。</li>
</ul>
</li>
<li>使用正则表达式来为 <code>HTML</code> 添加元素；

<ul>
<li>可以为添加文章标题、发布时间等操作</li>
</ul>
</li>
</ul>


<p>使用场景已经描述完了，但是怎么样实现呢，下面直接上代码：</p>

<p><strong>加载本地 CSS </strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSRegularExpression *regularexpression = [[NSRegularExpression alloc]
</span><span class='line'>                                              initWithPattern:@"(?i)&lt;\\s*link\\s*href=\"[^\"]+\\.css\""
</span><span class='line'>                                              options:NSRegularExpressionCaseInsensitive
</span><span class='line'>                                              error:nil];
</span><span class='line'>    NSArray *matches = [regularexpression matchesInString:htmlContent options:0 range:NSMakeRange(0, [htmlContent length])];
</span><span class='line'>    NSString *content = htmlContent;
</span><span class='line'>    NSString *replaceStr = [NSString stringWithFormat:@"&lt;link href=\"%@\"",cssFilePath];
</span><span class='line'>    for (NSTextCheckingResult *match in matches){
</span><span class='line'>        NSRange matchRange = [match range];
</span><span class='line'>        content=[regularexpression stringByReplacingMatchesInString:content options:0 range:matchRange withTemplate:replaceStr];
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p><strong>获取图片资源</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> NSMutableArray *imageIds = [NSMutableArray array];
</span><span class='line'>    NSString *str = @"(?i)&lt;div\\s*class\\s*=\\s*\"[^\"]*img\"&gt;\\s*&lt;img\\s*[^&gt;]*id=\\s*\"[^&gt;]*&gt;";
</span><span class='line'> NSRegularExpression *regularexpression = [[NSRegularExpression alloc]
</span><span class='line'>                                              initWithPattern:str
</span><span class='line'>                                              options:NSRegularExpressionCaseInsensitive
</span><span class='line'>                                              error:nil];
</span><span class='line'> NSArray *matches = [regularexpression matchesInString:htmlContent
</span><span class='line'>                                                  options:0
</span><span class='line'>                                                    range:NSMakeRange(0, [htmlContent length])];
</span></code></pre></td></tr></table></div></figure>


<p><strong>对图片进行操作</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> NSString *str = @"(?i)&lt;div\\s*class=\"[^\"]*img\"&gt;\\s*&lt;img\\s*[^&gt;]*id=\\s*\"";
</span><span class='line'>
</span><span class='line'> str = [str stringByAppendingString:imageInfo.image_id];
</span><span class='line'> str = [str stringByAppendingString:@"\"\\s*src=\\s*\"[^\"]*\"[^&gt;]*&gt;"];
</span><span class='line'>
</span><span class='line'> NSString *replacejs = [NSString stringWithFormat:@"&lt;div class=\"img\" id=\"%@\" onclick=\"location.href='picid'+this.id\" style=\"background-color:#999999;width:%fpx;height:%fpx;\" /&gt;",imageInfo.image_id,width,height];
</span><span class='line'>
</span><span class='line'> replacejs = [replacejs stringByAppendingString:[NSString stringWithFormat:@"&lt;img src=\"%@\"  width=\"%fpx\" height=\"%fpx\"/&gt;",imagePath,width,0.0]];
</span><span class='line'> 
</span><span class='line'> replacejs = [replacejs stringByAppendingString:[NSString stringWithFormat:@"&lt;img src=\"%@\" width=\"180px\" height=\"36px\" style=\"margin-left:%fpx;margin-top:%fpx\"/&gt;",logoImagePath,(width / 2 - 90),(height/2 - 34)]];
</span><span class='line'>
</span><span class='line'> NSRegularExpression *regularexpression = [[NSRegularExpression alloc]
</span><span class='line'>                                          initWithPattern:str
</span><span class='line'>                                          options:NSRegularExpressionCaseInsensitive
</span><span class='line'>                                          error:nil];
</span><span class='line'> NSArray *matches = [regularexpression matchesInString:content options:0 range:NSMakeRange(0,  [content length])];
</span><span class='line'>
</span><span class='line'>
</span><span class='line'> for (NSTextCheckingResult *match in matches){
</span><span class='line'>    NSRange matchRange = [match range];
</span><span class='line'>    content=[regularexpression stringByReplacingMatchesInString:content options:0 range:matchRange withTemplate:replacejs];
</span><span class='line'> }
</span><span class='line'>            </span></code></pre></td></tr></table></div></figure>


<p><strong>放大缩小页面中的文本</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> NSString *jsString = [[NSString alloc] initWithFormat:@"document.getElementsByTagName('body')[0].style.webkitTextSizeAdjust= '%@'",textFontScale];
</span><span class='line'>    
</span><span class='line'>[_webView stringByEvaluatingJavaScriptFromString:jsString];</span></code></pre></td></tr></table></div></figure>


<p><strong>扩展 - 在本地HTML中加入JS</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSString *js = @"&lt;script language=\"javascript\" type=\"text/javascript\"&gt;";
</span><span class='line'> //替换css文件
</span><span class='line'>js = [js stringByAppendingString:@"function replacejscssfile(oldfilename, newfilename, filetype){ var targetelement=(filetype==\"js\")? \"script\" : (filetype==\"css\")? \"link\" : \"none\"; var targetattr=(filetype==\"js\")? \"src\" : (filetype==\"css\")? \"href\" : \"none\"; var allsuspects=document.getElementsByTagName(targetelement); for (var i=allsuspects.length; i&gt;=0; i--){ if (allsuspects[i] && allsuspects[i].getAttribute(targetattr)!=null && allsuspects[i].getAttribute(targetattr).indexOf(oldfilename)!=-1){ var newelement=createjscssfile(newfilename, filetype); allsuspects[i].parentNode.replaceChild(newelement, allsuspects[i]);} } return \"sdasds\";}"];
</span><span class='line'>
</span><span class='line'>js = [js stringByAppendingString:@"&lt;/script&gt;&lt;/head&gt;"];
</span><span class='line'>
</span><span class='line'>   NSString *content = [htmlContent stringByReplacingOccurrencesOfString:@"&lt;/head&gt;" withString:js];</span></code></pre></td></tr></table></div></figure>


<h3>常用正则表达式</h3>

<p>网址（URL）：  [a-zA-z]+://[^\s]*</p>

<p>IP地址(IP Address)： ((2[0-4]\d|25[0-5]|[01]?\d\d?).){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)</p>

<p>电子邮件(Email)：  \w+([-+.]\w+)<em>@\w+([-.]\w+)</em>.\w+([-.]\w+)*</p>

<p>QQ号码： [1-9]\d{4,}</p>

<p>HTML标记(包含内容或自闭合)： &lt;(.<em>)(.</em>)>.<em>&lt;\/\1>|&lt;(.</em>) \/></p>

<p>密码(由数字/大写字母/小写字母/标点符号组成，四种都必有，8位以上)：    (?=^.{8,}$)(?=.<em>\d)(?=.</em>\W+)(?=.<em>[A-Z])(?=.</em>[a-z])(?!.<em>\n).</em>$</p>

<p>日期(年-月-日)：  (\d{4}|\d{2})-((1[0-2])|(0?[1-9]))-(([12][0-9])|(3[01])|(0?[1-9]))</p>

<p>日期(月/日/年)：  ((1[0-2])|(0?[1-9]))/(([12][0-9])|(3[01])|(0?[1-9]))/(\d{4}|\d{2})</p>

<p>时间(小时:分钟, 24小时制)：   ((1|0?)[0-9]|2[0-3]):([0-5][0-9])</p>

<p>汉字(字符)：   [\u4e00-\u9fa5]</p>

<p>中文及全角标点符号(字符)：  [\u3000-\u301e\ufe10-\ufe19\ufe30-\ufe44\ufe50-\ufe6b\uff01-\uffee]</p>

<p>中国大陆固定电话号码：   (\d{4}-|\d{3}-)?(\d{8}|\d{7})</p>

<p>中国大陆手机号码： 1\d{10}</p>

<p>中国大陆邮政编码： [1-9]\d{5}</p>

<p>中国大陆身份证号(15位或18位)：  \d{15}(\d\d[0-9xX])?</p>

<p>非负整数(正整数或零)：    \d+</p>

<p>正整数：    [0-9]<em>[1-9][0-9]</em></p>

<p>负整数：    -[0-9]<em>[1-9][0-9]</em></p>

<p>整数：   -?\d+</p>

<p>小数：   (-?\d+)(.\d+)?</p>

<p>不包含abc的单词：    \b((?!abc)\w)+\b</p>

<h3>后记</h3>

<p>整理这篇博文的过程中，当然涉及到的知识不仅仅是正则表达式，还有后面通过 webview 和 JavaScript 进行交互，这是另一方面的知识了，就不在这里介绍了。马上七夕情人节了，大家快乐。就写到这里啦，还没有准备礼物，赶紧准备，不然&hellip;</p>

<p>参考博文：<a href="http://deerchao.net/tutorials/regex/regex.htm">正则表达式30分钟入门教程</a></p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Bash - 趣味Shell]]></title>
        <link href="http://swplzj.github.io/blog/2015/08/14/bash-qu-wei-shell/"/>
        <updated>2015-08-14T11:27:23+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/08/14/bash-qu-wei-shell</id>
        <content type="html"><![CDATA[<p>今天抽闲玩了一下<code>Shell</code>，发现几个比较有意思的，记录一下。</p>

<ul>
<li>终端彩虹字：<code>lolcat</code></li>
<li>图形化文字：<code>figlet</code></li>
<li>幸运人生格言：<code>fortune</code></li>
<li><code>ASCII</code>牛说：<code>Cowsay</code></li>
<li>黑客帝国中瀑布流文字：<code>cmatrix</code></li>
<li>写在最后</li>
</ul>


<p>很有趣的 <code>Shell</code>， 值得一试；</p>

<!--more-->


<h3>lolcat</h3>

<p> <strong>安装</strong></p>

<p>由于 <code>Lolcat</code> 是一个 <code>ruby gem</code> 程序，所以在你的系统中必须安装有最新版本的 <code>ruby</code>。安装<code>ruby</code>过程不再详述；</p>

<p>使用下面命令进行安装<code>lolcat</code></p>

<pre><code>gem install lolcat
</code></pre>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_lolcat.png"></p>

<p><strong>使用</strong></p>

<p><code>lolcat</code>作用是在终端中为文本添加彩虹般的色彩。安装完成之后就可以使用了。</p>

<p>首先看一下<code>lolcat</code>的帮助文档</p>

<pre><code>lolcat --help
</code></pre>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_lolcat_help.png"></p>

<p>接着查看日历</p>

<pre><code>cal | lolcat
</code></pre>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_lolcat_cal.png"></p>

<p><strong>高级技巧</strong></p>

<p>我们还可以给文本赋予彩虹颜色的动画:</p>

<pre><code>echo Hello World | lolcat -a -d 500
</code></pre>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_lolcat_echo.gif"></p>

<p><strong>别名技巧:<code>alias</code></strong></p>

<p>我们发现，假如一个经常使用的打印命令，比如<code>ls</code>，想打印彩虹色彩，我们每次都需要在敲完<code>ls</code>之后再加上<code>lolcat</code>，也就是<code>ls | lolcat</code>，这样很不方便，这时我们就可以想到别名，<code>alias</code>。我们可以设定一些别名：</p>

<pre><code>alias ls="ls | lolcat"
</code></pre>

<p>但是，有一个问题来了，只要把终端这个标签关闭掉或者重启终端，我们设置的别名就失效了，也就是说别名只针对当前标签页有效。所以，接下来我们要设置<code>alias</code>永久有效，我们输入命令<code>cd ~</code>到用户主目录，找到<code>.bash_profile</code>文件，如果没有，我们创建一个</p>

<pre><code>touch .bash_profile
</code></pre>

<p>然后在<code>.bash_profile</code>中加入我们的别名</p>

<pre><code>alias ls="ls | lolcat"  
</code></pre>

<p>保存，关闭，重启<code>Terminal</code>，看一下效果：</p>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_lolcat_ls.png"></p>

<p><strong>BTW</strong></p>

<p>假如你的终端没有设置配色方案，可以选择自带的主题：<code>Silver Aerogel</code>，设置方法:找到<code>.bash_profile</code>文件，添加如下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># for color
</span><span class='line'>export CLICOLOR=1
</span><span class='line'># \h:\W \u\$
</span><span class='line'>export PS1='\[\033[01;33m\]\u@\h\[\033[01;31m\] \W\$\[\033[00m\] '</span></code></pre></td></tr></table></div></figure>


<p>保存，重启终端，就可以看到漂亮的配色方案了。</p>

<h3>figlet</h3>

<p><strong>安装</strong></p>

<p>我们使用 <code>Homebrew</code>来安装此插件，</p>

<pre><code>brew install figlet
</code></pre>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_figlet_install.png"></p>

<p><strong>使用</strong></p>

<ul>
<li>figlet</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lizhenjie@localhost ~$ figlet Leo Lee
</span><span class='line'> _                 _              
</span><span class='line'>| |    ___  ___   | |    ___  ___ 
</span><span class='line'>| |   / _ \/ _ \  | |   / _ \/ _ \
</span><span class='line'>| |__|  __/ (_) | | |__|  __/  __/
</span><span class='line'>|_____\___|\___/  |_____\___|\___|</span></code></pre></td></tr></table></div></figure>


<ul>
<li>figlist：列出所有字体名称</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lizhenjie@localhost ~$ figlist
</span><span class='line'>Default font: standard
</span><span class='line'>Font directory: /usr/local/Cellar/figlet/2.2.5/share/figlet/fonts
</span><span class='line'>Figlet fonts in this directory:
</span><span class='line'>3-d
</span><span class='line'>3x5
</span><span class='line'>5lineoblique
</span><span class='line'>acrobatic
</span><span class='line'>alligator
</span><span class='line'>alligator2
</span><span class='line'>alphabet
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<ul>
<li>showfigfonts：展示每个字体效果！</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lizhenjie@localhost ~$ showfigfonts
</span><span class='line'>3-d :
</span><span class='line'>  ****             **
</span><span class='line'> */// *           /**
</span><span class='line'>/    /*           /**
</span><span class='line'>   ***  *****  ******
</span><span class='line'>  /// */////  **///**
</span><span class='line'> *   /*      /**  /**
</span><span class='line'>/ ****       //******
</span><span class='line'> ////         ////// 
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>3x5 :
</span><span class='line'>            
</span><span class='line'>###     ### 
</span><span class='line'>  # # # #   
</span><span class='line'> ##  #  ### 
</span><span class='line'>  # # #   # 
</span><span class='line'>###     ### 
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<p>只能列两种字体了，太多了。</p>

<p>当然，可以结合上面的 <code>lolcat</code>使用更炫哦。</p>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_figlet_lolcat.png"></p>

<p><strong>Dashboard Figlet</strong></p>

<p>安装过程中，意外发现<code>Figlet</code>也有<code>Dashboard</code>中的插件，可以到<a href="http://www.apple.com/downloads/dashboard/email_messaging/figletwidget.html">苹果官网下载</a>，使用起来也是非常方便的。</p>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_lolcat_dashboard.png"></p>

<h3>fortune</h3>

<p><strong>安装</strong></p>

<pre><code>brew install fortune
</code></pre>

<p><strong>用法</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lizhenjie@localhost ~$ fortune
</span><span class='line'>"To take a significant step forward, you must make a series of finite 
</span><span class='line'>improvements."
</span><span class='line'>-- Donald J. Atwood, General Motors</span></code></pre></td></tr></table></div></figure>


<p>结合<code>lolcat</code>使用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lizhenjie@localhost ~$ fortune | lolcat</span></code></pre></td></tr></table></div></figure>


<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_fortune_lolcat.png"></p>

<h3>Cowsay</h3>

<p><strong>安装</strong></p>

<pre><code>brew install cowsay
</code></pre>

<p><strong>用法</strong></p>

<ul>
<li><code>cowsay</code>可以输出一个在终端用ASCII码组成的小牛，这个小牛会说出你想要它说的话。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lizhenjie@localhost ~$ cowsay God help them who help themselves!
</span><span class='line'> ____________________________________ 
</span><span class='line'>&lt; God help them who help themselves! &gt;
</span><span class='line'> ------------------------------------ 
</span><span class='line'>        \   ^__^
</span><span class='line'>         \  (oo)\_______
</span><span class='line'>            (__)\       )\/\
</span><span class='line'>                ||----w |
</span><span class='line'>                ||     ||
</span><span class='line'>lizhenjie@localhost ~$ 
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>罗列出所有可以画出的动物形状</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lizhenjie@localhost ~$ cowsay -l
</span><span class='line'>Cow files in /usr/local/Cellar/cowsay/3.03/share/cows:
</span><span class='line'>beavis.zen bong bud-frogs bunny cheese cower daemon default dragon
</span><span class='line'>dragon-and-cow elephant elephant-in-snake eyes flaming-sheep ghostbusters
</span><span class='line'>head-in hellokitty kiss kitty koala kosh luke-koala meow milk moofasa moose
</span><span class='line'>mutilated ren satanic sheep skeleton small sodomized stegosaurus stimpy
</span><span class='line'>supermilker surgery telebears three-eyes turkey turtle tux udder vader
</span><span class='line'>vader-koala www</span></code></pre></td></tr></table></div></figure>


<ul>
<li>使用其他动物形状</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lizhenjie@localhost ~$ cowsay -f dragon LEO
</span><span class='line'> _____ 
</span><span class='line'>&lt; LEO &gt;
</span><span class='line'> ----- 
</span><span class='line'>      \                    / \  //\
</span><span class='line'>       \    |\___/|      /   \//  \\
</span><span class='line'>            /0  0  \__  /    //  | \ \    
</span><span class='line'>           /     /  \/_/    //   |  \  \  
</span><span class='line'>           @_^_@'/   \/_   //    |   \   \ 
</span><span class='line'>           //_^_/     \/_ //     |    \    \
</span><span class='line'>        ( //) |        \///      |     \     \
</span><span class='line'>      ( / /) _|_ /   )  //       |      \     _\
</span><span class='line'>    ( // /) '/,_ _ _/  ( ; -.    |    _ _\.-~        .-~~~^-.
</span><span class='line'>  (( / / )) ,-{        _      `-.|.-~-.           .~         `.
</span><span class='line'> (( // / ))  '/\      /                 ~-. _ .-~      .-~^-.  \
</span><span class='line'> (( /// ))      `.   {            }                   /      \  \
</span><span class='line'>  (( / ))     .----~-.\        \-'                 .~         \  `. \^-.
</span><span class='line'>             ///.----..&gt;        \             _ -~             `.  ^-`  ^-_
</span><span class='line'>               ///-._ _ _ _ _ _ _}^ - - - - ~                     ~-- ,.-~
</span><span class='line'>                                                                  /.-~
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>结合<code>fortune</code>使用</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lizhenjie@localhost ~$ fortune | cowsay
</span><span class='line'> _________________________________________ 
</span><span class='line'>/ We are all worms. But I do believe I am \
</span><span class='line'>| a glowworm.                             |
</span><span class='line'>|                                         |
</span><span class='line'>\ -- Winston Churchill                    /
</span><span class='line'> ----------------------------------------- 
</span><span class='line'>        \   ^__^
</span><span class='line'>         \  (oo)\_______
</span><span class='line'>            (__)\       )\/\
</span><span class='line'>                ||----w |
</span><span class='line'>                ||     ||</span></code></pre></td></tr></table></div></figure>


<ul>
<li>结合<code>lolcat</code>使用：</li>
</ul>


<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_cowsay_lolcat.png"></p>

<ul>
<li>结合<code>lolcat + fortune + cowsay</code></li>
</ul>


<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_cowsay_lolcat_forturn.png"></p>

<p>是不是很神奇！！！</p>

<h3>cmatrix</h3>

<p><strong>安装</strong></p>

<p>黑客帝国‘Hacker’风格的桌面的生动画面</p>

<pre><code>brew install cmatrix
</code></pre>

<p><strong>用法</strong></p>

<pre><code>cmatrix 
</code></pre>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_cmatrix.png"></p>

<p>其他用法可以使用 <code>man</code>查看。</p>

<h3>写在最后</h3>

<p>上面的命令可能在实际中对自己没有多大用途，但是，在配置的过程中，学到了不少东西，还增加了对 <code>Shell</code>的了解和兴趣，我们对自己的定位不能只局限与写代码，而是让自己多去了解自己不了解的，时常去走出自己的舒适区，找一些有趣有挑战性的东西去做，总之，保证自己一直在进步，加油！</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Stay Hungry Stay Foolish]]></title>
        <link href="http://swplzj.github.io/blog/2015/08/11/stay-hungry/"/>
        <updated>2015-08-11T22:17:40+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/08/11/stay-hungry</id>
        <content type="html"><![CDATA[<p>今天又看了一遍乔帮主的演讲，每次观看，都能让我重新定位自己，重新审视自己，从自己身上找到答案。</p>

<p>乔布斯对操场上挤的满满的毕业生、校友和家长们说：“你的时间有限，所以最好别把它浪费在模仿别人这种事上。” &ndash;同样地，如果还在学校的话，似乎不应该去模仿退学的牛人们。</p>

<p>You&rsquo;ve got to find what you love,&lsquo; Jobs says
　　</p>

<p>Jobs说，你必须要找到你所爱的东西。
　　</p>

<p>This is the text of the Commencement address by Steve Jobs, CEO of Apple Computer and of Pixar Animation Studios, delivered on June 12, 2005.</p>

<p>这是苹果公司和Pixar动画工作室的CEO Steve Jobs于2005年6月12号在斯坦福大学的毕业典礼上面的演讲稿。</p>

<p>　　<!--more--></p>

<p>I am honored to be with you today at your commencement from one of the finest universities in the world. I never graduated from college. Truth be told, this is the closest I&rsquo;ve ever gotten to a college graduation. Today I want to tell you three stories from my life. That&rsquo;s it. No big deal. Just three stories.</p>

<p>　　我今天很荣幸能和你们一起参加毕业典礼，斯坦福大学是世界上最好的大学之一。我从来没有从大学中毕业。说实话,今天也许是在我的生命中离大学毕业最近的一天了。今天我想向你们讲述我生活中的三个故事。不是什么大不了的事情,只是三个故事而已。
　　</p>

<h3>　　The first story is about connecting the dots.</h3>

<h3>　　第一个故事是关于如何把生命中的点点滴滴串连起来。</h3>

<p>I dropped out of Reed College after the first 6 months, but then stayed around as a drop-in for another 18 months or so before I really quit. So why did I drop out?
　　</p>

<p>我在Reed大学读了六个月之后就退学了,但是在十八个月以后——我真正的作出退学决定之前,我还经常去学校。我为什么要退学呢?</p>

<p>　　It started before I was born. My biological mother was a young, unwed college graduate student, and she decided to put me up for adoption. She felt very strongly that I should be adopted by college graduates, so everything was all set for me to be adopted at birth by a lawyer and his wife. Except that when I popped out they decided at the last minute that they really wanted a girl.
　　</p>

<p>故事从我出生的时候讲起。我的亲生母亲是一个年轻的,没有结婚的大学毕业生。她决定让别人收养我, 她十分想让我被大学毕业生收养。所以在我出生的时候，她已经做好了一切的准备工作，能使得我被一个律师和他的妻子所收养。但是她没有料到,当我出生之后,律师夫妇突然决定他们想要一个女孩。</p>

<p>So my parents, who were on a waiting list, got a call in the middle of the night asking: &ldquo;We have an unexpected baby boy; do you want him?&rdquo; They said: &ldquo;Of course.&rdquo; My biological mother later found out that my mother had never graduated from college and that my father had never graduated from high school. She refused to sign the final adoption papers. She only relented a few months later when my parents promised that I would someday go to college.</p>

<p>所以我的生养父母(他们还在我亲生父母的观察名单上)突然在半夜接到了一个电话:“我们现在这儿有一个不小心生出来的男婴,你们想要他吗?”他们回答道:“当然!”但是我亲生母亲随后发现，我的养母从来没有上过大学,我的父亲甚至从没有读过高中。她拒绝签这个收养合同。只是在几个月以后,我的父母答应她一定要让我上大学,那个时候她才同意。</p>

<p>And 17 years later I did go to college. But I naively chose a college that was almost as expensive as Stanford, and all of my working-class parents' savings were being spent on my college tuition. After six months, I couldn&rsquo;t see the value in it. I had no idea what I wanted to do with my life and no idea how college was going to help me figure it out.</p>

<p>在十七岁那年,我真的上了大学。但是我很愚蠢的选择了一个几乎和你们斯坦福大学一样贵的学校, 我父母还处于蓝领阶层，他们几乎把所有积蓄都花在了我的学费上面。在六个月后, 我已经看不到其中的价值所在。我不知道我想要在生命中做什么,我也不知道大学能帮助我找到怎样的答案。</p>

<p>And here I was spending all of the money my parents had saved their entire life. So I decided to drop out and trust that it would all work out OK. It was pretty scary at the time, but looking back it was one of the best decisions I ever made. The minute I dropped out I could stop taking the required classes that didn&rsquo;t interest me, and begin dropping in on the ones that looked interesting.</p>

<p>但是在这里，我几乎花光了我父母这一辈子的所有积蓄。所以我决定要退学,我觉得这是个正确的决定。不能否认,我当时确实非常的害怕, 但是现在回头看看,那的确是我这一生中最棒的一个决定。在我做出退学决定的那一刻, 我终于可以不必去读那些令我提不起丝毫兴趣的课程了。然后我还可以去修那些看起来有点意思的课程。</p>

<p>It wasn&rsquo;t all romantic. I didn&rsquo;t have a dorm room, so I slept on the floor in friends' rooms, I returned coke bottles for the 5¢ deposits to buy food with, and I would walk the 7 miles across town every Sunday night to get one good meal a week at the Hare Krishna temple. I loved it. And much of what I stumbled into by following my curiosity and intuition turned out to be priceless later on. Let me give you one example:</p>

<p>但是这并不是那么罗曼蒂克。我失去了我的宿舍,所以我只能在朋友房间的地板上面睡觉,我去捡5美分的可乐瓶子，仅仅为了填饱肚子, 在星期天的晚上,我需要走七英里的路程，穿过这个城市到Hare Krishna寺庙(注：位于纽约Brooklyn下城),只是为了能吃上饭——这个星期唯一一顿好一点的饭。但是我喜欢这样。我跟着我的直觉和好奇心走, 遇到的很多东西,此后被证明是无价之宝。让我给你们举一个例子吧：</p>

<p>　　Reed College at that time offered perhaps the best calligraphy instruction in the country. Throughout the campus every poster, every label on every drawer, was beautifully hand calligraphed. Because I had dropped out and didn&rsquo;t have to take the normal classes, I decided to take a calligraphy class to learn how to do this.</p>

<p>Reed大学在那时提供也许是全美最好的美术字课程。在这个大学里面的每个海报, 每个抽屉的标签上面全都是漂亮的美术字。因为我退学了, 没有受到正规的训练, 所以我决定去参加这个课程，去学学怎样写出漂亮的美术字。</p>

<p>　　I learned about serif and san serif typefaces, about varying the amount of space between different letter combinations, about what makes great typography great. It was beautiful, historical, artistically subtle in a way that science can&rsquo;t capture, and I found it fascinating.
　　</p>

<p>我学到了san serif 和serif字体, 我学会了怎么样在不同的字母组合之中改变空格的长度, 还有怎么样才能作出最棒的印刷式样。那是一种科学永远不能捕捉到的、美丽的、真实的艺术精妙, 我发现那实在是太美妙了。</p>

<p>　　None of this had even a hope of any practical application in my life. But ten years later, when we were designing the first Macintosh computer, it all came back to me. And we designed it all into the Mac. It was the first computer with beautiful typography. If I had never dropped in on that single course in college, the Mac would have never had multiple typefaces or proportionally spaced fonts.
　　</p>

<p>当时看起来这些东西在我的生命中，好像都没有什么实际应用的可能。但是十年之后,当我们在设计第一台Macintosh电脑的时候,就不是那样了。我把当时我学的那些家伙全都设计进了Mac。那是第一台使用了漂亮的印刷字体的电脑。</p>

<p>　　And since Windows just copied the Mac, its likely that no personal computer would have them. If I had never dropped out, I would have never dropped in on this calligraphy class, and personal computers might not have the wonderful typography that they do. Of course it was impossible to connect the dots looking forward when I was in college. But it was very, very clear looking backwards ten years later.
　　</p>

<p>如果我当时没有退学, 就不会有机会去参加这个我感兴趣的美术字课程, Mac就不会有这么多丰富的字体，以及赏心悦目的字体间距。那么现在个人电脑就不会有现在这么美妙的字型了。当然我在大学的时候，还不可能把从前的点点滴滴串连起来,但是当我十年后回顾这一切的时候,真的豁然开朗了。</p>

<p>　　Again, you can&rsquo;t connect the dots looking forward; you can only connect them looking backwards. So you have to trust that the dots will somehow connect in your future. You have to trust in something - your gut, destiny, life, karma, whatever. This approach has never let me down, and it has made all the difference in my life.
　　</p>

<p>再次说明的是,你在向前展望的时候不可能将这些片断串连起来;你只能在回顾的时候将点点滴滴串连起来。所以你必须相信这些片断会在你未来的某一天串连起来。你必须要相信某些东西：你的勇气、目的、生命、因缘。这个过程从来没有令我失望(let me down),只是让我的生命更加地与众不同而已。</p>

<h3>　　My second story is about love and loss.</h3>

<h3>　　我的第二个故事是关于爱和损失的。</h3>

<p>　　I was lucky – I found what I loved to do early in life. Woz and I started Apple in my parents garage when I was 20. We worked hard, and in 10 years Apple had grown from just the two of us in a garage into a billion company with over 4000 employees. We had just released our finest creation - the Macintosh - a year earlier, and I had just turned 30.
　　</p>

<p>我非常幸运, 因为我在很早的时候就找到了我钟爱的东西。Woz和我在二十岁的时候就在父母的车库里面开创了苹果公司。我们工作得很努力, 十年之后, 这个公司从那两个车库中的穷光蛋发展到了超过四千名的雇员、价值超过二十亿的大公司。在公司成立的第九年,我们刚刚发布了最好的产品,那就是Macintosh。我也快要到三十岁了。</p>

<p>　　And then I got fired. How can you get fired from a company you started? Well, as Apple grew we hired someone who I thought was very talented to run the company with me, and for the first year or so things went well. But then our visions of the future began to diverge and eventually we had a falling out. When we did, our Board of Directors sided with him. So at 30 I was out. And very publicly out. What had been the focus of my entire adult life was gone, and it was devastating.
　　</p>

<p>在那一年, 我被炒了鱿鱼。你怎么可能被你自己创立的公司炒了鱿鱼呢? 嗯,在苹果快速成长的时候，我们雇用了一个很有天分的家伙和我一起管理这个公司, 在最初的几年,公司运转的很好。但是后来我们对未来的看法发生了分歧, 最终我们吵了起来。当争吵不可开交的时候, 董事会站在了他的那一边。所以在三十岁的时候, 我被炒了。在这么多人的眼皮下我被炒了。在而立之年，我生命的全部支柱离自己远去, 这真是毁灭性的打击。</p>

<p>I really didn&rsquo;t know what to do for a few months. I felt that I had let the previous generation of entrepreneurs down - that I had dropped the baton as it was being passed to me. I met with David Packard and Bob Noyce and tried to apologize for screwing up so badly.</p>

<p>在最初的几个月里，我真是不知道该做些什么。我把从前的创业激情给丢了, 我觉得自己让与我一同创业的人都很沮丧。我和David Pack和Bob Boyce见面，并试图向他们道歉。</p>

<p>　　I was a very public failure, and I even thought about running away from the valley. But something slowly began to dawn on me – I still loved what I did. The turn of events at Apple had not changed that one bit. I had been rejected, but I was still in love. And so I decided to start over.
　　</p>

<p>我把事情弄得糟糕透顶了。但是我渐渐发现了曙光, 我仍然喜爱我从事的这些东西。苹果公司发生的这些事情丝毫的没有改变这些, 一点也没有。我被驱逐了,但是我仍然钟爱它。所以我决定从头再来。</p>

<p>　　I didn&rsquo;t see it then, but it turned out that getting fired from Apple was the best thing that could have ever happened to me. The heaviness of being successful was replaced by the lightness of being a beginner again, less sure about everything. It freed me to enter one of the most creative periods of my life.
　　</p>

<p>我当时没有觉察, 但是事后证明, 从苹果公司被炒是我这辈子发生的最棒的事情。因为，作为一个成功者的极乐感觉被作为一个创业者的轻松感觉所重新代替: 对任何事情都不那么特别看重。这让我觉得如此自由, 进入了我生命中最有创造力的一个阶段。</p>

<p>　　During the next five years, I started a company named NeXT, another company named Pixar, and fell in love with an amazing woman who would become my wife. Pixar went on to create the worlds first computer animated feature film, Toy Story, and is now the most successful animation studio in the world.
　　</p>

<p>在接下来的五年里, 我创立了一个名叫NeXT的公司, 还有一个叫Pixar的公司, 然后和一个后来成为我妻子的优雅女人相识。Pixar 制作了世界上第一个用电脑制作的动画电影——“”玩具总动员”,Pixar现在也是世界上最成功的电脑制作工作室。</p>

<p>　　In a remarkable turn of events, Apple bought NeXT, I retuned to Apple, and the technology we developed at NeXT is at the heart of Apple&rsquo;s current renaissance. And Laurene and I have a wonderful family together.
　　</p>

<p>在后来的一系列运转中,Apple收购了NeXT, 然后我又回到了Apple公司。我们在NeXT发展的技术在Apple的复兴之中发挥了关键的作用。我还和Laurence 一起建立了一个幸福的家庭。</p>

<p>　　I&rsquo;m pretty sure none of this would have happened if I hadn&rsquo;t been fired from Apple. It was awful tasting medicine, but I guess the patient needed it. Sometimes life hits you in the head with a brick. Don&rsquo;t lose faith. I&rsquo;m convinced that the only thing that kept me going was that I loved what I did. You&rsquo;ve got to find what you love.
　　</p>

<p>我可以非常肯定,如果我不被Apple开除的话, 这其中一件事情也不会发生的。这个良药的味道实在是太苦了,但是我想病人需要这个药。有些时候, 生活会拿起一块砖头向你的脑袋上猛拍一下。不要失去信心。我很清楚唯一使我一直走下去的，就是我做的事情令我无比钟爱。你需要去找到你所爱的东西</p>

<p>　　And that is as true for your work as it is for your lovers. Your work is going to fill a large part of your life, and the only way to be truly satisfied is to do what you believe is great work. And the only way to do great work is to love what you do. If you haven&rsquo;t found it yet, keep looking. Don&rsquo;t settle. As with all matters of the heart, you&rsquo;ll know when you find it. And, like any great relationship, it just gets better and better as the years roll on. So keep looking until you find it. Don&rsquo;t settle.
　　</p>

<p>对于工作是如此, 对于你的爱人也是如此。你的工作将会占据生活中很大的一部分。你只有相信自己所做的是伟大的工作, 你才能怡然自得。如果你现在还没有找到, 那么继续找、不要停下来、全心全意的去找, 当你找到的时候你就会知道的。就像任何真诚的关系, 随着岁月的流逝只会越来越紧密。所以继续找，直到你找到它，不要停下来!</p>

<h3>　　My third story is about death.</h3>

<h3>　　我的第三个故事是关于死亡的。</h3>

<p>　　When I was 17, I read a quote that went something like: &ldquo;If you live each day as if it was your last, someday you&rsquo;ll most certainly be right.&rdquo; It made an impression on me, and since then, for the past 33 years, I have looked in the mirror every morning and asked myself: &ldquo;If today were the last day of my life, would I want to do what I am about to do today?&rdquo; And whenever the answer has been &ldquo;No&rdquo; for too many days in a row, I know I need to change something.
　　</p>

<p>当我十七岁的时候, 我读到了一句话:“如果你把每一天都当作生命中最后一天去生活的话,那么有一天你会发现你是正确的。”这句话给我留下了深刻的印象。从那时开始,过了33年,我在每天早晨都会对着镜子问自己:“如果今天是我生命中的最后一天, 你会不会完成你今天想做的事情呢?”当答案连续很多次被给予“不是”的时候, 我知道自己需要改变某些事情了。</p>

<p>　　Remembering that I&rsquo;ll be dead soon is the most important tool I&rsquo;ve ever encountered to help me make the big choices in life. Because almost everything – all external expectations, all pride, all fear of embarrassment or failure - these things just fall away in the face of death, leaving only what is truly important. Remembering that you are going to die is the best way I know to avoid the trap of thinking you have something to lose. You are already naked. There is no reason not to follow your heart.
　　</p>

<p>“记住你即将死去”是我一生中遇到的最重要箴言。它帮我指明了生命中重要的选择。因为几乎所有的事情, 包括所有的荣誉、所有的骄傲、所有对难堪和失败的恐惧,这些在死亡面前都会消失。我看到的是留下的真正重要的东西。你有时候会思考你将会失去某些东西,“记住你即将死去”是我知道的避免这些想法的最好办法。你已经赤身裸体了, 你没有理由不去跟随自己的心一起跳动。</p>

<p>　　About a year ago I was diagnosed with cancer. I had a scan at 7:30 in the morning, and it clearly showed a tumor on my pancreas. I didn&rsquo;t even know what a pancreas was. The doctors told me this was almost certainly a type of cancer that is incurable, and that I should expect to live no longer than three to six months. My doctor advised me to go home and get my affairs in order, which is doctor&rsquo;s code for prepare to die. It means to try to tell your kids everything you thought you&rsquo;d have the next 10 years to tell them in just a few months. It means to make sure everything is buttoned up so that it will be as easy as possible for your family. It means to say your goodbyes.
　　</p>

<p>大概一年以前, 我被诊断出癌症。我在早晨七点半做了一个检查, 检查清楚的显示在我的胰腺有一个肿瘤。我当时都不知道胰腺是什么东西。医生告诉我那很可能是一种无法治愈的癌症, 我还有三到六个月的时间活在这个世界上。我的医生叫我回家, 然后整理好我的一切, 那就是医生准备死亡的程序。那意味着你将要把未来十年对你小孩说的话在几个月里面说完.;那意味着把每件事情都搞定, 让你的家人会尽可能轻松的生活;那意味着你要说“再见了”。</p>

<p>　　I lived with that diagnosis all day. Later that evening I had a biopsy, where they stuck an endoscope down my throat, through my stomach and into my intestines, put a needle into my pancreas and got a few cells from the tumor. I was sedated, but my wife, who was there, told me that when they viewed the cells under a microscope the doctors started crying because it turned out to be a very rare form of pancreatic cancer that is curable with surgery. I had the surgery and I&rsquo;m fine now.
　　</p>

<p>我整天和那个诊断书一起生活。后来有一天早上我作了一个活切片检查，医生将一个内窥镜从我的喉咙伸进去,通过我的胃, 然后进入我的肠子, 用一根针在我的胰腺上的肿瘤上取了几个细胞。我当时很镇静,因为我被注射了镇定剂。但是我的妻子在那里, 后来告诉我，当医生在显微镜地下观察这些细胞的时候他们开始尖叫, 因为这些细胞最后竟然是一种非常罕见的可以用手术治愈的胰腺癌症。我做了这个手术, 现在我痊愈了。</p>

<p>　　This was the closest I&rsquo;ve been to facing death, and I hope its the closest I get for a few more decades. Having lived through it, I can now say this to you with a bit more certainty than when death was a useful but purely intellectual concept:</p>

<p>那是我最接近死亡的时候, 我还希望这也是以后的几十年最接近的一次。从死亡线上又活了过来, 死亡对我来说，只是一个有用但是纯粹是知识上的概念的时候，我可以更肯定一点地对你们说：</p>

<p>　　No one wants to die. Even people who want to go to heaven don&rsquo;t want to die to get there. And yet death is the destination we all share. No one has ever escaped it. And that is as it should be, because Death is very likely the single best invention of Life. It is Life&rsquo;s change agent. It clears out the old to make way for the new. Right now the new is you, but someday not too long from now, you will gradually become the old and be cleared away. Sorry to be so dramatic, but it is quite true.
　　</p>

<p>没有人愿意死, 即使人们想上天堂, 人们也不会为了去那里而死。但是死亡是我们每个人共同的终点。从来没有人能够逃脱它。也应该如此。 因为死亡就是生命中最好的一个发明。它将旧的清除以便给新的让路。你们现在是新的, 但是从现在开始不久以后, 你们将会逐渐的变成旧的然后被清除。我很抱歉这很戏剧性, 但是这十分的真实。</p>

<p>　　Your time is limited, so don&rsquo;t waste it living someone else&rsquo;s life. Don&rsquo;t be trapped by dogma - which is living with the results of other people&rsquo;s thinking. Don&rsquo;t let the noise of other&rsquo;s opinions drown out your own inner voice. And most important, have the courage to follow your heart and intuition. They somehow already know what you truly want to become. Everything else is secondary.
　　</p>

<p>When I was young, there was an amazing publication called The Whole Earth Catalog, which was one of the bibles of my generation. It was created by a fellow named Stewart Brand not far from here in Menlo Park, and he brought it to life with his poetic touch. This was in the late 1960&rsquo;s, before personal computers and desktop publishing, so it was all made with typewriters, scissors, and polaroid cameras. It was sort of like Google in paperback form, 35 years before Google came along: it was idealistic, and overflowing with neat tools and great notion</p>

<p>　　Stewart and his team put out several issues of The Whole Earth Catalog, and then when it had run its course, they put out a final issue. It was the mid-1970s, and I was your age. On the back cover of their final issue was a photograph of an early morning country road, the kind you might find yourself hitchhiking on if you were so adventurous. Beneath it were the words: &ldquo;Stay Hungry. Stay Foolish.&rdquo; It was their farewell message as they signed off. Stay Hungry. Stay Foolish. And I have always wished that for myself. And now, as you graduate to begin anew, I wish that for you.
　　</p>

<p>Stay Hungry. Stay Foolish.</p>

<p>Thank you all very much.</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Mac - Navicat Premium 11.0.16 破解记录]]></title>
        <link href="http://swplzj.github.io/blog/2015/08/06/mac-navicat-premium-11-dot-0-16-po-jie-ji-lu/"/>
        <updated>2015-08-06T16:13:08+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/08/06/mac-navicat-premium-11-dot-0-16-po-jie-ji-lu</id>
        <content type="html"><![CDATA[<p>今天在测试聚信立相关接口时候，需要改变用户在数据库中聚信立认证状态，需要后台人员频繁帮忙修改改数据库中的值，有些麻烦。同事之前给推荐的数据库管理软件又过了试用期，只能重新安装，自己动手，丰衣足食。这是我安装 <code>Navicat Premium</code> 并破解的记录，供大家参考。</p>

<!--more-->


<p>1、安装 <code>Navicat Premium</code></p>

<p>2、打开注册机(若注册机无法打开，右击-显示简介-选中以32位模式打开)</p>

<p>3、（默认选择）点击 <code>Generate</code> 获取激活码</p>

<p>4、点击 <code>Activata</code>，弹出选择程序的窗口，选择 <code>Navicat Premium</code>，操作系统支持10.10（本人系统是Yosimite 10.10.3）</p>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_06_my_os_version.png"></p>

<p>5、点击 <code>patched</code> 又弹出选择程序的窗口，选择 <code>Navicat Premium</code></p>

<p>6、恭喜注册成功</p>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_06_crack_success.png"></p>

<p><code>注意</code>　　
　　</p>

<p>如果还不能激活请在终端运行以下命令（非常重要）：
　　</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>rm -Rf ~/Library/Application\ Support/PremiumSoft\ CyberTech/Navicat*
</span><span class='line'>
</span><span class='line'>rm -Rf ~/Library/Caches/com.prect.NavicatPremium 
</span><span class='line'>
</span><span class='line'>rm -Rf ~/Library/Preferences/com.prect.NavicatPremium.plist
</span><span class='line'>
</span><span class='line'>sudo rm -Rf /Applications/Navicat\ Premium.app/
</span></code></pre></td></tr></table></div></figure>


<p>执行完成后重启（一定要重启）再安装 <code>Navicat Premium</code>，并再次执行破解过程！</p>

<p>附破解注册机及 <code>navicat Premimum11.0.16</code> <a href="http://pan.baidu.com/s/1eQmwQky">安装包下载地址</a></p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Objective-C 规范整理]]></title>
        <link href="http://swplzj.github.io/blog/2015/08/06/objective-c-gui-fan-zheng-li/"/>
        <updated>2015-08-06T09:54:19+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/08/06/objective-c-gui-fan-zheng-li</id>
        <content type="html"><![CDATA[<p>这份规范参考了一些主流公司的代码规范，也结合自己实战中的操作整理而成，也是我们 iOS 团队的代码约定，为了减少项目维护成本，大家可以参照。</p>

<h2>目录</h2>

<ul>
<li><a href="#%E5%85%B3%E4%BA%8EView%E7%9A%84%E5%B8%83%E5%B1%80">关于View的布局</a></li>
<li><a href="#%E7%82%B9%E8%AF%AD%E6%B3%95">点语法</a></li>
<li><a href="#%E9%97%B4%E8%B7%9D">间距</a></li>
<li><a href="#%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD">条件判断</a>

<ul>
<li><a href="#%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6">三目运算符</a></li>
</ul>
</li>
<li><a href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">错误处理</a></li>
<li><a href="#%E6%96%B9%E6%B3%95">方法</a></li>
<li><a href="#%E5%8F%98%E9%87%8F">变量</a></li>
<li><a href="#%E5%91%BD%E5%90%8D">命名</a></li>
<li><a href="#%E6%B3%A8%E9%87%8A">注释</a></li>
<li><a href="#init-%E5%92%8C-dealloc">Init 和 Dealloc</a></li>
<li><a href="#%E5%AD%97%E9%9D%A2%E9%87%8F">字面量</a></li>
<li><a href="#CGRect-%E5%87%BD%E6%95%B0">CGRect 函数</a></li>
<li><a href="#%E5%B8%B8%E9%87%8F">常量</a></li>
<li><a href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B">枚举类型</a></li>
<li><a href="#%E4%BD%8D%E6%8E%A9%E7%A0%81">位掩码</a></li>
<li><a href="#%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7">私有属性</a></li>
<li><a href="#%E5%9B%BE%E7%89%87%E5%91%BD%E5%90%8D">图片命名</a></li>
<li><a href="#%E5%B8%83%E5%B0%94">布尔</a></li>
<li><a href="#%E5%8D%95%E4%BE%8B">单例</a></li>
<li><a href="#%E5%AF%BC%E5%85%A5">导入</a></li>
<li><a href="#Xcode-%E5%B7%A5%E7%A8%8B">Xcode 工程</a></li>
</ul>


<!--more-->


<h2>关于View的布局</h2>

<p>应该 <strong>始终</strong> 使用纯代码自动布局来实现视图展示</p>

<h2>点语法</h2>

<p>应该 <strong>始终</strong> 使用点语法来访问或者修改属性，访问其他实例时首选括号。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>view.backgroundColor = [UIColor orangeColor];
</span><span class='line'>[UIApplication sharedApplication].delegate;</span></code></pre></td></tr></table></div></figure>


<p><strong>反对：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[view setBackgroundColor:[UIColor orangeColor]];
</span><span class='line'>UIApplication.sharedApplication.delegate;</span></code></pre></td></tr></table></div></figure>


<h2>间距</h2>

<ul>
<li>一个缩进使用 4 个空格，永远不要使用制表符（tab）缩进。请确保在 Xcode 中设置了此偏好。</li>
<li>使用 Xcode 中 re-indent 功能定期对代码格式进行整理。</li>
<li>方法的大括号和其他的大括号（<code>if</code>/<code>else</code>/<code>switch</code>/<code>while</code> 等等）始终和声明在同一行开始，在新的一行结束。</li>
</ul>


<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (user.isHappy) {
</span><span class='line'>// Do something
</span><span class='line'>}
</span><span class='line'>else {
</span><span class='line'>// Do something else
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>方法之间应该正好空一行，这有助于视觉清晰度和代码组织性。在方法中的功能块之间应该使用空白分开，但往往可能应该创建一个新的方法。</li>
<li><code>@synthesize</code> 和 <code>@dynamic</code> 在实现中每个都应该占一个新行。</li>
</ul>


<h2>条件判断</h2>

<p>条件判断主体部分应该始终使用大括号括住来防止出错，即使它可以不用大括号（例如它只需要一行）。这些错误包括添加第二行（代码）并希望它是 if 语句的一部分时。还有另外一种更危险的，当 if 语句里面的一行被注释掉，下一行就会在不经意间成为了这个 if 语句的一部分。此外，这种风格也更符合所有其他的条件判断，因此也更容易检查。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (!error) {
</span><span class='line'>    return success;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><strong>反对：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (!error)
</span><span class='line'>    return success;</span></code></pre></td></tr></table></div></figure>


<p>或</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (!error) return success;</span></code></pre></td></tr></table></div></figure>


<h3>三目运算符</h3>

<p>三目运算符，? ，只有当它可以增加代码清晰度或整洁时才使用。单一的条件都应该优先考虑使用。多条件时通常使用 if 语句会更易懂，或者重构为实例变量。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>result = a &gt; b ? x : y;</span></code></pre></td></tr></table></div></figure>


<p><strong>反对：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>result = a &gt; b ? x = c &gt; d ? c : d : y;</span></code></pre></td></tr></table></div></figure>


<h2>错误处理</h2>

<p>当引用一个返回错误参数（error parameter）的方法时，应该针对返回值，而非错误变量。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSError *error;
</span><span class='line'>if (![self trySomethingWithError:&error]) {
</span><span class='line'>    // 处理错误
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><strong>反对：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSError *error;
</span><span class='line'>[self trySomethingWithError:&error];
</span><span class='line'>if (error) {
</span><span class='line'>    // 处理错误
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>一些苹果的 API 在成功的情况下会写一些垃圾值给错误参数（如果非空），所以针对错误变量可能会造成虚假结果（以及接下来的崩溃）。</p>

<h2>方法</h2>

<p>在方法签名中，在 -/+ 符号后应该有一个空格。方法片段之间也应该有一个空格。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)setExampleText:(NSString *)text image:(UIImage *)image;</span></code></pre></td></tr></table></div></figure>


<p><strong>对方法进行分组</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#pragma mark - View Life Cycle //视图生命周期
</span><span class='line'>#pragma mark - AutoLayout Methods//适配
</span><span class='line'>#pragma mark - Private Methods//私有方法
</span><span class='line'>#pragma mark - UITableView Delegate
</span><span class='line'>#pragma mark - UITableView Datasource
</span><span class='line'>#pragma mark - Event Response//事件处理
</span><span class='line'>#pragma mark - Getter And Setter//放到下面
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<h2>变量</h2>

<p>变量名应该尽可能命名为描述性的。除了 <code>for()</code> 循环外，其他情况都应该避免使用单字母的变量名。
星号表示指针属于变量，例如：<code>NSString *text</code> 不要写成 <code>NSString* text</code> 或者 <code>NSString * text</code> ，常量除外。
尽量定义属性来代替直接使用实例变量。除了初始化方法（<code>init</code>， <code>initWithCoder:</code>，等）， <code>dealloc</code> 方法和自定义的 setters 和 getters 内部，应避免直接访问实例变量。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface UCSection: NSObject
</span><span class='line'>
</span><span class='line'>@property (nonatomic) NSString *headline;
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p><strong>反对：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface UCSection : NSObject {
</span><span class='line'>    NSString *headline;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>变量限定符</h4>

<p>当涉及到在 ARC 中被引入变量限定符时，
限定符 (<code>__strong</code>, <code>__weak</code>, <code>__unsafe_unretained</code>, <code>__autoreleasing</code>) 应该位于星号和变量名之间，如：<code>NSString * __weak text</code>。</p>

<h2>命名</h2>

<p>尽可能遵守苹果的命名约定，尤其那些涉及到内存管理规则的。</p>

<p>长的和描述性的方法名和变量名都不错。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIButton *settingsButton;</span></code></pre></td></tr></table></div></figure>


<p><strong>反对：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIButton *setBut;</span></code></pre></td></tr></table></div></figure>


<p>类名和常量应该始终使用项目前缀（例如 UCredit <code>UC</code>），但 Core Data 实体名称可以省略。为了代码清晰，常量应该使用相关类的名字作为前缀并使用驼峰命名法。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static const NSTimeInterval UCHomeViewControllerNavigationFadeAnimationDuration = 0.3;</span></code></pre></td></tr></table></div></figure>


<p><strong>反对：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static const NSTimeInterval fadetime = 1.7;</span></code></pre></td></tr></table></div></figure>


<p>属性和局部变量应该使用驼峰命名法并且首字母小写。</p>

<p>为了保持一致，实例变量应该使用驼峰命名法命名，并且首字母小写，以下划线为前缀。这与 LLVM 自动合成的实例变量相一致。</p>

<p>项目相关的类：使用项目中自定义的前缀，使用UC作前缀</p>

<p><strong>推荐</strong></p>

<pre><code>UCHomeViewController
</code></pre>

<p><strong>后缀要求</strong></p>

<ul>
<li>ViewController：使用ViewController作后缀</li>
<li>View：使用View作后缀</li>
<li>UITableCell：使用Cell作后缀</li>
<li>Protocol：使用Delegate或DataSource作后缀</li>
</ul>


<p><strong>宏命名</strong></p>

<p>全大写，单词间用 _ 分隔</p>

<pre><code>eg：#define THIS_IS_AN_MACRO @"THIS_IS_AN_MACRO"   
</code></pre>

<h2>注释</h2>

<p>当需要的时候，注释应该被用来解释 <strong>为什么</strong> 特定代码做了某些事情。所使用的任何注释必须保持最新否则就删除掉。</p>

<p>通常应该避免一大块注释，代码就应该尽量作为自身的文档，只需要隔几行写几句说明。这并不适用于那些用来生成文档的注释。注释需要与代码同步更新。</p>

<h2>init 和 dealloc</h2>

<p><code>dealloc</code> 方法应该放在实现文件的最上面，并且刚好在 <code>@synthesize</code> 和 <code>@dynamic</code> 语句的后面。在任何类中，<code>init</code> 都应该直接放在 <code>dealloc</code> 方法的下面。</p>

<p><code>init</code> 方法的结构应该像这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (instancetype)init {
</span><span class='line'>    self = [super init]; // 或者调用指定的初始化方法
</span><span class='line'>    if (self) {
</span><span class='line'>        // Custom initialization
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    return self;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>字面量</h2>

<p>每当创建 <code>NSString</code>， <code>NSDictionary</code>， <code>NSArray</code>，和 <code>NSNumber</code> 类的不可变实例时，都应该使用字面量。要注意 <code>nil</code> 值不能传给 <code>NSArray</code> 和 <code>NSDictionary</code> 字面量，这样做会导致崩溃。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSArray *names = @[@"Brian", @"Matt", @"Chris", @"Alex", @"Steve", @"Paul"];
</span><span class='line'>NSDictionary *productManagers = @{@"iPhone" : @"Kate", @"iPad" : @"Kamal", @"Mobile Web" : @"Bill"};
</span><span class='line'>NSNumber *shouldUseLiterals = @YES;
</span><span class='line'>NSNumber *buildingZIPCode = @10018;</span></code></pre></td></tr></table></div></figure>


<p><strong>反对：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSArray *names = [NSArray arrayWithObjects:@"Brian", @"Matt", @"Chris", @"Alex", @"Steve", @"Paul", nil];
</span><span class='line'>NSDictionary *productManagers = [NSDictionary dictionaryWithObjectsAndKeys: @"Kate", @"iPhone", @"Kamal", @"iPad", @"Bill", @"Mobile Web", nil];
</span><span class='line'>NSNumber *shouldUseLiterals = [NSNumber numberWithBool:YES];
</span><span class='line'>NSNumber *buildingZIPCode = [NSNumber numberWithInteger:10018];</span></code></pre></td></tr></table></div></figure>


<h2>CGRect 函数</h2>

<p>当访问一个 <code>CGRect</code> 的 <code>x</code>， <code>y</code>， <code>width</code>， <code>height</code> 时，应该使用<code>CGGeometry</code> 函数代替直接访问结构体成员。苹果的 <code>CGGeometry</code> 参考中说到：</p>

<blockquote><p>All functions described in this reference that take CGRect data structures as inputs implicitly standardize those rectangles before calculating their results. For this reason, your applications should avoid directly reading and writing the data stored in the CGRect data structure. Instead, use the functions described here to manipulate rectangles and to retrieve their characteristics.</p></blockquote>

<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CGRect frame = self.view.frame;
</span><span class='line'>
</span><span class='line'>CGFloat x = CGRectGetMinX(frame);
</span><span class='line'>CGFloat y = CGRectGetMinY(frame);
</span><span class='line'>CGFloat width = CGRectGetWidth(frame);
</span><span class='line'>CGFloat height = CGRectGetHeight(frame);</span></code></pre></td></tr></table></div></figure>


<p><strong>反对：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CGRect frame = self.view.frame;
</span><span class='line'>
</span><span class='line'>CGFloat x = frame.origin.x;
</span><span class='line'>CGFloat y = frame.origin.y;
</span><span class='line'>CGFloat width = frame.size.width;
</span><span class='line'>CGFloat height = frame.size.height;</span></code></pre></td></tr></table></div></figure>


<h2>常量</h2>

<p>常量首选内联字符串字面量或数字，因为常量可以轻易重用并且可以快速改变而不需要查找和替换。常量应该声明为 <code>static</code> 常量而不是 <code>#define</code> ，除非非常明确地要当做宏来使用。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static NSString * const UCAboutViewControllerCompanyName = @"The UCredit Company";
</span></code></pre></td></tr></table></div></figure>


<p><strong>反对：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define CompanyName @"The UCredit Company"</span></code></pre></td></tr></table></div></figure>


<h2>枚举类型</h2>

<p>当使用 <code>enum</code> 时，建议使用新的基础类型规范，因为它具有更强的类型检查和代码补全功能。现在 SDK 包含了一个宏来鼓励使用使用新的基础类型 - <code>NS_ENUM()</code></p>

<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef NS_ENUM(NSInteger,UCAdRequestState) {
</span><span class='line'>      UCAdRequestStateInactive,
</span><span class='line'>    UCAdRequestStateLoading
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<h2>位掩码</h2>

<p>当用到位掩码时，使用 <code>NS_OPTIONS</code> 宏。</p>

<p><strong>举例：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef NS_OPTIONS(NSUInteger, UCAdCategory) {
</span><span class='line'>UCAdCategoryAutos      = 1 &lt;&lt; 0,
</span><span class='line'>UCAdCategoryJobs       = 1 &lt;&lt; 1,
</span><span class='line'>UCAdCategoryRealState  = 1 &lt;&lt; 2,
</span><span class='line'>UCAdCategoryTechnology = 1 &lt;&lt; 3
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<h2>私有属性</h2>

<p>私有属性应该声明在类实现文件的延展（匿名的类目）中。有名字的类目（例如 <code>UCPrivate</code> 或 <code>private</code>）永远都不应该使用，除非要扩展其他类。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface UCAdvertisement ()
</span><span class='line'>
</span><span class='line'>@property (nonatomic, strong) GADBannerView *googleAdView;
</span><span class='line'>@property (nonatomic, strong) ADBannerView *iAdView;
</span><span class='line'>@property (nonatomic, strong) UIWebView *adXWebView;
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<h2>图片命名</h2>

<p>为了便于图片资源的管理和维护，图片统一使用Image.xcassets，图片名称应该被统一命名以保持组织的完整。它们应该被命名为一个说明它们用途的带下划线字符串，其次是自定义类或属性的无前缀名字（如果有的话），然后进一步说明颜色 和/或 展示位置，最后是它们的状态。</p>

<p><strong>推荐：</strong></p>

<ul>
<li><code>smile_tab_default_selected@2x</code> / <code>smile_tab_default_selected@3x</code></li>
<li><code>sidebar_bg_mask_white@2x</code> / <code>sidebar_bg_mask_white@3x</code></li>
</ul>


<p>图片目录中被用于类似目的的图片应归入各自的组中。</p>

<h2>布尔</h2>

<p>因为 <code>nil</code> 解析为 <code>NO</code>，所以没有必要在条件中与它进行比较。永远不要直接和 <code>YES</code> 进行比较，因为 <code>YES</code> 被定义为 1，而 <code>BOOL</code> 可以多达 8 位。</p>

<p>这使得整个文件有更多的一致性和更大的视觉清晰度。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (!someObject) {
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><strong>反对：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (someObject == nil) {
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<hr />

<p><strong>对于 <code>BOOL</code> 来说, 这有两种用法:</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (isAwesome)
</span><span class='line'>if (![someObject boolValue])</span></code></pre></td></tr></table></div></figure>


<p><strong>反对：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if ([someObject boolValue] == NO)
</span><span class='line'>if (isAwesome == YES) // 永远别这么做</span></code></pre></td></tr></table></div></figure>


<hr />

<p>如果一个 <code>BOOL</code> 属性名称是一个形容词，属性可以省略 “is” 前缀，但为 get 访问器指定一个惯用的名字，例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@property (assign, getter=isEditable) BOOL editable;</span></code></pre></td></tr></table></div></figure>


<p>内容和例子来自 Cocoa 命名指南。</p>

<h2>单例</h2>

<p>单例对象应该使用线程安全的模式创建共享的实例。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (instancetype)sharedInstance {
</span><span class='line'>   static id sharedInstance = nil;
</span><span class='line'>
</span><span class='line'>   static dispatch_once_t onceToken;
</span><span class='line'>   dispatch_once(&onceToken, ^{
</span><span class='line'>      sharedInstance = [[self alloc] init];
</span><span class='line'>   });
</span><span class='line'>
</span><span class='line'>   return sharedInstance;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这将会预防有时可能产生的许多崩溃。</p>

<h2>导入</h2>

<p>如果有一个以上的 import 语句，就对这些语句进行分组。每个分组的注释是可选的。 <br/>
注：对于模块使用 @import 语法。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Frameworks
</span><span class='line'>@import QuartzCore;
</span><span class='line'>
</span><span class='line'>// Models
</span><span class='line'>#import "UCUser.h"
</span><span class='line'>
</span><span class='line'>// Views
</span><span class='line'>#import "UCButton.h"
</span><span class='line'>#import "UCUserView.h"</span></code></pre></td></tr></table></div></figure>


<p></p>

<h2>Xcode 工程</h2>

<p>为了避免文件杂乱，物理文件应该保持和 Xcode 项目文件同步。Xcode 创建的任何组（group）都必须在文件系统有相应的映射。为了更清晰，代码不仅应该按照类型进行分组，也可以根据功能进行分组。</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[iOS - '#'引发的思考]]></title>
        <link href="http://swplzj.github.io/blog/2015/08/04/ios-number-yin-fa-de-si-kao/"/>
        <updated>2015-08-04T18:37:45+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/08/04/ios-number-yin-fa-de-si-kao</id>
        <content type="html"><![CDATA[<p>在代码中使用 <code>Autolayout</code> 时，大家都会使用 <code>NSDictionaryOfVariableBindings</code> 这个宏，这个宏可以生成一个变量名到变量值映射的 <code>Dictionary</code>。比如 <code>NSDictionaryOfVariableBindings(button1, button2)</code> 将会生成一个<code>{ @"button1" = button1, @"button2 = button2 }</code> 的 <code>Dictionary</code>。它是怎么做到的呢？我们来看看这个宏的定义：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define NSDictionaryOfVariableBindings(...) _NSDictionaryOfVariableBindings(@"" # __VA_ARGS__, __VA_ARGS__, nil)</span></code></pre></td></tr></table></div></figure>


<p>这个宏定义中有3个参数，后两个参数不难理解，但第一个参数中间有个 <code>#</code> 符号，语法上看起来比较怪异，这个是什么呢？以前在做越狱的 <code>mobilesubstrate</code> 开发时，其中定义的一堆宏频繁使用了这个符号，下面就来揭开 <code>#</code> 这个符号在宏定义中的迷雾。</p>

<!--more-->


<h3>预编译的一些知识</h3>

<p>我们的代码在 <code>build</code> 时并不是直接进行编译的，在编译之前还进行了预编译处理。预编译会把 <code>include</code> 或 <code>import</code> 的文件导入到文件中，同时会将代码中用到的宏进行替换。注意宏是直接在代码中替换成宏的定义的，如果有嵌套也会逐层替换。</p>

<h3>“#”指示一些预编译命令</h3>

<p>预编译命令一般都是以 <code>#</code> 开头的，比如 <code>#include</code>、<code>#import</code>、<code>#if</code> 等，在这里就不一一说明了，本文主要说明一下 <code>#</code> 在宏定义里面的一些作用。</p>

<h3>宏参数字符串化</h3>

<p>在一个参数前加一个<code>#</code>，预处理时将会变成这个参数名的字符串常量，即字符串化（<code>stringify</code>）。比如:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define GET_NAME(X) #X
</span><span class='line'>int a = 0;
</span><span class='line'>NSLog(@"%s",GET_NAME(a));      //output: "a"
</span><span class='line'>NSLog(@"%s",GET_NAME(a+3));    //output: "a+3"</span></code></pre></td></tr></table></div></figure>


<p>将会得到以下输出：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a
</span><span class='line'>a+3</span></code></pre></td></tr></table></div></figure>


<p>可以看出<code>#</code>，将参数原样转换成字符串常量，如果参数是一个表达式，那么输出这个表达式的原样字符串常量。</p>

<p>回头再看看<code>NSDictionaryOfVariableBindings</code>的定义：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define NSDictionaryOfVariableBindings(...) _NSDictionaryOfVariableBindings(@"" # __VA_ARGS__, __VA_ARGS__, nil)</span></code></pre></td></tr></table></div></figure>


<p>如果这样生成两个<code>button</code>的映射：</p>

<pre><code>NSDictionaryOfVariableBindings(button1, button2);
</code></pre>

<p>那么预编译时就会转换成：</p>

<pre><code>_NSDictionaryOfVariableBindings(@"""button1, button2", button1, button2, nil);
</code></pre>

<p>由于两个常量字符串放在一起就是字符串常量串联，将变成两个字符串常量组合在一起的字符串常量，也就是上面是一个空字符串<code>""</code>和<code>"button1, button2"</code>串联，所以上面的代码等价于：</p>

<pre><code>_NSDictionaryOfVariableBindings(@"button1, button2", button1, button2, nil);
</code></pre>

<p>那么<code>_NSDictionaryOfVariableBindings</code>函数就可以将它的第一个参数按逗号,分割开作为<code>key</code>，后面就是各个<code>key</code>对应的值了。因此这段代码就创建了一个内容为<code>{ @"button1" = button1, @"button2 = button2 }</code>的<code>Dictionary</code>。</p>

<h3>命名的串联</h3>

<p><code>#</code>在宏定义中的另一个作用就是用于命名的串联，用<code>##</code>就可以串联它左右两边的命名，比如以下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define CONCAT(X, Y) X ## Y
</span><span class='line'>NSString *helloworld = @"Hello, world!";
</span><span class='line'>NSLog(@"%@",CONCAT(hello, world)); //output: "Hello, world"</span></code></pre></td></tr></table></div></figure>


<p><code>CONCAT(hello, world)</code>实际被转换成<code>helloworld</code>。注意一下，因为宏是预编译阶段进行展开的，就是说在编译之前，因此代码中的<code>hello</code>和<code>world</code>即使没有定义其实也是没问题的，预编译处理后，这两个命名是不存在的。</p>

<h3>可选可变参数</h3>

<p><code>##</code>在宏定义中可以放在<code>__VA_ARGS__</code>之前表示可变参数可以为空，否则的话可变参数至少为一个了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define MYLOG(format, ...) NSLog(format, ##__VA_ARGS__)
</span><span class='line'>MYLOG(@"Don't make an error!");</span></code></pre></td></tr></table></div></figure>


<p>上面代码中<code>MLOG</code>中只有一个参数，如果不加<code>##</code>，则<code>MLOG</code>至少需要两个参数，在<code>Xcode</code>里将会出现编译错误。</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Mac - 截屏功能高级篇]]></title>
        <link href="http://swplzj.github.io/blog/2015/08/04/mac-jie-ping-gong-neng-gao-ji-pian/"/>
        <updated>2015-08-04T16:29:59+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/08/04/mac-jie-ping-gong-neng-gao-ji-pian</id>
        <content type="html"><![CDATA[<p>截屏在平常应该是最常用的功能了，虽然说有一些工具可以提供截屏，比如 QQ 带的截屏功能，但是默认的快捷键可能与系统自定义冲突，或者使用鼠标不方便。其实，系统本身所提供的截屏功能，足够我们使用，你真的认为你掌握了截屏功能？那进来看看吧。</p>

<!--more-->


<h3>最常用的截屏：</h3>

<ol>
<li>command + shift + 3  &ndash; 截取全屏</li>
<li>command + shift + 4  &ndash; 自定义大小截屏</li>
<li>command + shift + 4 + space &ndash; 截取特定区域</li>
</ol>


<h3>高级功能 - 在 command + shift + 4 之后</h3>

<ol>
<li>长按空格 &ndash; 移动截屏区域；</li>
<li>长按 shift &ndash; 固定高度（宽度），调整截取区域宽度（高度）；</li>
<li>长按 option &ndash; 以中心点为中心宽度（高度）同时增加；</li>
<li>同时长按 shift + option 固定高度（宽度），以中心点为中心调整截取区域宽度（高度）；</li>
<li>command + shift + control &ndash; 把截图 copy 到剪贴板</li>
</ol>

]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[博客升级了]]></title>
        <link href="http://swplzj.github.io/blog/2015/07/31/bo-ke-sheng-ji-liao/"/>
        <updated>2015-07-31T19:17:56+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/07/31/bo-ke-sheng-ji-liao</id>
        <content type="html"><![CDATA[<p>博客其实早就搭建了，中间发布过一些文章，可是博客一直没有升级，现在针对以下几个功能进行了添加及优化。</p>

<ul>
<li>更换主题</li>
<li>添加站长统计</li>
<li>添加多说评论</li>
<li>添加七牛云图片存储服务</li>
<li>自动为图片添加url前缀</li>
<li>写在最后</li>
</ul>


<!--more-->


<h3>更换主题</h3>

<p>搭建完博客之后，接着就要更换为自己喜欢的主题了，选择的主题是 <a href="http://sofreshandsogreen.herokuapp.com">So Fresh and So Green</a>，喜欢这种带有活力的色调。具体设置步骤如下：</p>

<p><code>Step 1</code></p>

<p>使用命令安装主题；</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git clone https://github.com/johnkeith/sofreshandsogreen.git .themes/sofreshandsogreen
</span><span class='line'>  
</span><span class='line'>$ bundle exec rake install['sofreshandsogreen']</span></code></pre></td></tr></table></div></figure>


<p><code>Step 2</code></p>

<p>更改博客配置文件  <code>_config.yml</code>，需要移除默认主题的侧边栏，</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>default_asides: []
</span><span class='line'>sidebar: collapse</span></code></pre></td></tr></table></div></figure>


<p><code>Step 3</code></p>

<p>在首页显示显示圆形头像，首先到 <code>source/images</code>目录下面，使用你选择的头像替换掉 <code>portrait.jpg</code>, 然后再配置文件 <code>_config.yml</code> 中，添加下面一句代码：</p>

<pre><code>portrait: true
</code></pre>

<p>（BTW：我选择的头像使我们几个朋友一起亲手绘画的梵高的向日葵，色调与博客主题色调完美搭配，赞一个~~）</p>

<p>至此，博客主题安装完成。</p>

<h3>添加站长统计</h3>

<p>博客搭建完成之后，需要看自己博客被访问次数，访问页面，访问速度，页面停留时间&hellip;等等，都需要借助第三方的统计工具来完成的，类似于移动端 App 使用的友盟统计一样，这个还要简单只需要注册相应的账号，然后，在自己博客中添加官方提供的 JS 代码。我选择的是国内使用很广的 <a href="http://www.cnzz.com">CNZZ</a>，注册后，添加并验证你的网站就可以添加统计代码了，选好自己喜欢的样式，获得代码，可添加到 <code>source/_includes/custom/footer.html</code> 中。即可查看每天你的博客的流量，进行相应的优化了。</p>

<pre><code>&lt;script type="text/javascript"&gt;var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1255930196'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1255930196%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));&lt;/script&gt;
</code></pre>

<h3>添加多说评论</h3>

<p>Octopress默认自带了 <code>DISQUS</code> ，但是对于国内不是很好用，于是选择了多说作为评论插件，这个还是很接地气的。多说官网账号无需注册，我是使用的百度账号来进行设置，添加站点，获取站点 <code>short_name</code>。这个</p>

<p>在配置文件 <code>_config.yml</code> 中，添加以下代码：</p>

<pre><code>duoshuo_comments: true
duoshuo_short_name: yoursite (多说二级域名 yoursite.duoshuo.com)(yoursite是你在多说中添加的站点名称)
</code></pre>

<p>在 <code>source/_layouts/post.html</code> 中 <code>disqus</code> 代码下方添加<a href="https://github.com/swplzj/swplzj.github.io/blob/source/source/_layouts/post.html">多说代码本想粘贴出代码，但是一直显示不全只能留源文件地址了。</a></p>

<p>然后，在路径 <code>source/_includes/post</code>下创建一个 <code>duoshuo.html</code>, <a href="https://github.com/swplzj/swplzj.github.io/blob/source/source/_includes/post/duoshuo.html">直接上文件地址</a></p>

<p>到此为止，添加多说评论完成。</p>

<h3>添加七牛云存储作为图床</h3>

<p>博客其实已经可以正常发布博文，展示，数据统计，评论，归档等功能了，但是一直有个特殊情景，在困扰着我，假如我想发布一篇博文，博文中包含很多图片，大家都知道在 Markdown 语言中添加一张图片，是很简单的，直接使用语法，发一个图片地址就可以了。但是这个图片放到本地，然后随博客同步到 GitHub 上的话，就会造成两个主要问题，第一，在国内由于网络问题，加载图片特别缓慢；第二，GitHub 免费存储是固定的，用来当做图床，不是明智之举，鉴于此，就寻找国内比较稳定优秀的图床。最终选择了七牛云存储，优点：访问速度极快，支持日志、防盗链和水印。然后有了图床，就解决了图片存储的问题，流程就是，先把博文中所要使用的图片，先上传到七牛上，然后拿到获取此资源的链接，写到博文中，就可以了。</p>

<h3>自动为图片添加url前缀</h3>

<p>我把图片资源都放在了七牛云存储上，写博客时候就是用七牛的外链。但是这样有几个问题：
每次写博客插入图片外链地址时候都很麻烦，需要给每张图片都添加七牛外链地址url前缀；
如果以后更换了存储，那就麻烦了，需要依次编辑替换每个图片的url前缀
现在我们就使用一种灵活的方式来配置并自动生成图片的url前缀：</p>

<p>1.修改 <code>/plugins/image_tag.rb</code> 文件，在</p>

<pre><code>@img['class'].gsub!(/"/, '') if @img['class']
</code></pre>

<p>后添加下面一行代码：</p>

<pre><code>@img['src'] = Jekyll.configuration({})['static_file_prefix'] + @img['src'] if @img['src'][0] == '/'
</code></pre>

<p>2.再修改根目录下的 <code>_config.yml</code> 文件，添加如下配置：</p>

<pre><code>static_file_prefix: http://7u2i08.com1.z0.glb.clouddn.com
</code></pre>

<p>这样在生成文章的时候，以 <code>/</code> 开头的图片会自动加上 <code>http://7u2i08.com1.z0.glb.clouddn.com</code> 前缀。</p>

<p>3.我们在插入图片的时候要记住不能再使用 Markdown 语法来写了，要使用 Ocotpress 自定义的 <code>Image Tag</code> 来插入图片。</p>

<p>4.使用 <a href="http://developer.qiniu.com/docs/v6/tools/qrsync.html"><code>qrsync</code></a> 同步图片资源。<code>qrsync</code> 是一个根据七牛云存储API实现的简易命令行辅助上传同步工具，支持断点续上传，增量同步，它可将用户本地的某目录的文件同步到七牛云存储中，同步或上传几百GB甚至上TB的文件毫无鸭梨。
下载对应的命令行辅助同步工具，我使用的Mac，下载完成后，解压出命令执行文件，放到 <code>/usr/local/bin</code> 目录下。</p>

<p>5.创建一个配置文件（<a href="http://json.org/json-zh.html">JSON格式</a>）,可以命名为 <code>qrsync.json</code>,输入以下配置</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "debug_level" : 1,
</span><span class='line'>  "deletable" : 0,
</span><span class='line'>  "dest" : "qiniu:access_key=yourAccessKey&secret_key=yourSecretKey&bucket=yourSpaceName",
</span><span class='line'>  "src" : "/Users/yourname/octopress/source/images"
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>其中，<code>AccessKey</code> 和 <code>SecretKey</code> 就是之前咱们在七牛云存储平台上申请的。如图所示：</p>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_03_qi_niu_key.png"></p>

<table>
<thead>
<tr>
<th>参数              </th>
<th> 备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>debug_level     </td>
<td>  日志输出等级（通常设置1，只输出必要的日志）</td>
</tr>
<tr>
<td>deletable       </td>
<td> 是否同步删除七牛云上的文件（通常设置0，当本地文件删除时并不删除存储在七牛的对应文件）</td>
</tr>
<tr>
<td>src             </td>
<td> 本地源目录路径（本地需要同步上传目录的完整的绝对路径）</td>
</tr>
<tr>
<td>bucket          </td>
<td> 目标空间名称</td>
</tr>
</tbody>
</table>


<p>这样就可以使用七牛的资源同步辅助命令了。
本地预览先 <code>rake generate</code> 后 <code>rake preview</code> ，这样插入图片就灵活方便多了。</p>

<p><code>注意1</code></p>

<p>在 <code>rake generate</code> 时，我这里遇到一个错误，报错如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Configuration file: /Users/lizhenjie/octopress/_config.yml
</span><span class='line'>  Liquid Exception: undefined method `+' for nil:NilClass in _posts/2015-07-30-test.markdown/#excerpt
</span><span class='line'>jekyll 2.5.3 | Error:  undefined method `+' for nil:NilClass</span></code></pre></td></tr></table></div></figure>


<p>经过搜索，发现如果要把两个字符串连接在一起。如</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a = “abc”
</span><span class='line'>b = a + “de”</span></code></pre></td></tr></table></div></figure>


<p>此时b的值为 <code>abcde</code>
但如果 <code>a = nil</code> 时，就会抛出未定义“+”的异常，因为此时a为nil。仔细检查发现修改完 <code>/plugins/image_tag.rb</code> 文件后，没有做保存，没有关闭文件，造成的问题，还好我没有放弃，O(∩_∩)O哈哈~</p>

<p><code>注意2</code></p>

<p>我们在插入图片的时候要记住不能再使用 Markdown 语法来写了，要使用 Ocotpress 自定义的 <a href="http://octopress.org/docs/plugins/image-tag/">Image Tag</a> 来插入图片。
然后在发布博文之前，先同步自己的图片，</p>

<pre><code>qrsync qrsync.json 
</code></pre>

<p>然后，生成博文，发布博文</p>

<pre><code>rake generate
rake deploy
</code></pre>

<h3>写在最后</h3>

<p>终于大功告成，通过设置博客，也看到了很多优秀的博客，也看到自己与优秀极客的差距，这也更加坚定了我写博客，记录自己学习的点点滴滴的决心。希望能帮助到你们。有什么问题可以反馈。 Have fun！</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[iOS - UIWebView 动态载入/删除/更新外部 JavaScript/CSS 文件]]></title>
        <link href="http://swplzj.github.io/blog/2015/03/12/ios-uiwebview-dong-tai-zai-ru-slash-shan-chu-slash-geng-xin-wai-bu-javascript-slash-css-wen-jian/"/>
        <updated>2015-03-12T19:59:54+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/03/12/ios-uiwebview-dong-tai-zai-ru-slash-shan-chu-slash-geng-xin-wai-bu-javascript-slash-css-wen-jian</id>
        <content type="html"><![CDATA[<h5>动态载入 JavaScript/CSS 文件</h5>

<p>传统加载外部 <code>JavaScript(*.js)</code> 或者 <code>CSS(*.css)</code> 文件的方法是直接在 <code>&lt;head&gt;</code> 标签里面进行添加:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;head&gt; 
</span><span class='line'>&lt;script type="text/javascript" src="myscript.js"&gt;&lt;/script&gt; 
</span><span class='line'>&lt;link rel="stylesheet" type="text/css" href="main.css" /&gt; 
</span><span class='line'>&lt;/head&gt; </span></code></pre></td></tr></table></div></figure>




<!--more-->


<p>这些文件用这种方式会同步加载到当前这个页面。</p>

<h5>用动态的方式载入 JavaScript/CSS 文件：</h5>

<p>用 DOM createElement 方法创建一个 “script” 或者 ”link” 元素
设置相应的属性
使用 appendChild 方法, 把创建的元素插入到 head 标签的末尾</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function loadjscssfile(filename, filetype){ 
</span><span class='line'>//如果文件类型为 .js ,则创建 script 标签，并设置相应属性 
</span><span class='line'>if (filetype=="js"){ 
</span><span class='line'>var fileref=document.createElement('script'); 
</span><span class='line'>fileref.setAttribute("type","text/javascript"); 
</span><span class='line'>fileref.setAttribute("src", filename); 
</span><span class='line'>} 
</span><span class='line'>//如果文件类型为 .css ,则创建 script 标签，并设置相应属性 
</span><span class='line'>else if (filetype=="css"){ 
</span><span class='line'>var fileref=document.createElement("link"); 
</span><span class='line'>fileref.setAttribute("rel", "stylesheet"); 
</span><span class='line'>fileref.setAttribute("type", "text/css"); 
</span><span class='line'>fileref.setAttribute("href", filename); 
</span><span class='line'>} 
</span><span class='line'>if (typeof fileref!="undefined") 
</span><span class='line'>document.getElementsByTagName("head")[0].appendChild(fileref); 
</span><span class='line'>} 
</span><span class='line'>//动态添加一个.js 文件 
</span><span class='line'>loadjscssfile("myscript.js", "js"); 
</span><span class='line'>//像添加.js文件一样，动态添加一个.php文件 
</span><span class='line'>loadjscssfile("javascript.php", "js"); 
</span><span class='line'>//动态一个.css文件 
</span><span class='line'>loadjscssfile("mystyle.css", "css"); </span></code></pre></td></tr></table></div></figure>


<h5>为了防止多次载入同一个js/css文件， 添加以下判断（这只是粗略检测）</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//临时载入的文件名 
</span><span class='line'>var filesadded=""; 
</span><span class='line'>function checkloadjscssfile(filename, filetype){ 
</span><span class='line'>if (filesadded.indexOf("["+filename+"]")==-1){ 
</span><span class='line'>loadjscssfile(filename, filetype); 
</span><span class='line'>//把 [filename] 存入 filesadded 
</span><span class='line'>filesadded+="["+filename+"]"; 
</span><span class='line'>} 
</span><span class='line'>else{ 
</span><span class='line'>alert("file already added!"); 
</span><span class='line'>} 
</span><span class='line'>//第一次载入 
</span><span class='line'>checkloadjscssfile("myscript.js", "js"); 
</span><span class='line'>//重复载入同一个文件， 失败 
</span><span class='line'>checkloadjscssfile("myscript.js", "js"); </span></code></pre></td></tr></table></div></figure>


<h5>动态删除 JavaScript/Csss 文件</h5>

<p>注意：ie6/7 下动态删除样式时有bug. 2种解决方案：1.样式表里不要有import的样式表 2.把link的type属性设置为空值， 然后再修改 href 的地， 或者直接设置href为空， 最后再把type值设置成”text/css” 强制让ie解释新的样式表。</p>

<p>取得相应的 DOM 元素
根据 文件名&amp;文件类型 定位元素
用 DOM removeChild 删除一个 “script” 或者 ”link” 元素</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function removejscssfile(filename, filetype){ 
</span><span class='line'>//判断文件类型 
</span><span class='line'>var targetelement=(filetype=="js")? "script" : (filetype=="css")? "link" : "none"; 
</span><span class='line'>//判断文件名 
</span><span class='line'>var targetattr=(filetype=="js")? "src" : (filetype=="css")? "href" : "none"; 
</span><span class='line'>var allsuspects=document.getElementsByTagName(targetelement); 
</span><span class='line'>//遍历元素， 并删除匹配的元素 
</span><span class='line'>for (var i=allsuspects.length; i&gt;=0; i--){ 
</span><span class='line'>if (allsuspects[i] && allsuspects[i].getAttribute(targetattr)!=null && allsuspects[i].getAttribute(targetattr).indexOf(filename)!=-1) 
</span><span class='line'>allsuspects[i].parentNode.removeChild(allsuspects[i]); 
</span><span class='line'>} 
</span><span class='line'>} 
</span><span class='line'>removejscssfile("somescript.js", "js"); 
</span><span class='line'>removejscssfile("somestyle.css", "css"); </span></code></pre></td></tr></table></div></figure>


<h5>动态更新 JavaScript/Csss 文件</h5>

<p>使用 createElement 创建 要更新的 JavaScript/Css 元素
查找要被替换的元素
用 replaceChild 替换元素</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function createjscssfile(filename, filetype){ 
</span><span class='line'>if (filetype=="js"){ //if filename is a external JavaScript file 
</span><span class='line'>var fileref=document.createElement('script') 
</span><span class='line'>fileref.setAttribute("type","text/javascript") 
</span><span class='line'>fileref.setAttribute("src", filename) 
</span><span class='line'>} 
</span><span class='line'>else if (filetype=="css"){ //if filename is an external CSS file 
</span><span class='line'>var fileref=document.createElement("link") 
</span><span class='line'>fileref.setAttribute("rel", "stylesheet") 
</span><span class='line'>fileref.setAttribute("type", "text/css") 
</span><span class='line'>fileref.setAttribute("href", filename) 
</span><span class='line'>} 
</span><span class='line'>return fileref 
</span><span class='line'>} 
</span><span class='line'>
</span><span class='line'>function replacejscssfile(oldfilename, newfilename, filetype){ 
</span><span class='line'>var targetelement=(filetype=="js")? "script" : (filetype=="css")? "link" : "none"; 
</span><span class='line'>var targetattr=(filetype=="js")? "src" : (filetype=="css")? "href" : "none"; 
</span><span class='line'>var allsuspects=document.getElementsByTagName(targetelement); 
</span><span class='line'>for (var i=allsuspects.length; i&gt;=0; i--){ 
</span><span class='line'>if (allsuspects[i] && allsuspects[i].getAttribute(targetattr)!=null && allsuspects[i].getAttribute(targetattr).indexOf(oldfilename)!=-1){ 
</span><span class='line'>var newelement=createjscssfile(newfilename, filetype); 
</span><span class='line'>allsuspects[i].parentNode.replaceChild(newelement, allsuspects[i]); 
</span><span class='line'>} 
</span><span class='line'>} 
</span><span class='line'>} 
</span><span class='line'>//用 "newscript.js" 替换 "oldscript.js" 
</span><span class='line'>replacejscssfile("oldscript.js", "newscript.js", "js")； 
</span><span class='line'>//用 "newscript.css" 替换 "oldscript.css" 
</span><span class='line'>replacejscssfile("oldstyle.css", "newscript.css","css"); </span></code></pre></td></tr></table></div></figure>

]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Mac翻墙技巧]]></title>
        <link href="http://swplzj.github.io/blog/2015/03/08/macfan-qiang-ji-qiao/"/>
        <updated>2015-03-08T10:57:41+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/03/08/macfan-qiang-ji-qiao</id>
        <content type="html"><![CDATA[<h4>困扰</h4>

<p>自己一直在寻找Mac上的免费翻墙工具，尝试过很多，但最终都没办法实现，对自己也造成了一些影响，比如需要在国外网站查询一些资料，下载一些应用，观看Youtube视频，刷Facebook，最要命的就是最近自己的Gmail也收不到邮件了，不想购买VPN，那只能尝试找免费翻墙工具了。</p>

<p>终于找到免费翻墙的工具了</p>

<p>不敢独享，故贴出来和大家分享一下。</p>

<!--more-->


<h4>终于等到你，还好我没放弃</h4>

<h5>这种翻墙方法的优点：</h5>

<ul>
<li>免费</li>
<li>无需下载任何软件</li>
<li>配置门槛低，简单</li>
</ul>


<h5>工具使用方法</h5>

<p><code>工具网址</code></p>

<p>首先打开网站：<a href="http://vcup.in/nyve">VPNCUP</a></p>

<p><code>使用方法</code></p>

<h6>注册账号</h6>

<p>在这个网站上注册一个账号。</p>

<h6>设置VPN登录密码</h6>

<p>因为在配置网络的时候，都会使用到VPN的登录密码来进行验证，这个密码不是你的账号登录密码，你需要在我的账户里面来开启，并进行设置。</p>

<p>1、进入<code>我的账户</code>中的<code>VPN账户</code>;</p>

<p>2、将<code>VPN账户状态</code>设置为<code>开放</code>;</p>

<p>3、设置<code>VPN登录密码</code>;</p>

<h6>配置电脑网络设置</h6>

<p>关于如何配置电脑的网络设置，在官网有详细的说明，下面给出相应的链接，大家跟着说明一步步做就好了</p>

<ul>
<li><a href="https://www.vcup136.com/config/windows-xp">Windows XP设置登录VPN服务器图文介绍</a></li>
<li><a href="https://www.vcup136.com/config/iphone-l2tp">Apple Iphone和Apple iTouch设置登录VPN服务器图文介绍(L2TP模式)</a></li>
<li><a href="https://www.vcup136.com/config/iphone">Apple Iphone和Apple iTouch设置登录VPN服务器图文介绍(PPTP模式)</a></li>
<li><a href="https://www.vcup136.com/config/macosx">mac系统下的配置指南</a></li>
<li><a href="https://www.vcup136.com/config/ubuntu">Ubuntu设置VPN</a></li>
<li><a href="https://www.vcup136.com/config/windows">windows系统下的配置指南</a></li>
<li><a href="https://www.vcup136.com/config/android">Android系统设置VPN</a></li>
</ul>


<h4>总结</h4>

<p>设置完成了，大家可以享受墙外的世界了，希望能帮助到你。</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[面向 iOS 开发的优秀 XCode 插件]]></title>
        <link href="http://swplzj.github.io/blog/2015/02/13/mian-xiang-ios-kai-fa-de-you-xiu-xcode-cha-jian/"/>
        <updated>2015-02-13T21:05:50+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/02/13/mian-xiang-ios-kai-fa-de-you-xiu-xcode-cha-jian</id>
        <content type="html"><![CDATA[<p>一套理想的插件架构几乎能够决定整个集成开发环境的差异与特性。Sublime Text与TextMate就是很好的实例。但大家可能不了解的是，Xcode也支持插件。哈哈，如果各位真的前所未闻，我也不会感到惊讶，毕竟苹果并没有把太多精力用在Xcode的宣传之上。事实上，我们几乎找不到多少用于指导Xcode创建的说明文档。</p>

<p>幸运的是，这并没有妨碍开发人员在Xcode这片土地上耕耘并构建自己的插件果实。目前市面上存在大量插件，能够让我们的Xcode使用之旅更加平坦也更富乐趣，甚至足以弥合苹果在其中留下的所有沟壑。在今天的文章中，我将向大家展示自己在日常工作中频繁用到的几款优秀插件。</p>

<!--more-->


<h5>Alcatraz</h5>

<p>过去，安装Xcode插件往往令人抓狂不已，但Alcatraz的出现彻底改写了这一历史。今年早些时候，Alcatraz迎来了发展道路上的里程碑——1.0版本，现在如今已经可以与Xcode 5相兼容。如果大家还没有安装Alcatraz，我建议大家首先完成这项工作。</p>

<p>官方网站：<a href="http://alcatraz.io/">http://alcatraz.io/</a></p>

<h5>XToDo</h5>

<p>这款插件不仅能够着力强调TODO、FIXME、？？？以及！！！注释，同时可以按住 control + T 可以快速查看专用列表，并且可以自定义一些标签。</p>

<p><img src="http://s9.51cto.com/wyfs02/M00/46/84/wKioL1Pyvc2iUbyMAABLbcwVzmM494.jpg" alt="id1" /></p>

<p>官方网站：<a href="https://github.com/trawor/XToDo">https://github.com/trawor/XToDo</a></p>

<h5>Dash for Xcode</h5>

<p>Dash是一款用于浏览文档的优秀软件，我每天都会反复加以运用。更让人喜出望外的是，它现在已经与Xcode相集成，这要归功于其Xcode插件。大家可能知道，我们可以在Xcode编辑器中按住Option键同时点击以直接前往对应文档。不过我对于Xcode自带来的文档浏览器评价不高，在这种情况下Dash插件就成了最理想的解决方案。</p>

<p><img src="http://s2.51cto.com/wyfs02/M00/46/83/wKiom1PyvYOBTuZFAACLZqMVukQ768.jpg" alt="id2" /></p>

<p>该插件能够在我们按住Option并点击对应文档后利用Dash而非Xcode自带文档浏览器将其打开。Dash不仅运行速度极快，同时还能与CocoaDocs相集成。举例来说，如果大家用这种方式点击AFNetworking库中的一个方法，那么Dash将显示出该方法的说明文档。我超爱这项功能。</p>

<p>官方网站：<a href="http://kapeli.com/dash">http://kapeli.com/dash</a></p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[即时通讯类移动APP开发要点]]></title>
        <link href="http://swplzj.github.io/blog/2015/02/06/ji-shi-tong-xun-lei-yi-dong-appkai-fa-yao-dian/"/>
        <updated>2015-02-06T16:05:06+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/02/06/ji-shi-tong-xun-lei-yi-dong-appkai-fa-yao-dian</id>
        <content type="html"><![CDATA[<p>即时通讯（IM）软件作为满足人们沟通需求的工具，十几年来一直长盛不衰，并随着移动时代的到来迎来了新的增长。如在国内广泛使用的微信，在北美广泛使用的Whatsapp、Kik，在亚洲广泛使用的Line、KakaoTalk。另外还有其他一些以独特视角切入移动IM市场的APP，主打阅后即焚、私密消息等。</p>

<p>试着从技术的角度来总结这一类应用的开发要点，或者说是相比桌面版的IM软件，移动IM应用开发需要注意的地方，欢迎指正和补充。</p>

<!--more-->


<h5>网络</h5>

<h6>移动APP经常随着移动设备在不同的网络之间切换，所以处理好网络切换、断网、重连就至关重要。</h6>

<p>解决这个问题的办法，就是要求移动APP能以尽量少的通讯量、尽快的速度重新注册服务器。</p>

<p>比如不再从服务器获取配置信息、联系人信息和联系人状态等。</p>

<p>但是如果这段时间服务器端有变化发生，就需要服务器有推送变化信息的能力。</p>

<p>同时，服务器对客户端重连间隔要保持宽容态度，不要因为客户端在给定的较短时间内没有重连上就移除这个会话。要知道，在移动环境下，客户端断掉连接只是不得已，一有机会，它就会努力重连上来的。</p>

<p>另外，由于网络的不稳定性，消息的发送方和接受方一定要有确认机制，不管这种确认机制是端对端的的还是通过服务器中转，以避免客户端突然掉线，而服务器还未及时知晓的情况。</p>

<h5>电池</h5>

<h6>移动APP必须尽量减少电池的消耗。</h6>

<p>以iOS为例，它以三个规则来强制APP最小化电池消耗：</p>

<ol>
<li><p>APP在后台是不能主动运行的，特定功能的APP可以设置timer唤醒，但最频繁也只能每10分钟运行若干秒。</p></li>
<li><p>APP在后台被唤醒的次数有严格限制，不能在300秒内被唤醒超过15次，否则被系统终止。</p></li>
<li><p>APP即使申请后台任务，最多也只有60秒的运行时间。</p></li>
</ol>


<p>满足这些要求的最好办法，就是不要试图让移动IM应用在后台运行。而把网络监听这样的任务，在APP进入后台的时候转交给iOS系统来完成。</p>

<p>而服务器则要有灵活的过滤机制，不管是主动还是被动的，过滤掉绝大多数试图发给客户端的网络通讯，以保持客户端睡眠的状态。而仅仅把必要的信息，如即时消息，推送给客户端。</p>

<h5>内存</h5>

<h6>移动APP要尽量减少内存消耗。</h6>

<p>以iOS为例，系统会保持尽可能多的APP在内存中，但是内存不足时它就会终止已被挂起的APP来回收内存。这种情况下，首先被回收的就是占内存多的后台APP。</p>

<p>解决这个问题的一个办法，就是在内存消耗较多的模块，通常是模型层的组件，提供持久化机制。当APP切换到后台的时候保存大多数暂时不会用到的数据到文件系统，等回到前台的时候再重建这些数据结构。</p>

<p>比如所有联系人的详细信息就适合这么做。</p>

<h5>系统资源</h5>

<h6>移动APP要尽量减少对系统资源的占有。</h6>

<p>应该以最少使用时间为原则来使用系统资源，以iOS为例，在APP切换到后台之前就要放弃对地址簿的访问。</p>

<h5>后台运行</h5>

<p>以上几点都跟APP在后台运行有关，其实这也是移动IM应用的一大特点。所谓养兵千日、用兵一时，移动IM应用绝大多数时间都躺在后台，所以处理好后台运行就处理好了移动IM应用的大部分。</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[valueForKeyPath的使用总结]]></title>
        <link href="http://swplzj.github.io/blog/2015/01/16/valueforkeypathde-shi-yong-zong-jie/"/>
        <updated>2015-01-16T21:10:46+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/01/16/valueforkeypathde-shi-yong-zong-jie</id>
        <content type="html"><![CDATA[<p>可能大家对- (id)valueForKeyPath:(NSString *)keyPath方法不是很了解。
其实这个方法非常的强大，具体有以下几个功能:</p>

<h5>对数组中的每个元素执行成员实例方法</h5>

<!--more-->




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSArray *array = @[@"name", @"w", @"aa", @"jimsa"];
</span><span class='line'>NSLog(@"%@", [array valueForKeyPath:@"uppercaseString"]);</span></code></pre></td></tr></table></div></figure>


<p>输出</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(
</span><span class='line'>    NAME,
</span><span class='line'>    W,
</span><span class='line'>    AA,
</span><span class='line'>    JIMSA
</span><span class='line'>)</span></code></pre></td></tr></table></div></figure>


<p>相当于数组中的每个成员执行了uppercaseString方法，然后把返回的对象组成一个新数组返回。既然可以用uppercaseString方法，那么NSString的其他方法也可以，比如</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[array valueForKeyPath:@"length"]</span></code></pre></td></tr></table></div></figure>


<p>返回每个字符串长度的组成的数组。只要你能想到的成员实例方法都可以这么用。</p>

<h5>对NSNumber数组快速计算数组求和、平均数、最大值、最小值</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSArray *array = @[@1, @2, @3, @4, @10];
</span><span class='line'>NSNumber *sum = [array valueForKeyPath:@"@sum.self"];
</span><span class='line'>NSNumber *avg = [array valueForKeyPath:@"@avg.self"];
</span><span class='line'>NSNumber *max = [array valueForKeyPath:@"@max.self"];
</span><span class='line'>NSNumber *min = [array valueForKeyPath:@"@min.self"];</span></code></pre></td></tr></table></div></figure>


<p></p>

<h5>或者指定输出类型</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSNumber *sum = [array valueForKeyPath:@"@sum.floatValue"];
</span><span class='line'>NSNumber *avg = [array valueForKeyPath:@"@avg.floatValue"];
</span><span class='line'>NSNumber *max = [array valueForKeyPath:@"@max.floatValue"];
</span><span class='line'>NSNumber *min = [array valueForKeyPath:@"@min.floatValue"];</span></code></pre></td></tr></table></div></figure>


<h5>剔除重复数据</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSArray *array = @[@"name", @"w", @"aa", @"jimsa", @"aa"];
</span><span class='line'>NSLog(@"%@", [array valueForKeyPath:@"@distinctUnionOfObjects.self"]);</span></code></pre></td></tr></table></div></figure>


<p>打印</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(
</span><span class='line'>name,
</span><span class='line'>w,
</span><span class='line'>jimsa,
</span><span class='line'>aa
</span><span class='line'>)</span></code></pre></td></tr></table></div></figure>


<h5>对NSDictionary数组快速找出相应key对的值</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSArray *array = @[@{@"name" : @"cookeee",@"code" : @1},
</span><span class='line'>                           @{@"name": @"jim",@"code" : @2},
</span><span class='line'>                           @{@"name": @"jim",@"code" : @1},
</span><span class='line'>                           @{@"name": @"jbos",@"code" : @1}];
</span><span class='line'>NSLog(@"%@", [array valueForKeyPath:@"name"]);</span></code></pre></td></tr></table></div></figure>


<p>直接得到字典中namekey对应的值组成的数组，显然比循环取值再加入到新数组中方便快捷</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(
</span><span class='line'>    cookeee,
</span><span class='line'>    jim,
</span><span class='line'>    jim,
</span><span class='line'>    jbos
</span><span class='line'>)</span></code></pre></td></tr></table></div></figure>


<p>同样可以嵌套使用，先剔除name对应值的重复数据再取值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> NSArray *array = @[@{@"name" : @"cookeee",@"code" : @1},
</span><span class='line'>                           @{@"name": @"jim",@"code" : @2},
</span><span class='line'>                           @{@"name": @"jim",@"code" : @1},
</span><span class='line'>                           @{@"name": @"jbos",@"code" : @1}];
</span><span class='line'>
</span><span class='line'>NSLog(@"%@", [array valueForKeyPath:@"@distinctUnionOfObjects.name"]);</span></code></pre></td></tr></table></div></figure>


<p>打印</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(
</span><span class='line'>cookeee,
</span><span class='line'>jim,
</span><span class='line'>jbos
</span><span class='line'>)</span></code></pre></td></tr></table></div></figure>


<h5>改变UITextfiedl的placeholder的颜色</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[searchField setValue:[UIColor whiteColor] forKeyPath:@"_placeholderLabel.textColor"];</span></code></pre></td></tr></table></div></figure>


<p>比起重写</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)drawPlaceholderInRect:(CGRect)rect;</span></code></pre></td></tr></table></div></figure>


<p>要方便很多</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Objective-C中的Selector和SEL]]></title>
        <link href="http://swplzj.github.io/blog/2015/01/07/objective-czhong-de-selectorhe-sel/"/>
        <updated>2015-01-07T10:32:05+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/01/07/objective-czhong-de-selectorhe-sel</id>
        <content type="html"><![CDATA[<h4>Objective-C中Selector基本概念和操作</h4>

<p>简而言之，你可以理解 @selector()就是取类方法的编号,他的行为基本可以等同C语言的中函数指针,只不过C语言中，可以把函数名直接赋给一个函数指针，而Objective-C的类不能直接应用函数指针，这样只能做一个@selector语法来取.</p>

<!--more-->


<p></p>

<p>它的结果是一个SEL类型。这个类型本质是类方法的编号(函数地址)?因此我们有如下代码。</p>

<h5>一、取得selector值.</h5>

<p>C函数指针</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int add(int val)  
</span><span class='line'>{  
</span><span class='line'>  return val+1;  
</span><span class='line'>}  
</span><span class='line'>int (* c_func)(int val); //定义一个函数指针变量  
</span><span class='line'>_func = add ;  //把函数addr地址直接赋给c_func </span></code></pre></td></tr></table></div></figure>


<p>Objective-C的选择器,</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface foo  
</span><span class='line'>-(int)add:int val;  
</span><span class='line'>@end  
</span><span class='line'> 
</span><span class='line'>SEL class_func ; //定义一个类方法指针  
</span><span class='line'>class_func = @selector(add:int); </span></code></pre></td></tr></table></div></figure>


<p><code>注意:</code></p>

<ol>
<li>@selector是查找当前类的方法，而[object @selector(方法名:方法参数..) ] ;是取object对应类的相庆方法;</li>
<li>查找类方法时，除了方法名,方法参数也查询条件之一.</li>
<li>可以用字符串来找方法 SEL　变量名　=　NSSelectorFromString(方法名字的字符串);</li>
<li>可以运行中用SEL变量反向查出方法名字字符串</li>
</ol>


<p>NSString　*变量名　=　NSStringFromSelector(SEL参数);</p>

<h5>二、执行selector值.</h5>

<p>取得相庆值后，怎么处理SEL值呢，这一点仍然与函数指针一样，就是执行它</p>

<p>函数指针执行，（以下有几种等效形式）</p>

<ul>
<li>*c_func(10);</li>
<li>c_func(10);</li>
<li>SEL变量的执行.用performSelecor方法来执行.</li>
<li>[对象　performSelector:SEL变量　withObject:参数1　withObject:参数2];</li>
</ul>


<h5>三.selector的应用场合</h5>

<p>selector本质是跟C的回调函数一样。主要用于两个对象之间进行松耦合的通讯.这种方法很多开发环境用到。比如GTK，Delphi.基本上整个Cocoa库之间对象，控制之间通讯都是在这个基础构建的。</p>

<h4>SEL</h4>

<p>在Objective-C中，SEL是选择器（selector）的一个类型。选择器就是指向方法的一个指针，读者可以简单理解为程序运行到这里就会执行指定的方法，可以这样定义一个选择器：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SEL action = [button action]; </span></code></pre></td></tr></table></div></figure>


<p>我们这样使用一个选择器，下面的选择器都叫做action：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[Foo action]  
</span><span class='line'>[Bar action] </span></code></pre></td></tr></table></div></figure>


<p>在Target-Action 模式（Cocoa 程序中的一种常用模式）中：Target 指定了一个类，Action指定一个方法。在一个对象上设置Action就是通过选择器完成的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-（void）setTarget:（id）target;  
</span><span class='line'>-（void）setAction:（SEL）action; </span></code></pre></td></tr></table></div></figure>


<p>下述语句设置了一个button对象上的Action为“@selector（start:）”，即它调用start方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[button setAction:@selector（start:）]; </span></code></pre></td></tr></table></div></figure>


<p>如果你的方法上有两个参数，比如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-（void）setName:（NSString *）name age:（int）age; </span></code></pre></td></tr></table></div></figure>


<p>那么，你的选择器应该这样书写：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SEL sel = @selector（setName:age:）; </span></code></pre></td></tr></table></div></figure>


<p>如果方法不存在的话，调用该方法的应用可能会异常中止。所以，需要使用respondsToSelector 方法来判断该对象是否存在对应的方法，使用performSelector:withObject:方法来调用选择器：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SEL sel = @selector (start:) ; // 指定action  
</span><span class='line'>if ([obj respondsToSelector:sel]) { //判断该对象是否有相应的方法  
</span><span class='line'>[obj performSelector:sel withObject:self]; //调用选择器方法  
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>下面来看一个应用选择器的实例。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import &lt;Foundation/Foundation.h&gt; 
</span><span class='line'>@interface ClassA : NSObject {  
</span><span class='line'>}  
</span><span class='line'>- (void) print;  
</span><span class='line'>@end  
</span><span class='line'>@implementation ClassA  
</span><span class='line'>- (void) print{  
</span><span class='line'>NSLog (@"I'm ClassA.") ;  
</span><span class='line'>}  
</span><span class='line'>@end  
</span><span class='line'>int main (int argc, const char * argv[]) {  
</span><span class='line'>NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];  
</span><span class='line'>SEL sel = @selector (print) ;  
</span><span class='line'>ClassA *classA = [[ClassA alloc]init];  
</span><span class='line'>[classA performSelector:sel withObject:nil]; //调用选择器指定的方法  
</span><span class='line'>[pool drain];  
</span><span class='line'>return 0;  
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>【程序结果】</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>I'm ClassA. </span></code></pre></td></tr></table></div></figure>


<p>下面解释一下这段代码，读者有可能看不明白，因为到目前为止并没有讲述类相关的知识。读者只需要了解上述例子中选择器的用法即可，关于类的知识，会在后面的章节详细阐述。</p>

<p>代码首先创建了一个名字叫ClassA 的类，它只包含一个方法print。在随后的实现文件中，我们实现了这个方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void) print{  
</span><span class='line'>NSLog (@"I'm ClassA.") ;  
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>读者不难看出，这个方法仅仅是打印到控制台上一句话。在接下来的main方法中，定义了一个选择器sel，它指向的是一个名叫print 的方法。我们并不知道这个方法是哪个类的，因为具体的信息是在运行期间系统自动帮我们判断的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SEL sel = @selector (print) ; </span></code></pre></td></tr></table></div></figure>


<p>随后构建了一个对象（读者不用拘泥于语法，我们会在后面的章节详细阐述），并调用这个对象performSelector:withObject:的方法。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ClassA *classA = [[ClassA alloc]init];  
</span><span class='line'>[classA performSelector:sel withObject:nil]; </span></code></pre></td></tr></table></div></figure>


<p>这时候，系统就会自动调用classA对象的print方法，最终得到程序运行结果。</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[使用神奇的PONYDEBUGGER调试iOS应用]]></title>
        <link href="http://swplzj.github.io/blog/2014/12/14/shi-yong-shen-qi-de-ponydebugger-tiao-shi-ios-ying-yong/"/>
        <updated>2014-12-14T17:30:40+08:00</updated>
        <id>http://swplzj.github.io/blog/2014/12/14/shi-yong-shen-qi-de-ponydebugger-tiao-shi-ios-ying-yong</id>
        <content type="html"><![CDATA[<h3>前言</h3>

<p>Debug算是开发者的基本技能之一吧，对于iOS开发者而言，可能会遇到如下一些debug需求：</p>

<p>调试网络请求问题
调试一个层次结构复杂的用户界面
查看应用内Core Data数据变化
虽然你可以通过NSLog日志，打断点，抑或LLDB的调试命令等一些常见手段来解决以上问题，但这些方式始终不够直观，效率也不高，特别是对于调试UI这个需求。要提高效率，我们可以使用一些第三方的调试工具，比如本文要介绍的PonyDebugger。</p>

<!--more-->


<h3>关于PonyDebugger</h3>

<p>PonyDebugger是Square开源的一个远程调试工具包，它可以通过Chrome开发者工具来调试iOS应用的网络流量，数据存储以及用户界面。</p>

<h3>安装和使用</h3>

<h4>服务端安装</h4>

<p>curl -sk <a href="https://cloud.github.com/downloads/square/PonyDebugger/bootstrap-ponyd.py">https://cloud.github.com/downloads/square/PonyDebugger/bootstrap-ponyd.py</a> | \ python - &ndash;ponyd-symlink=/usr/local/bin/ponyd ~/Library/PonyDebugger</p>

<p>安装时遇到的一些坑记录如下：</p>

<p>移动宽带下偶尔出现连接不上pypi的情况，使用电信宽带则正常，移动宽带用户可以改用国内的镜像地址，比如V2EX的pypi镜像<a href="http://pypi.v2ex.com/simple">http://pypi.v2ex.com/simple</a>
服务端依赖pybonjour，但是在zsh终端下使用pip安装会提示找不到这个包，需要手动安装，添加allow-external和allow-unverified
手动安装方法如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>source ~/Library/PonyDebugger/bin/activate
</span><span class='line'>
</span><span class='line'>pip install -U -e git+https://github.com/square/PonyDebugger.git#egg=ponydebugger --allow-external pybonjour --allow-unverified pybonjour
</span><span class='line'>
</span><span class='line'>ponyd update-devtools</span></code></pre></td></tr></table></div></figure>


<h4>客户端安装</h4>

<p>使用CocoaPods，在PodFile中添加以下依赖：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod 'PonyDebugger', '~&gt; 0.3.1'</span></code></pre></td></tr></table></div></figure>


<p>也可以直接指向Github开源地址，这样可以随时使用最新版本的代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod 'PonyDebugger', :git =&gt; 'https://github.com/square/PonyDebugger.git'</span></code></pre></td></tr></table></div></figure>


<h4>使用</h4>

<p>终端输入以下命令启动服务端，然后Chrome打开<a href="http://localhost:9000">http://localhost:9000</a> ，使用开发者工具即可进行调试</p>

<p>ponyd serve &ndash;listen-interface=127.0.0.1</p>

<p>为了便于随时开启和关闭PonyDebugger，客户端在Preprocessor Macros中定义了一个宏ENABLE_PONYDEBUGGER</p>

<p>在AppDeleagate的didFinishLaunchingWithOptions方法中使用如下代码进行一些初始化工作：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#if ENABLE_PONYDEBUGGER
</span><span class='line'>
</span><span class='line'>    PDDebugger *debugger = [PDDebugger defaultInstance];
</span><span class='line'>    
</span><span class='line'>    // Enable Network debugging, and automatically track network traffic that comes through any classes that NSURLConnectionDelegate methods.
</span><span class='line'>    [debugger enableNetworkTrafficDebugging];
</span><span class='line'>    [debugger forwardAllNetworkTraffic];
</span><span class='line'>    
</span><span class='line'>    // Enable Core Data debugging, and broadcast the main managed object context.
</span><span class='line'>    [debugger enableCoreDataDebugging];
</span><span class='line'>    [debugger addManagedObjectContext:self.managedObjectContext withName:@"Twitter Test MOC"];
</span><span class='line'>    
</span><span class='line'>    // Enable View Hierarchy debugging. This will swizzle UIView methods to monitor changes in the hierarchy
</span><span class='line'>    // Choose a few UIView key paths to display as attributes of the dom nodes
</span><span class='line'>    [debugger enableViewHierarchyDebugging];
</span><span class='line'>    [debugger setDisplayedViewAttributeKeyPaths:@[@"frame", @"hidden", @"alpha", @"opaque", @"accessibilityLabel", @"text"]];
</span><span class='line'>    
</span><span class='line'>    // Connect to a specific host
</span><span class='line'>    [debugger connectToURL:[NSURL URLWithString:@"ws://localhost:9000/device"]];
</span><span class='line'>    // Or auto connect via bonjour discovery
</span><span class='line'>    //[debugger autoConnect];
</span><span class='line'>    // Or to a specific ponyd bonjour service
</span><span class='line'>    //[debugger autoConnectToBonjourServiceNamed:@"MY PONY"];
</span><span class='line'>
</span><span class='line'>    // Enable remote logging to the DevTools Console via PDLog()/PDLogObjects().
</span><span class='line'>    [debugger enableRemoteLogging];
</span><span class='line'>    
</span><span class='line'>#endif</span></code></pre></td></tr></table></div></figure>


<p>Chrome看到网页显示如下说明连接成功：</p>

<p><img src="http://ww4.sinaimg.cn/large/674a21d2gw1eemkgp4t9rj216c0ea40f.jpg" alt="id1" /></p>

<p>点击网页中间的应用名即可跳转到debug工具</p>

<h4>实现原理</h4>

<p>简单看了一下PonyDebugger的源码，服务端使用Tornado框架提供WebSocket服务，客户端则是基于Square自家开源的SocketRocket，关于WebSocket相关的知识，可以参考我之前的这篇博文。</p>

<p>网络请求抓包功能是通过注入到NSURLConnectionDelegate中实现的，代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (void)injectIntoAllNSURLConnectionDelegateClasses;
</span><span class='line'>{
</span><span class='line'>    // Only allow swizzling once.
</span><span class='line'>    static BOOL swizzled = NO;
</span><span class='line'>    if (swizzled) {
</span><span class='line'>        return;
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    swizzled = YES;
</span><span class='line'>
</span><span class='line'>    // Swizzle any classes that implement one of these selectors.
</span><span class='line'>    const SEL selectors[] = {
</span><span class='line'>        @selector(connectionDidFinishLoading:),
</span><span class='line'>        @selector(connection:didReceiveResponse:)
</span><span class='line'>    };
</span><span class='line'>    
</span><span class='line'>    const int numSelectors = sizeof(selectors) / sizeof(SEL);
</span><span class='line'>
</span><span class='line'>    Class *classes = NULL;
</span><span class='line'>    NSInteger numClasses = objc_getClassList(NULL, 0);
</span><span class='line'>    
</span><span class='line'>    if (numClasses &gt; 0) {
</span><span class='line'>        classes = (__unsafe_unretained Class *)malloc(sizeof(Class) * numClasses);
</span><span class='line'>        numClasses = objc_getClassList(classes, numClasses);
</span><span class='line'>        for (NSInteger classIndex = 0; classIndex &lt; numClasses; ++classIndex) {
</span><span class='line'>            Class class = classes[classIndex];
</span><span class='line'>            
</span><span class='line'>            if (class_getClassMethod(class, @selector(isSubclassOfClass:)) == NULL) {
</span><span class='line'>                continue;
</span><span class='line'>            }
</span><span class='line'>            
</span><span class='line'>            if (![class isSubclassOfClass:[NSObject class]]) {
</span><span class='line'>                continue;
</span><span class='line'>            }
</span><span class='line'>            
</span><span class='line'>            if ([class isSubclassOfClass:[PDNetworkDomainController class]]) {
</span><span class='line'>                continue;
</span><span class='line'>            }
</span><span class='line'>            
</span><span class='line'>            for (int selectorIndex = 0; selectorIndex &lt; numSelectors; ++selectorIndex) {
</span><span class='line'>                if ([class instancesRespondToSelector:selectors[selectorIndex]]) {
</span><span class='line'>                    [self injectIntoDelegateClass:class];
</span><span class='line'>                    break;
</span><span class='line'>                }
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>        
</span><span class='line'>        free(classes);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>从这个实现也可以发现，像ASIHttpRequest这样的直接基于底层CFNetwork封装的库，以及iOS 7中新引入的NSURLSession都是无法抓到请求包的，这种情况下如果需要抓包就只能使用Charles这类工具了。</p>

<p>调试视图功能调用了一些runtime的私有API，部分代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (void)startMonitoringUIViewChanges;
</span><span class='line'>{
</span><span class='line'>    // Swizzle UIView add/remove methods to monitor changes in the view hierarchy
</span><span class='line'>    // Only do it once to avoid swapping back if this method is called again
</span><span class='line'>    static dispatch_once_t onceToken;
</span><span class='line'>    dispatch_once(&onceToken, ^{
</span><span class='line'>        Method original, swizzle;
</span><span class='line'>        Class viewClass = [UIView class];
</span><span class='line'>
</span><span class='line'>        // Using sel_registerName() because compiler complains about the swizzled selectors not being found.
</span><span class='line'>        original = class_getInstanceMethod(viewClass, @selector(addSubview:));
</span><span class='line'>        swizzle = class_getInstanceMethod(viewClass, sel_registerName("pd_swizzled_addSubview:"));
</span><span class='line'>        method_exchangeImplementations(original, swizzle);
</span><span class='line'>        
</span><span class='line'>        ···
</span><span class='line'>                  
</span><span class='line'>        original = class_getInstanceMethod(viewClass, @selector(exchangeSubviewAtIndex:withSubviewAtIndex:));
</span><span class='line'>        swizzle = class_getInstanceMethod(viewClass, sel_registerName("pd_swizzled_exchangeSubviewAtIndex:withSubviewAtIndex:"));
</span><span class='line'>        method_exchangeImplementations(original, swizzle);
</span><span class='line'>    });
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这部分可以看到是通过Method Swizzling来动态交换了UIView的方法实现，以addSubview为例，替换成了pd_swizzled_addSubview，至于pd_swizzled_addSubview的实现请看下面</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)pd_swizzled_addSubview:(UIView *)subview;
</span><span class='line'>{
</span><span class='line'>    [[PDDOMDomainController defaultInstance] removeView:subview];
</span><span class='line'>    [self pd_swizzled_addSubview:subview];
</span><span class='line'>    [[PDDOMDomainController defaultInstance] addView:subview];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>替换后的removeView和addView方法都是重新实现的，里面会将UIView的变动以DOM形式写到PDDOMDomain对象中输出。</p>

<p>除了以上两个主要功能，还有Core Data远程调试，日志远程输出等功能，其实现方式大同小异，就不一一赘述了。</p>

<p>总的来说，PonyDebugger的功能还是十分强大的，也能够有效地提高开发者的调试效率，有类似需求的很值得一试。</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[使用VIPER构建iOS应用]]></title>
        <link href="http://swplzj.github.io/blog/2014/12/07/shi-yong-viper-chuang-jian-kuang-jia/"/>
        <updated>2014-12-07T22:03:17+08:00</updated>
        <id>http://swplzj.github.io/blog/2014/12/07/shi-yong-viper-chuang-jian-kuang-jia</id>
        <content type="html"><![CDATA[<p>建筑领域流行这样一句话，“我们虽然在营造建筑，但建筑也会重新塑造我们”。正如所有开发者最终领悟到的，这句话同样适用于构建软件。</p>

<p>编写代码中至关重要的是，需要使每一部分容易被识别，赋有一个特定而明显的目的，并与其他部分在逻辑关系中完美契合。这就是我们所说的软件架构。好的架构不仅让一个产品成功投入使用，还可以让产品具有可维护性，并让人不断头脑清醒的对它进行维护！</p>

<!--more-->


<p>在这篇文章中，我们介绍了一种称之为 <a href="http://mutualmobile.github.io/blog/2013/12/04/viper-introduction/">VIPER</a> 的 iOS 应用架构的方式。VIPER 已经在很多大型的项目上成功实践，但是出于本文的目的我们将通过一个待办事项清单 (to-do app) 来介绍 VIPER 。你可以在 <a href="https://github.com/objcio/issue-13-viper">GitHub</a> 上关注这个项目。</p>

<h5>什么是 VIPER？</h5>

<p>测试永远不是构建 iOS 应用的主要部分。当我们 <a href="https://github.com/mutualmobile/">Mutual Mobile</a> 着手改善我们的测试实践时，我们发现给 iOS 应用写测试代码非常困难。因此如果想要设法改变测试的现状，我们首先需要一个更好的方式来架构应用，我们称之为 VIPER。</p>

<p>VIPER 是一个创建 iOS 应用<a href="http://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html">简明构架</a>的程序。VIPER 可以是视图 (View)，交互器 (Interactor)，展示器 (Presenter)，实体 (Entity) 以及路由 (Routing) 的首字母缩写。简明架构将一个应用程序的逻辑结构划分为不同的责任层。这使得它更容易隔离依赖项 (如数据库)，也更容易测试各层间的边界处的交互：
<img src="http://www.cocoachina.com/cms/uploads/allimg/140703/8370_140703100012_1.jpg" alt="id1" /></p>

<p>大部分 iOS 应用利用 MVC 构建，使用 MVC 应用程序架构可以引导你将每一个类看做模型，视图或控制器中的一个。但由于大部分应用程序的逻辑不会存在于模型或视图中，所以通常最终总是在控制器里实现。这就导致一个称为<a href="https://twitter.com/Colin_Campbell/status/293167951132098560">重量级视图控制器</a>的问题，在这里，视图控制器做了太多工作。为这些重量级视图控制器<a href="http://www.objc.io/issue-1/lighter-view-controllers.html">瘦身</a>并不是 iOS 开发者寻求提高代码的质量所要面临的唯一挑战，但至少这是一个很好的开端。</p>

<p>VIPER 的不同层提供了明确的程序逻辑以及导航控制代码来应对这个挑战，利用 VIPER ，你会注意到在我们的待办事项示例清单中的视图控制器可以简洁高效，意义明确地控制视图。你也会发现视图控制器中代码和所有的其他类很容易理解，容易测试，理所当然也更易维护。</p>

<h5>基于用例的应用设计</h5>

<p>应用通常是一些用户用例的集合。用例也被称为验收标准，或行为集，它们用来描述应用的用途。清单可以根据时间，类型以及名字排序，这就是一个用例。用例是应用程序中用来负责业务逻辑的一层，应独立于用户界面的实现，同时要足够小，并且有良好的定义。决定如何将一个复杂的应用分解成较小的用例非常具有挑战性，并且需要长期实践，但这对于缩小你解决的问题时所要面临的范围及完成的每个类的所要涉及的内容来说，是很有帮助的。</p>

<p>利用 VIPER 建立一个应用需要实施一组套件来满足所有的用例，应用逻辑是实现用例的主要组成部分，但却不是唯一。用例也会影响用户界面。另一个重要的方面，是要考虑用例如何与其他应用程序的核心组件相互配合，例如网络和数据持久化。组件就好比用例的插件，VIPER 则用来描述这些组件的作用是什么，如何进行交互。</p>

<p>我们其中一个用例，或者说待办事项清单中其中的一个需求是可以基于用户的选择来将待办事项分组。通过分离的逻辑将数据组织成一个用例，我们能够在测试时使用户界面代码保持干净，用例更易组装，从而确保它如我们预期的方式工作。</p>

<h5>VIPER 的主要部分</h5>

<p>VIPER 的主要部分是：</p>

<p>视图：根据展示器的要求显示界面，并将用户输入反馈给展示器。
交互器：包含由用例指定的业务逻辑。
展示器：包含为显示（从交互器接受的内容）做的准备工作的相关视图逻辑，并对用户输入进行反馈（从交互器获取新数据）。
实体：包含交互器要使用的基本模型对象。
路由：包含用来描述屏幕显示和显示顺序的导航逻辑。</p>

<p>这种分隔形式同样遵循<a href="http://www.objectmentor.com/resources/articles/srp.pdf">单一责任原则</a>。交互器负责业务分析的部分，展示器代表交互设计师，而视图相当于视觉设计师。</p>

<p>以下则是不同组件的相关图解，并展示了他们之间是如何关联的：</p>

<p><img src="http://www.cocoachina.com/cms/uploads/allimg/140703/8370_140703100110_1.png" alt="id2" /></p>

<p>虽然在应用中 VIPER 的组件可以以任意顺序实现，我们在这里选择按照我们推荐的顺序来进行介绍。你会注意到这个顺序与构建整个应用的进程大致符合 &ndash; 首先要讨论的是产品需要做什么，以及用户会如何与之交互。</p>

<h5>交互器</h5>

<p>交互器在应用中代表着一个独立的用例。它具有业务逻辑以操纵模型对象（实体）执行特定的任务。交互器中的工作应当独立与任何用户界面，同样的交互器可以同时运用于 iOS 应用或者 OS X 应用中。</p>

<p>由于交互器是一个 PONSO (Plain Old NSObject，普通的 NSObject)，它主要包含了逻辑，因此很容易使用 TDD 进行开发。</p>

<p>示例应用的主要用例是向用户展示所有的待办事项（比如任何截止于下周末的任务）。此类用例的业务逻辑主要是找出今天至下周末之间将要到期的待办事项，然后为它们分配一个相对的截止日期，比如今天，明天，本周以内，或者下周。</p>

<p>以下是来自 VTDListInteractor 的对应方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)findUpcomingItems 
</span><span class='line'>{ 
</span><span class='line'>    __weak typeof(self) welf = self; 
</span><span class='line'>    NSDate* today = [self.clock today]; 
</span><span class='line'>    NSDate* endOfNextWeek = [[NSCalendar currentCalendar] dateForEndOfFollowingWeekWithDate:today]; 
</span><span class='line'>    [self.dataManager todoItemsBetweenStartDate:today endDate:endOfNextWeek completionBlock:^(NSArray* todoItems) { 
</span><span class='line'>        [welf.output foundUpcomingItems:[welf upcomingItemsFromToDoItems:todoItems]]; 
</span><span class='line'>    }]; 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<h5>实体</h5>

<p>实体是被交互器操作的模型对象，并且它们只被交互器所操作。交互器永远不会传输实体至表现层 (比如说展示器)。</p>

<p>实体也应该是 PONSOs。如果你使用 Core Data，最好是将托管对象保持在你的数据层之后，交互器不应与 NSManageObjects 协同工作。</p>

<p>这里是我们的待办事项服务的实体：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface VTDTodoItem : NSObject 
</span><span class='line'> 
</span><span class='line'>@property (nonatomic, strong)   NSDate*     dueDate; 
</span><span class='line'>@property (nonatomic, copy)     NSString*   name; 
</span><span class='line'> 
</span><span class='line'>+ (instancetype)todoItemWithDueDate:(NSDate*)dueDate name:(NSString*)name; 
</span><span class='line'> 
</span><span class='line'>@end 
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>不要诧异于你的实体仅仅是数据结构，任何依赖于应用的逻辑都应该放到交互器中。</p>

<h5>展示器</h5>

<p>展示器是一个主要包含了驱动用户界面的逻辑的 PONSO，它总是知道何时呈现用户界面。基于其收集来自用户交互的输入功能，它可以在合适的时候更新用户界面并向交互器发送请求。</p>

<p>当用户点击 “+” 键新建待办事项时，addNewEntry 被调用。对于此项操作，展示器会要求 wireframe 显示用户界面以增加新项目：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)addNewEntry 
</span><span class='line'>{ 
</span><span class='line'>    [self.listWireframe presentAddInterface]; 
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>展示器还会从交互器接收结果并将结果转换成能够在视图中有效显示的形式。</p>

<p>下面是如何从交互器接受待办事项的过程，其中包含了处理数据的过程并决定展现给用户哪些内容：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)foundUpcomingItems:(NSArray*)upcomingItems 
</span><span class='line'>{ 
</span><span class='line'>    if ([upcomingItems count] == 0) 
</span><span class='line'>    { 
</span><span class='line'>        [self.userInterface showNoContentMessage]; 
</span><span class='line'>    } 
</span><span class='line'>    else 
</span><span class='line'>    { 
</span><span class='line'>        [self updateUserInterfaceWithUpcomingItems:upcomingItems]; 
</span><span class='line'>    } 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>实体永远不会由交互器传输给展示器，取而代之，那些无行为的简单数据结构会从交互器传输到展示器那里。这就防止了那些“真正的工作”在展示器那里进行，展示器只能负责准备那些在视图里显示的数据。</p>

<h5>视图</h5>

<p>视图一般是被动的，它通常等待展示器下发需要显示的内容，而不会向其索取数据。视图（例如登录界面的登录视图控件）所定义的方法应该允许展示器在高度抽象的层次与之交流。展示器通过内容进行表达，而不关心那些内容所显示的样子。展示器不知道 UILabel，UIButton 等的存在，它只知道其中包含的内容以及何时需要显示。内容如何被显示是由视图来进行控制的。</p>

<p>视图是一个抽象的接口 (Interface)，在 Objective-C 中使用协议被定义。一个 UIViewController 或者它的一个子类会实现视图协议。比如我们的示例中 “添加” 界面会有以下接口：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@protocol VTDAddViewInterface  
</span><span class='line'> 
</span><span class='line'>- (void)setEntryName:(NSString *)name; 
</span><span class='line'>- (void)setEntryDueDate:(NSDate *)date; 
</span><span class='line'> 
</span><span class='line'>@end </span></code></pre></td></tr></table></div></figure>


<p>视图和视图控制器同样会操纵用户界面和相关输入。因为通常来说视图控制器是最容易处理这些输入和执行某些操作的地方，所以也就不难理解为什么视图控制器总是这么大了。为了使视图控制器保持苗条，我们需要使它们在用户进行相关操作的时候可以有途径来通知相关部分。视图控制器不应当根据这些行为进行相关决定，但是它应当将发生的事件传递到能够做决定的部分。</p>

<p>在我们的例子中，Add View Controller 有一个事件处理的属性，它实现了如下接口：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@protocol VTDAddModuleInterface  
</span><span class='line'> 
</span><span class='line'>- (void)cancelAddAction; 
</span><span class='line'>- (void)saveAddActionWithName:(NSString *)name dueDate:(NSDate *)dueDate 
</span><span class='line'> 
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>当用户点击取消键的时候，视图控制器告知这个事件处理程序用户需要其取消这次添加的动作。这样一来，事件处理程序便可以处理关闭 add view controller 并告知列表视图进行更新。</p>

<p>视图和展示器之间边界处是一个使用 <a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a> 的好地方。在这个示例中，视图控制器可以返回一个代表按钮操作的信号。这将允许展示器在不打破职责分离的前提下轻松地对那些信号进行响应。</p>

<h5>路由</h5>

<p>屏幕间的路径会在交互设计师创建的线框 (wireframes) 里进行定义。在 VIPER 中，路由是由两个部分来负责的：展示器和线框。一个线框对象包括 UIWindow，UINavigationController，UIViewController 等部分，它负责创建视图/视图控制器并将其装配到窗口中。</p>

<p>由于展示器包含了响应用户输入的逻辑，因此它就拥有知晓何时导航至另一个屏幕以及具体是哪一个屏幕的能力。而同时，线框知道如何进行导航。在两者结合起来的情况下，展示器可以使用线框来进行实现导航功能，它们两者一起描述了从一个屏幕至另一个屏幕的路由过程。</p>

<p>线框同时也明显是一个处理导航转场动画的地方。来看看这个 add wireframe 中的例子吧：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@implementation VTDAddWireframe 
</span><span class='line'> 
</span><span class='line'>- (void)presentAddInterfaceFromViewController:(UIViewController *)viewController  
</span><span class='line'>{ 
</span><span class='line'>    VTDAddViewController *addViewController = [self addViewController]; 
</span><span class='line'>    addViewController.eventHandler = self.addPresenter; 
</span><span class='line'>    addViewController.modalPresentationStyle = UIModalPresentationCustom; 
</span><span class='line'>    addViewController.transitioningDelegate = self; 
</span><span class='line'> 
</span><span class='line'>    [viewController presentViewController:addViewController animated:YES completion:nil]; 
</span><span class='line'> 
</span><span class='line'>    self.presentedViewController = viewController; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>#pragma mark - UIViewControllerTransitioningDelegate Methods 
</span><span class='line'> 
</span><span class='line'>- (id)animationControllerForDismissedController:(UIViewController *)dismissed  
</span><span class='line'>{ 
</span><span class='line'>    return [[VTDAddDismissalTransition alloc] init]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (id)animationControllerForPresentedController:(UIViewController *)presented 
</span><span class='line'>                                                                  presentingController:(UIViewController *)presenting 
</span><span class='line'>                                                                      sourceController:(UIViewController *)source  
</span><span class='line'>{ 
</span><span class='line'>    return [[VTDAddPresentationTransition alloc] init]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>@end 
</span></code></pre></td></tr></table></div></figure>


<p>应用使用了自定义的视图控制器转场来呈现 add view controller。因为线框部件负责实施这个转场，所以它成为了 add view controller 转场的委托，并且返回适当的转场动画。</p>

<h5>利用 VIPER 组织应用组件</h5>

<p>iOS 应用的构架需要考虑到 UIKit 和 Cocoa Touch 是建立应用的主要工具。架构需要和应用的所有组件都能够和平相处，但又需要为如何使用框架的某些部分以及它们应该在什么位置提供一些指导和建议。</p>

<p>iOS 应用程序的主力是 UIViewController，我们不难想象找一个竞争者来取代 MVC 就可以避免大量使用视图控制器。但是视图控制器现在是这个平台的核心：它们处理设备方向的变化，回应用户的输入，和类似导航控制器之类的系统系统组件集成得很好，而现在在 iOS 7 中又能实现自定义屏幕之间的转换，功能实在是太强大了。</p>

<p>有了 VIPER，视图控制器便就能真正的做它本来应该做的事情了，那就是控制视图。 我们的待办事项应拥有两个视图控制器，一个是列表视图，另一个是新建待办。因为 add view controller 要做的所有事情就是控制视图，所以实现起来非常的简单基础：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@implementation VTDAddViewController 
</span><span class='line'> 
</span><span class='line'>- (void)viewDidAppear:(BOOL)animated  
</span><span class='line'>{ 
</span><span class='line'>    [super viewDidAppear:animated]; 
</span><span class='line'> 
</span><span class='line'>    UITapGestureRecognizer *gestureRecognizer = [[UITapGestureRecognizer alloc] initWithTarget:self 
</span><span class='line'>                                                                                        action:@selector(dismiss)]; 
</span><span class='line'>    [self.transitioningBackgroundView addGestureRecognizer:gestureRecognizer]; 
</span><span class='line'>    self.transitioningBackgroundView.userInteractionEnabled = YES; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (void)dismiss  
</span><span class='line'>{ 
</span><span class='line'>    [self.eventHandler cancelAddAction]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (void)setEntryName:(NSString *)name  
</span><span class='line'>{ 
</span><span class='line'>    self.nameTextField.text = name; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (void)setEntryDueDate:(NSDate *)date  
</span><span class='line'>{ 
</span><span class='line'>    [self.datePicker setDate:date]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (IBAction)save:(id)sender  
</span><span class='line'>{ 
</span><span class='line'>    [self.eventHandler saveAddActionWithName:self.nameTextField.text 
</span><span class='line'>                                     dueDate:self.datePicker.date]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (IBAction)cancel:(id)sender  
</span><span class='line'>{ 
</span><span class='line'>    [self.eventHandler cancelAddAction]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'> 
</span><span class='line'>#pragma mark - UITextFieldDelegate Methods 
</span><span class='line'> 
</span><span class='line'>- (BOOL)textFieldShouldReturn:(UITextField *)textField  
</span><span class='line'>{ 
</span><span class='line'>    [textField resignFirstResponder]; 
</span><span class='line'> 
</span><span class='line'>    return YES; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>@end </span></code></pre></td></tr></table></div></figure>


<p>应用在接入网络以后会变得更有用处，但是究竟该在什么时候联网呢？又由谁来负责启动网络连接呢？典型的情况下，由交互器来启动网络连接操作的项目，但是它不会直接处理网络代码。它会寻找一个像是 network manager 或者 API client 这样的依赖项。交互器可能聚合来自多个源的数据来提供所需的信息，从而完成一个用例。最终，就由展示器来采集交互器反馈的数据，然后组织并进行展示。</p>

<p>数据存储模块负责提供实体给交互器。因为交互器要完成业务逻辑，因此它需要从数据存储中获取实体并操纵它们，然后将更新后的实体再放回数据存储中。数据存储管理实体的持久化，而实体应该对数据库全然不知，正因如此，实体并不知道如何对自己进行持久化。</p>

<p>交互器同样不需要知道如何将实体持久化，有时交互器更希望使用一个 data manager 来使其与数据存储的交互变得容易。Data manager 可以处理更多的针对存储的操作，比如创建获取请求，构建查询等等。这就使交互器能够将更多的注意力放在应用逻辑上，而不必再了解实体是如何被聚集或持久化的。下面我们举一个例子来说明使用 data manager 有意义的，这个例子假设你在使用 Core Data。这是示例应用程序的 data manager 的接口：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface VTDListDataManager : NSObject 
</span><span class='line'> 
</span><span class='line'>@property (nonatomic, strong) VTDCoreDataStore *dataStore; 
</span><span class='line'> 
</span><span class='line'>- (void)todoItemsBetweenStartDate:(NSDate *)startDate endDate:(NSDate *)endDate completionBlock:(void (^)(NSArray *todoItems))completionBlock; 
</span><span class='line'> 
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>当使用 TDD 来开发一个交互器时，是可以用一个测试用的模拟存储来代替生产环境的数据存储的。避免与远程服务器通讯（网络服务）以及避免读取磁盘（数据库）可以加快你测试的速度并加强其可重复性。</p>

<p>将数据存储保持为一个界限清晰的特定层的原因之一是，这可以让你延迟选择一个特定的持久化技术。如果你的数据存储是一个独立的类，那你就可以使用一个基础的持久化策略来开始你的应用，然后等到有意义的时候升级至 SQLite 或者 Core Data。而因为数据存储层的存在，你的应用代码库中就不需要改变任何东西。</p>

<p>在 iOS 的项目中使用 Core Data 经常比构架本身还容易引起更多争议。然而，利用 VIPER 来使用 Core Data 将给你带来使用 Core Data 的前所未有的良好体验。在持久化数据的工具层面上，Core Data 可以保持快速存取和低内存占用方面，简直是个神器。但是有个很恼人的地方，它会像触须一样把 NSManagedObjectContext 延伸至你所有的应用实现文件中，特别是那些它们不该待的地方。VIPER 可以使 Core Data 待在正确的地方：数据存储层。</p>

<p>在待办事项示例中，应用仅有的两部分知道使用了 Core Data，其一是数据存储本身，它负责建立 Core Data 堆栈；另一个是 data manager。Data manager 执行了获取请求，将数据存储返回的 NSManagedObject 对象转换为标准的 PONSO 模型对象，并传输回业务逻辑层。这样一来，应用程序核心将不再依赖于 Core Data，附加得到的好处是，你也再也不用担心过期数据 (stale) 和没有良好组织的多线程 NSManagedObjects 来糟蹋你的工作成果了。</p>

<p>在通过请求访问 Core Data 存储时，data manager 中看起来是这样的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@implementation VTDListDataManager 
</span><span class='line'> 
</span><span class='line'>- (void)todoItemsBetweenStartDate:(NSDate *)startDate endDate:(NSDate*)endDate completionBlock:(void (^)(NSArray *todoItems))completionBlock 
</span><span class='line'>{ 
</span><span class='line'>    NSCalendar *calendar = [NSCalendar autoupdatingCurrentCalendar]; 
</span><span class='line'> 
</span><span class='line'>    NSPredicate *predicate = [NSPredicate predicateWithFormat:@"(date &gt;= %@) AND (date &lt;= %@)", [calendar dateForBeginningOfDay:startDate], [calendar dateForEndOfDay:endDate]]; 
</span><span class='line'>    NSArray *sortDescriptors = @[]; 
</span><span class='line'> 
</span><span class='line'>    __weak typeof(self) welf = self; 
</span><span class='line'>    [self.dataStore 
</span><span class='line'>     fetchEntriesWithPredicate:predicate 
</span><span class='line'>     sortDescriptors:sortDescriptors 
</span><span class='line'>     completionBlock:^(NSArray* entries) { 
</span><span class='line'>         if (completionBlock) 
</span><span class='line'>         { 
</span><span class='line'>             completionBlock([welf todoItemsFromDataStoreEntries:entries]); 
</span><span class='line'>         } 
</span><span class='line'>     }]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (NSArray*)todoItemsFromDataStoreEntries:(NSArray *)entries 
</span><span class='line'>{ 
</span><span class='line'>    return [entries arrayFromObjectsCollectedWithBlock:^id(VTDManagedTodoItem *todo) { 
</span><span class='line'>        return [VTDTodoItem todoItemWithDueDate:todo.date name:todo.name]; 
</span><span class='line'>    }]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>@end </span></code></pre></td></tr></table></div></figure>


<p>与 Core Data 一样极富争议的恐怕就是 UI 故事板了。故事板具有很多有用的功能，如果完全忽视它将会是一个错误。然而，调用故事版所能提供的所有功能来完成 VIPER 的所有目标仍然是很困难的。</p>

<p>我们所能做出的妥协就是选择不使用 segues 。有时候使用 segues 是有效的，但是使用 segues 的危险性在于它们很难原封不动地保持屏幕之间的分离，以及 UI 和应用逻辑之间的分离。一般来说，如果实现 prepareForSegue 方法是必须的话，我们就尽量不去使用 segues。</p>

<p>除此之外，故事板是一个实现用户界面布局有效方法，特别是在使用自动布局的时候。我们选择在实现待办事项两个界面的实例中使用故事板，并且使用这样的代码来执行自己的导航操作。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static NSString *ListViewControllerIdentifier = @"VTDListViewController"; 
</span><span class='line'> 
</span><span class='line'>@implementation VTDListWireframe 
</span><span class='line'> 
</span><span class='line'>- (void)presentListInterfaceFromWindow:(UIWindow *)window  
</span><span class='line'>{ 
</span><span class='line'>    VTDListViewController *listViewController = [self listViewControllerFromStoryboard]; 
</span><span class='line'>    listViewController.eventHandler = self.listPresenter; 
</span><span class='line'>    self.listPresenter.userInterface = listViewController; 
</span><span class='line'>    self.listViewController = listViewController; 
</span><span class='line'> 
</span><span class='line'>    [self.rootWireframe showRootViewController:listViewController 
</span><span class='line'>                                      inWindow:window]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (VTDListViewController *)listViewControllerFromStoryboard  
</span><span class='line'>{ 
</span><span class='line'>    UIStoryboard *storyboard = [self mainStoryboard]; 
</span><span class='line'>    VTDListViewController *viewController = [storyboard instantiateViewControllerWithIdentifier:ListViewControllerIdentifier]; 
</span><span class='line'>    return viewController; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (UIStoryboard *)mainStoryboard  
</span><span class='line'>{ 
</span><span class='line'>    UIStoryboard *storyboard = [UIStoryboard storyboardWithName:@"Main" 
</span><span class='line'>                                                         bundle:[NSBundle mainBundle]]; 
</span><span class='line'>    return storyboard; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>@end </span></code></pre></td></tr></table></div></figure>


<h5>使用 VIPER 构建模块</h5>

<p>一般在使用 VIPER 的时候，你会发现一个屏幕或一组屏幕倾向于聚在一起作为一个模块。模块可以以多种形式体现，但一般最好把它想成是一种特性。在播客应用中，一个模块可能是音频播放器或订阅浏览器。然而在我们的待办事项应用中，列表和添加事项的屏幕都将作为单独的模块被建立。</p>

<p>将你的应用作为一组模块来设计有很多好处，其中之一就是模块可以有非常明确和定义良好的接口，并且独立于其他的模块。这就使增加或者移除特性变得更加简单，也使在界面中向用户展示各种可变模块变得更加简单。</p>

<p>我们希望能将待办事项中各模块之间分隔更加明确，我们为添加模块定义了两个协议。一个是模块接口，它定义了模块可以做什么；另一个则是模块的代理，用来描述该模块做了什么。例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@protocol VTDAddModuleInterface  
</span><span class='line'> 
</span><span class='line'>- (void)cancelAddAction; 
</span><span class='line'>- (void)saveAddActionWithName:(NSString *)name dueDate:(NSDate *)dueDate; 
</span><span class='line'> 
</span><span class='line'>@end 
</span><span class='line'> 
</span><span class='line'> 
</span><span class='line'>@protocol VTDAddModuleDelegate  
</span><span class='line'> 
</span><span class='line'>- (void)addModuleDidCancelAddAction; 
</span><span class='line'>- (void)addModuleDidSaveAddAction; 
</span><span class='line'> 
</span><span class='line'>@end </span></code></pre></td></tr></table></div></figure>


<p>因为模块必须要被展示，才能对用户产生价值，所以模块的展示器通常需要实现模型的接口。当另一个模型想要展现当前模块时，它的展示器就需要实现模型的委托协议，这样它就能在展示时知道当前模块做了些什么。</p>

<p>一个模块可能包括实体，交互器和管理器的通用应用逻辑层，这些通常可用于多个屏幕。当然，这取决于这些屏幕之间的交互及它们的相似度。一个模块可以像在待办事项列表里面一样，简单的只代表一个屏幕。这样一来，应用逻辑层对于它的特定模块的行为来说就非常特有了。</p>

<p>模块同样是组织代码的简便途径。将模块所有的编码都放在它自己的文件夹中并在 Xcode 中建一个 group，这会在你需要寻找和改变更加容易。当你在要寻找一个类时，它恰到好处地就在你所期待的地方，这种感觉真是无法形容的棒。</p>

<p>利用 VIPER 建立模块的另一个好处是它使得扩展到多平台时变得更加简单。独立在交互器层中的所有用例的应用逻辑允许你可以专注于为平板，电话或者 Mac 构建新的用户界面，同时可以重用你的应用层。</p>

<p>进一步来说，iPad 应用的用户界面能够将部分 iPhone 应用的视图，视图控制器及展示器进行再利用。在这种情况下，iPad 屏幕将由 ‘super’ 展示器和线框来代表，这样可以利用 iPhone 使用过的展示器和线框来组成屏幕。建立进而维护一个跨多平台的应用是一个巨大的挑战，但是好的构架可以对整个模型和应用层的再利用有大幅度的提升，并使其实现起来更加容易。</p>

<h5>利用 VIPER 进行测试</h5>

<p>VIPER 的出现激发了一个关注点的分离，这使得采用 TDD 变得更加简便。交互器包含独立与任何 UI 的纯粹逻辑，这使测试驱动开发更加简单。同时展示器包含用来为显示准备数据的逻辑，并且它也独立于任何一个 UIKit 部件。对于这个逻辑的开发也很容易用测试来驱动。</p>

<p>我们更倾向于先从交互器下手。用户界面里所有部分都服务于用例，而通过采用 TDD 来测试驱动交互器的 API 可以让你对用户界面和用例之间的关系有一个更好的了解。</p>

<p>作为实例，我们来看一下负责待办事项列表的交互器。寻找待办事项的策略是要找出所有的将在下周末前截止的项目，并将这些项目分别归类至截止于今天，明天，本周或者下周。</p>

<p>我们编写的第一个测试是为了保证交互器能够找到所有的截止于下周末的待办事项：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)testFindingUpcomingItemsRequestsAllToDoItemsFromTodayThroughEndOfNextWeek 
</span><span class='line'>{ 
</span><span class='line'>    [[self.dataManager expect] todoItemsBetweenStartDate:self.today endDate:self.endOfNextWeek completionBlock:OCMOCK_ANY]; 
</span><span class='line'>    [self.interactor findUpcomingItems]; 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>一旦知道了交互器找到了正确的待办事项后，我们就需要编写几个小测试用来确认它确实将待办事项分配到了正确的相对日期组内（比如说今天，明天，等等）。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)testFindingUpcomingItemsWithOneItemDueTodayReturnsOneUpcomingItemsForToday 
</span><span class='line'>{ 
</span><span class='line'>    NSArray *todoItems = @[[VTDTodoItem todoItemWithDueDate:self.today name:@"Item 1"]]; 
</span><span class='line'>    [self dataStoreWillReturnToDoItems:todoItems]; 
</span><span class='line'> 
</span><span class='line'>    NSArray *upcomingItems = @[[VTDUpcomingItem upcomingItemWithDateRelation:VTDNearTermDateRelationToday dueDate:self.today title:@"Item 1"]]; 
</span><span class='line'>    [self expectUpcomingItems:upcomingItems]; 
</span><span class='line'> 
</span><span class='line'>    [self.interactor findUpcomingItems]; 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>既然我们已经知道了交互器的 API 长什么样，接下来就是开发展示器。一旦展示器接收到了交互器传来的待办事项，我们就需要测试看看我们是否适当的将数据进行格式化并且在用户界面中正确的显示它。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)testFoundZeroUpcomingItemsDisplaysNoContentMessage 
</span><span class='line'>{ 
</span><span class='line'>    [[self.ui expect] showNoContentMessage]; 
</span><span class='line'> 
</span><span class='line'>    [self.presenter foundUpcomingItems:@[]]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (void)testFoundUpcomingItemForTodayDisplaysUpcomingDataWithNoDay 
</span><span class='line'>{ 
</span><span class='line'>    VTDUpcomingDisplayData *displayData = [self displayDataWithSectionName:@"Today" 
</span><span class='line'>                                                          sectionImageName:@"check" 
</span><span class='line'>                                                                 itemTitle:@"Get a haircut" 
</span><span class='line'>                                                                itemDueDay:@""]; 
</span><span class='line'>    [[self.ui expect] showUpcomingDisplayData:displayData]; 
</span><span class='line'> 
</span><span class='line'>    NSCalendar *calendar = [NSCalendar gregorianCalendar]; 
</span><span class='line'>    NSDate *dueDate = [calendar dateWithYear:2014 month:5 day:29]; 
</span><span class='line'>    VTDUpcomingItem *haircut = [VTDUpcomingItem upcomingItemWithDateRelation:VTDNearTermDateRelationToday dueDate:dueDate title:@"Get a haircut"]; 
</span><span class='line'> 
</span><span class='line'>    [self.presenter foundUpcomingItems:@[haircut]]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (void)testFoundUpcomingItemForTomorrowDisplaysUpcomingDataWithDay 
</span><span class='line'>{ 
</span><span class='line'>    VTDUpcomingDisplayData *displayData = [self displayDataWithSectionName:@"Tomorrow" 
</span><span class='line'>                                                          sectionImageName:@"alarm" 
</span><span class='line'>                                                                 itemTitle:@"Buy groceries" 
</span><span class='line'>                                                                itemDueDay:@"Thursday"]; 
</span><span class='line'>    [[self.ui expect] showUpcomingDisplayData:displayData]; 
</span><span class='line'> 
</span><span class='line'>    NSCalendar *calendar = [NSCalendar gregorianCalendar]; 
</span><span class='line'>    NSDate *dueDate = [calendar dateWithYear:2014 month:5 day:29]; 
</span><span class='line'>    VTDUpcomingItem *groceries = [VTDUpcomingItem upcomingItemWithDateRelation:VTDNearTermDateRelationTomorrow dueDate:dueDate title:@"Buy groceries"]; 
</span><span class='line'> 
</span><span class='line'>    [self.presenter foundUpcomingItems:@[groceries]]; 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>同样需要测试的是应用是否在用户想要新建待办事项时正确启动了相应操作：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)testAddNewToDoItemActionPresentsAddToDoUI 
</span><span class='line'>{ 
</span><span class='line'>    [[self.wireframe expect] presentAddInterface]; 
</span><span class='line'> 
</span><span class='line'>    [self.presenter addNewEntry]; 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>这时我们可以开发视图功能了，并且在没有待办事项的时候我们想要展示一个特殊的信息。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)testShowingNoContentMessageShowsNoContentView 
</span><span class='line'>{ 
</span><span class='line'>    [self.view showNoContentMessage]; 
</span><span class='line'> 
</span><span class='line'>    XCTAssertEqualObjects(self.view.view, self.view.noContentView, @"the no content view should be the view"); 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>有待办事项出现时，我们要确保列表是显示出来的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)testShowingUpcomingItemsShowsTableView 
</span><span class='line'>{ 
</span><span class='line'>    [self.view showUpcomingDisplayData:nil]; 
</span><span class='line'> 
</span><span class='line'>    XCTAssertEqualObjects(self.view.view, self.view.tableView, @"the table view should be the view"); 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>首先建立交互器是一种符合 TDD 的自然规律。如果你首先开发交互器，紧接着是展示器，你就可以首先建立一个位于这些层的套件测试，并且为实现这是实例奠定基础。由于你不需要为了测试它们而去与用户界面进行交互，所以这些类可以进行快速迭代。在你需要开发视图的时候，你会有一个可以工作并测试过的逻辑和表现层来与其进行连接。在快要完成对视图的开发时，你会发现第一次运行程序时所有部件都运行良好，因为你所有已通过的测试已经告诉你它可以工作。</p>

<h5>结论</h5>

<p>我们希望你喜欢这篇对 VIPER 的介绍。或许你们都很好奇接下来应该做什么，如果你希望通过 VIPER 来对你下一个应用进行设计，该从哪里开始呢？</p>

<p>我们竭尽全力使这篇文章和我们利用 VIPER 实现的应用实例足够明确并且进行了很好的定义。我们的待办事项里列表程序相当直接简单，但是它准确地解释了如何利用 VIPER 来建立一个应用。在实际的项目中，你可以根据你自己的挑战和约束条件来决定要如何实践这个例子。根据以往的经验，我们的每个项目在使用 VIPER 时都或多或少地改变了一些策略，但它们无一例外的都从中得益，找到了正确的方向。</p>

<p>很多情况下由于某些原因，你可能会想要偏离 VIPER 所指引的道路。可能你遇到了很多 &lsquo;bunny&rsquo; 对象，或者你的应用使用了故事板的 segues。没关系的，在这些情况下，你只需要在做决定时稍微考虑下 VIPER 所代表的精神就好。VIPER 的核心在于它是建立在单一责任原则上的架构。如果你碰到了些许麻烦，想想这些原则再考虑如何前进。</p>

<p>你一定想知道在现有的应用中能否只用 VIPER 。在这种情况下，你可以考虑使用 VIPER 构建新的特性。我们许多现有项目都使用了这个方法。你可以利用 VIPER 建立一个模块，这能帮助你发现许多建立在单一责任原则基础上造成难以运用架构的现有问题。</p>

<p>软件开发最伟大的事情之一就是每个应用程序都是不同的，而设计每个应用的架构的方式也是不同的。这就意味着每个应用对于我们来说都是一个学习和尝试的机遇，如果你决定开始使用 VIPER，你会受益匪浅。感谢你的阅读。</p>

<h5>Swift 补充</h5>

<p>苹果上周在 WWDC 介绍了一门称之为 Swift 的编程语言来作为 Cocoa 和 Cocoa Touch 开发的未来。现在发表关于 Swift 的完整意见还为时尚早，但众所周知编程语言对我们如何设计和构建应用有着重大影响。我们决定使用 Swift 重写我们的待办事项清单，帮助我们学习它对 VIPER 意味着什么。至今为止，收获颇丰。Swift 中的一些特性对于构建应用的体验有着显著的提升。</p>

<h5>结构体</h5>

<p>在 VIPER 中我们使用小型，轻量级的 model 类来在比如从展示器到视图这样不同的层间传递数据。这些 PONSOs 通常是只是简单地带有少量数据，并且通常这些类不会被继承。Swift 的结构体非常适合这个情况。下面的结构体的例子来自 VIPER Swift。这个结构体需要被判断是否相等，所以我们重载了 == 操作符来比较这个类型的两个实例。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct UpcomingDisplayItem : Equatable, Printable { 
</span><span class='line'>    let title : String = "" 
</span><span class='line'>    let dueDate : String = "" 
</span><span class='line'> 
</span><span class='line'>    var description : String { get { 
</span><span class='line'>        return "\(title) -- \(dueDate)" 
</span><span class='line'>    }} 
</span><span class='line'> 
</span><span class='line'>    init(title: String, dueDate: String) { 
</span><span class='line'>        self.title = title 
</span><span class='line'>        self.dueDate = dueDate 
</span><span class='line'>    } 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>func == (leftSide: UpcomingDisplayItem, rightSide: UpcomingDisplayItem) -&gt; Bool { 
</span><span class='line'>    var hasEqualSections = false 
</span><span class='line'>    hasEqualSections = rightSide.title == leftSide.title 
</span><span class='line'> 
</span><span class='line'>    if hasEqualSections == false { 
</span><span class='line'>        return false 
</span><span class='line'>    } 
</span><span class='line'> 
</span><span class='line'>    hasEqualSections = rightSide.dueDate == rightSide.dueDate 
</span><span class='line'> 
</span><span class='line'>    return hasEqualSections 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p></p>

<h5>类型安全</h5>

<p>也许 Objective-C 和 Swift 的最大区别是它们在对于类型处理上的不同。 Objective-C 是动态类型，而 Swift 故意在编译时做了严格的类型检查。对于一个类似 VIPER 的架构， 应用由不同层构成，类型安全是提升程序员效率和设计架构有非常大的好处。编译器帮助你确保正确类型的容器和对象在层的边界传递。如上所示，这是一个使用结构体的好地方。如果一个结构体的被设计为存在于两层之间，那么由于类型安全，你可以保证它将永远无法脱离这些层之间。</p>

<h5>扩展阅读</h5>

<p><a href="https://github.com/objcio/issue-13-viper">VIPER TODO, 文章示例</a></p>

<p><a href="https://github.com/objcio/issue-13-viper-swift">VIPER SWIFT, 基于 Swift 的文章示例</a></p>

<p><a href="https://github.com/mutualmobile/Counter">另一个计数器应用</a></p>

<p><a href="http://mutualmobile.github.io/blog/2013/12/04/viper-introduction/">Mutual Mobile 关于 VIPER 的介绍</a></p>

<p><a href="http://blog.8thlight.com/uncle-bob/2011/11/22/Clean-Architecture.html">简明架构</a></p>

<p><a href="http://objccn.io/issue-1-1/">更轻量的 View Controllers</a></p>

<p><a href="http://objccn.io/issue-1-3/">测试 View Controllers</a></p>

<p><a href="http://inessential.com/2014/03/16/smaller_please">Bunnies</a></p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[优秀开源项目：FACEBOOK PAPER动画引擎 – POP]]></title>
        <link href="http://swplzj.github.io/blog/2014/11/14/you-xiu-kai-yuan-xiang-mu-facebook-paper-dong-hua-yin-qing-pop/"/>
        <updated>2014-11-14T19:02:27+08:00</updated>
        <id>http://swplzj.github.io/blog/2014/11/14/you-xiu-kai-yuan-xiang-mu-facebook-paper-dong-hua-yin-qing-pop</id>
        <content type="html"><![CDATA[<p><img src="http://cc.cocimg.com/cms/uploads/allimg/140429/4196_140429142234_1.gif" alt="id1" /></p>

<p>Pop是一个适用于iOS和OS X平台的可扩展动画引擎，是一个成熟的经过多重测试的，可实现Facebook Paper中的所有动画和过渡效果。除了基本的静态动画，Pop还支持spring和decay动画，有助于打造一个逼真的，基于物理的交互。你可以通过Pop的API把Pop快速集成到现有的Objective-C代码库中，并在任何对象上实现动画的任何属性。</p>

<!--more-->


<p></p>

<h5>开始，停止以及更新</h5>

<p>开始动画–把它添加到你想要动画的对象上：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>POPSpringAnimation *anim = [POPSpringAnimation animation]; 
</span><span class='line'>… 
</span><span class='line'>[layer pop_addAnimation:anim forKey:@"myKey"]; </span></code></pre></td></tr></table></div></figure>


<p>停止动画–把它从key在刚开始时指定的对象引用中移除。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[layer pop_removeAnimationForKey:@"myKey"]; 
</span><span class='line'>key可以用来查询现有的动画。更新运行中动画的toValue，为改变进程提供了很好的方式：
</span><span class='line'>anim = [layer pop_animationForKey:@"myKey"]; 
</span><span class='line'>if (anim) { 
</span><span class='line'>  /* update to value to new destination */ 
</span><span class='line'>  anim.toValue = @(42.0); 
</span><span class='line'>} else { 
</span><span class='line'>  /* create and start a new animation */ 
</span><span class='line'>  …. 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>虽然上述代码中使用了layer，但是Pop接口作为一个NSObject上附加类别执行。任何NSObject或者子类可以被动画。</p>

<h5>类型</h5>

<p>Pop有四个具体的动画类型：spring, decay, basic和custom
Spring动画可以用来给对象一个令人愉悦的弹跳效果。在这个例子中，我们用spring动画来动画一个层次的弹跳效果，从现有的值设定为(0, 0, 400, 400)。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>POPSpringAnimation *anim = [POPSpringAnimation animationWithPropertyNamed:kPOPLayerBounds]; 
</span><span class='line'>anim.toValue = [NSValue valueWithCGRec 
</span><span class='line'>t:CGRectMake(0, 0, 400, 400)]; 
</span><span class='line'>[layer pop_addAnimation:anim forKey:@"size"]; </span></code></pre></td></tr></table></div></figure>


<p>Decay动画能用于逐渐减慢一个对象直至停止。在这个例子中，我们将layer的速率减小为每秒钟1000pts。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>POPDecayAnimation *anim = [POPDecayAnimation animationWithPropertyNamed:kPOPLayerPositionX]; 
</span><span class='line'>anim.velocity = @(1000.); 
</span><span class='line'>[layer pop_addAnimation:anim forKey:@"slide"]; </span></code></pre></td></tr></table></div></figure>


<p>基本动画能用于在指定的时间段插入值。使用一个淡入淡出动画在默认时间段将视图的透明度从0.0设置为1.0。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>POPBasicAnimation *anim = [POPBasicAnimation animationWithPropertyNamed:kPOPViewAlpha]; 
</span><span class='line'>anim.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]; 
</span><span class='line'>anim.fromValue = @(0.0); 
</span><span class='line'>anim.toValue = @(1.0); 
</span><span class='line'>[view pop_addAnimation:anim forKey:@"slide"]; </span></code></pre></td></tr></table></div></figure>


<p>通过处理CADisplayLink和相关的time-step管理，POPCustomAnimation使创建自定义动画和过渡变得更加容易。更多详情请查看header。</p>

<h5>属性</h5>

<p>属性由POPAnimatableProperty类指定动画。在这个例子中，我们创建一个spring动画，明确地设置与-[CALayer bounds]一致的动画属性：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>POPSpringAnimation *anim = [POPSpringAnimation animation]; 
</span><span class='line'>anim.property = [POPAnimatableProperty propertyWithName:kPOPLayerBounds]; </span></code></pre></td></tr></table></div></figure>


<p>这个框架提供了很多常见的层以及额外的视图动画属性。你可以通过创建类的新实例来动画一个自定义属性。在这个例子中，我声明了一个自定义音量属性：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>prop = [POPAnimatableProperty propertyWithName:@"com.foo.radio.vo 
</span><span class='line'>lume" initializer:^(POPMutableAnimatableProperty *prop) { 
</span><span class='line'>  // read value 
</span><span class='line'>  prop.readBlock = ^(id obj, CGFloat values[]) { 
</span><span class='line'>    values[0] = [obj volume]; 
</span><span class='line'>  }; 
</span><span class='line'>  // write value 
</span><span class='line'>  prop.writeBlock = ^(id obj, const CGFloat values[]) { 
</span><span class='line'>    [obj setVolume:values[0]]; 
</span><span class='line'>  }; 
</span><span class='line'>  // dynamics threshold 
</span><span class='line'>  prop.threshold = 0.01; 
</span><span class='line'>}]; 
</span><span class='line'>anim.property = prop; </span></code></pre></td></tr></table></div></figure>


<p>关于动画属性的完整列表以及声明自定义属性的更多信息，请看POPAnimatableProperty.h。</p>

<h5>调试</h5>

<p>这里有一些关于调试的技巧。Pop遵循模拟器的Toggle Slow Animations设置。试着用它放慢动画，将能更容易查看交互。
考虑给你的动画命名。当你通过日志查看动画或者调试动画时，这将使你更容易识别它们。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>anim.name = @“springOpen”; </span></code></pre></td></tr></table></div></figure>


<p>每个动画都有一个关联的tracer，它以一种快速高效的方式允许你记录所有的动画相关事件，还允许你在动画完成后对其进行查询和分析。下边的例子展示启动和配置tracer，以记录所有动画事件。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>POPAnimationTracer *tracer = anim.tracer; 
</span><span class='line'>tracer.shouldLogAndResetOnCompletion = YES; 
</span><span class='line'>[tracer start]; </span></code></pre></td></tr></table></div></figure>


<p>更多详情，请查看POPAnimationTracer.h。
假设已经安装了CocoaPods，这将在单元测试目标中包含必要的OCMock依赖。</p>

<h5>相关资源</h5>

<p><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html">Core Animation Programming Guide</a>
<a href="http://tapity.com/tutorial-getting-started-with-pop/">Tapity Tutorial – Getting Started with Pop</a>
<a href="https://github.com/facebook/tweaks">Tweaks – Easily adjust parameters for iOS apps in development</a>
<a href="http://facebook.github.io/rebound/">Rebound – Springs Animations for Android</a></p>
]]></content>
    </entry>
    
</feed>

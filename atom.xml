<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    
    <title><![CDATA[Leo Lee]]></title>
    <link href="http://swplzj.github.io/atom.xml" rel="self"/>
    <link href="http://swplzj.github.io/"/>
    <updated>2015-08-11T22:32:01+08:00</updated>
    <id>http://swplzj.github.io/</id>
    <author>
        <name><![CDATA[Leo Lee]]></name>
        <email><![CDATA[swplzj@126.com]]></email>
    </author>
    <generator uri="http://octopress.org/">Octopress</generator>
    
    
    <entry>
        <title type="html"><![CDATA[Stay Hungry Stay Foolish]]></title>
        <link href="http://swplzj.github.io/blog/2015/08/11/stay-hungry/"/>
        <updated>2015-08-11T22:17:40+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/08/11/stay-hungry</id>
        <content type="html"><![CDATA[<p>今天又看了一遍乔帮主的演讲，每次观看，都能让我重新定位自己，重新审视自己，从自己身上找到答案。</p>

<p>乔布斯对操场上挤的满满的毕业生、校友和家长们说：“你的时间有限，所以最好别把它浪费在模仿别人这种事上。” &ndash;同样地，如果还在学校的话，似乎不应该去模仿退学的牛人们。</p>

<p>You&rsquo;ve got to find what you love,&lsquo; Jobs says
　　</p>

<p>Jobs说，你必须要找到你所爱的东西。
　　</p>

<p>This is the text of the Commencement address by Steve Jobs, CEO of Apple Computer and of Pixar Animation Studios, delivered on June 12, 2005.</p>

<p>这是苹果公司和Pixar动画工作室的CEO Steve Jobs于2005年6月12号在斯坦福大学的毕业典礼上面的演讲稿。</p>

<p>　　<!--more--></p>

<p>I am honored to be with you today at your commencement from one of the finest universities in the world. I never graduated from college. Truth be told, this is the closest I&rsquo;ve ever gotten to a college graduation. Today I want to tell you three stories from my life. That&rsquo;s it. No big deal. Just three stories.</p>

<p>　　我今天很荣幸能和你们一起参加毕业典礼，斯坦福大学是世界上最好的大学之一。我从来没有从大学中毕业。说实话,今天也许是在我的生命中离大学毕业最近的一天了。今天我想向你们讲述我生活中的三个故事。不是什么大不了的事情,只是三个故事而已。
　　</p>

<h3>　　The first story is about connecting the dots.</h3>

<h3>　　第一个故事是关于如何把生命中的点点滴滴串连起来。</h3>

<p>I dropped out of Reed College after the first 6 months, but then stayed around as a drop-in for another 18 months or so before I really quit. So why did I drop out?
　　</p>

<p>我在Reed大学读了六个月之后就退学了,但是在十八个月以后——我真正的作出退学决定之前,我还经常去学校。我为什么要退学呢?</p>

<p>　　It started before I was born. My biological mother was a young, unwed college graduate student, and she decided to put me up for adoption. She felt very strongly that I should be adopted by college graduates, so everything was all set for me to be adopted at birth by a lawyer and his wife. Except that when I popped out they decided at the last minute that they really wanted a girl.
　　</p>

<p>故事从我出生的时候讲起。我的亲生母亲是一个年轻的,没有结婚的大学毕业生。她决定让别人收养我, 她十分想让我被大学毕业生收养。所以在我出生的时候，她已经做好了一切的准备工作，能使得我被一个律师和他的妻子所收养。但是她没有料到,当我出生之后,律师夫妇突然决定他们想要一个女孩。</p>

<p>So my parents, who were on a waiting list, got a call in the middle of the night asking: &ldquo;We have an unexpected baby boy; do you want him?&rdquo; They said: &ldquo;Of course.&rdquo; My biological mother later found out that my mother had never graduated from college and that my father had never graduated from high school. She refused to sign the final adoption papers. She only relented a few months later when my parents promised that I would someday go to college.</p>

<p>所以我的生养父母(他们还在我亲生父母的观察名单上)突然在半夜接到了一个电话:“我们现在这儿有一个不小心生出来的男婴,你们想要他吗?”他们回答道:“当然!”但是我亲生母亲随后发现，我的养母从来没有上过大学,我的父亲甚至从没有读过高中。她拒绝签这个收养合同。只是在几个月以后,我的父母答应她一定要让我上大学,那个时候她才同意。</p>

<p>And 17 years later I did go to college. But I naively chose a college that was almost as expensive as Stanford, and all of my working-class parents' savings were being spent on my college tuition. After six months, I couldn&rsquo;t see the value in it. I had no idea what I wanted to do with my life and no idea how college was going to help me figure it out.</p>

<p>在十七岁那年,我真的上了大学。但是我很愚蠢的选择了一个几乎和你们斯坦福大学一样贵的学校, 我父母还处于蓝领阶层，他们几乎把所有积蓄都花在了我的学费上面。在六个月后, 我已经看不到其中的价值所在。我不知道我想要在生命中做什么,我也不知道大学能帮助我找到怎样的答案。</p>

<p>And here I was spending all of the money my parents had saved their entire life. So I decided to drop out and trust that it would all work out OK. It was pretty scary at the time, but looking back it was one of the best decisions I ever made. The minute I dropped out I could stop taking the required classes that didn&rsquo;t interest me, and begin dropping in on the ones that looked interesting.</p>

<p>但是在这里，我几乎花光了我父母这一辈子的所有积蓄。所以我决定要退学,我觉得这是个正确的决定。不能否认,我当时确实非常的害怕, 但是现在回头看看,那的确是我这一生中最棒的一个决定。在我做出退学决定的那一刻, 我终于可以不必去读那些令我提不起丝毫兴趣的课程了。然后我还可以去修那些看起来有点意思的课程。</p>

<p>It wasn&rsquo;t all romantic. I didn&rsquo;t have a dorm room, so I slept on the floor in friends' rooms, I returned coke bottles for the 5¢ deposits to buy food with, and I would walk the 7 miles across town every Sunday night to get one good meal a week at the Hare Krishna temple. I loved it. And much of what I stumbled into by following my curiosity and intuition turned out to be priceless later on. Let me give you one example:</p>

<p>但是这并不是那么罗曼蒂克。我失去了我的宿舍,所以我只能在朋友房间的地板上面睡觉,我去捡5美分的可乐瓶子，仅仅为了填饱肚子, 在星期天的晚上,我需要走七英里的路程，穿过这个城市到Hare Krishna寺庙(注：位于纽约Brooklyn下城),只是为了能吃上饭——这个星期唯一一顿好一点的饭。但是我喜欢这样。我跟着我的直觉和好奇心走, 遇到的很多东西,此后被证明是无价之宝。让我给你们举一个例子吧：</p>

<p>　　Reed College at that time offered perhaps the best calligraphy instruction in the country. Throughout the campus every poster, every label on every drawer, was beautifully hand calligraphed. Because I had dropped out and didn&rsquo;t have to take the normal classes, I decided to take a calligraphy class to learn how to do this.</p>

<p>Reed大学在那时提供也许是全美最好的美术字课程。在这个大学里面的每个海报, 每个抽屉的标签上面全都是漂亮的美术字。因为我退学了, 没有受到正规的训练, 所以我决定去参加这个课程，去学学怎样写出漂亮的美术字。</p>

<p>　　I learned about serif and san serif typefaces, about varying the amount of space between different letter combinations, about what makes great typography great. It was beautiful, historical, artistically subtle in a way that science can&rsquo;t capture, and I found it fascinating.
　　</p>

<p>我学到了san serif 和serif字体, 我学会了怎么样在不同的字母组合之中改变空格的长度, 还有怎么样才能作出最棒的印刷式样。那是一种科学永远不能捕捉到的、美丽的、真实的艺术精妙, 我发现那实在是太美妙了。</p>

<p>　　None of this had even a hope of any practical application in my life. But ten years later, when we were designing the first Macintosh computer, it all came back to me. And we designed it all into the Mac. It was the first computer with beautiful typography. If I had never dropped in on that single course in college, the Mac would have never had multiple typefaces or proportionally spaced fonts.
　　</p>

<p>当时看起来这些东西在我的生命中，好像都没有什么实际应用的可能。但是十年之后,当我们在设计第一台Macintosh电脑的时候,就不是那样了。我把当时我学的那些家伙全都设计进了Mac。那是第一台使用了漂亮的印刷字体的电脑。</p>

<p>　　And since Windows just copied the Mac, its likely that no personal computer would have them. If I had never dropped out, I would have never dropped in on this calligraphy class, and personal computers might not have the wonderful typography that they do. Of course it was impossible to connect the dots looking forward when I was in college. But it was very, very clear looking backwards ten years later.
　　</p>

<p>如果我当时没有退学, 就不会有机会去参加这个我感兴趣的美术字课程, Mac就不会有这么多丰富的字体，以及赏心悦目的字体间距。那么现在个人电脑就不会有现在这么美妙的字型了。当然我在大学的时候，还不可能把从前的点点滴滴串连起来,但是当我十年后回顾这一切的时候,真的豁然开朗了。</p>

<p>　　Again, you can&rsquo;t connect the dots looking forward; you can only connect them looking backwards. So you have to trust that the dots will somehow connect in your future. You have to trust in something - your gut, destiny, life, karma, whatever. This approach has never let me down, and it has made all the difference in my life.
　　</p>

<p>再次说明的是,你在向前展望的时候不可能将这些片断串连起来;你只能在回顾的时候将点点滴滴串连起来。所以你必须相信这些片断会在你未来的某一天串连起来。你必须要相信某些东西：你的勇气、目的、生命、因缘。这个过程从来没有令我失望(let me down),只是让我的生命更加地与众不同而已。</p>

<h3>　　My second story is about love and loss.</h3>

<h3>　　我的第二个故事是关于爱和损失的。</h3>

<p>　　I was lucky – I found what I loved to do early in life. Woz and I started Apple in my parents garage when I was 20. We worked hard, and in 10 years Apple had grown from just the two of us in a garage into a billion company with over 4000 employees. We had just released our finest creation - the Macintosh - a year earlier, and I had just turned 30.
　　</p>

<p>我非常幸运, 因为我在很早的时候就找到了我钟爱的东西。Woz和我在二十岁的时候就在父母的车库里面开创了苹果公司。我们工作得很努力, 十年之后, 这个公司从那两个车库中的穷光蛋发展到了超过四千名的雇员、价值超过二十亿的大公司。在公司成立的第九年,我们刚刚发布了最好的产品,那就是Macintosh。我也快要到三十岁了。</p>

<p>　　And then I got fired. How can you get fired from a company you started? Well, as Apple grew we hired someone who I thought was very talented to run the company with me, and for the first year or so things went well. But then our visions of the future began to diverge and eventually we had a falling out. When we did, our Board of Directors sided with him. So at 30 I was out. And very publicly out. What had been the focus of my entire adult life was gone, and it was devastating.
　　</p>

<p>在那一年, 我被炒了鱿鱼。你怎么可能被你自己创立的公司炒了鱿鱼呢? 嗯,在苹果快速成长的时候，我们雇用了一个很有天分的家伙和我一起管理这个公司, 在最初的几年,公司运转的很好。但是后来我们对未来的看法发生了分歧, 最终我们吵了起来。当争吵不可开交的时候, 董事会站在了他的那一边。所以在三十岁的时候, 我被炒了。在这么多人的眼皮下我被炒了。在而立之年，我生命的全部支柱离自己远去, 这真是毁灭性的打击。</p>

<p>I really didn&rsquo;t know what to do for a few months. I felt that I had let the previous generation of entrepreneurs down - that I had dropped the baton as it was being passed to me. I met with David Packard and Bob Noyce and tried to apologize for screwing up so badly.</p>

<p>在最初的几个月里，我真是不知道该做些什么。我把从前的创业激情给丢了, 我觉得自己让与我一同创业的人都很沮丧。我和David Pack和Bob Boyce见面，并试图向他们道歉。</p>

<p>　　I was a very public failure, and I even thought about running away from the valley. But something slowly began to dawn on me – I still loved what I did. The turn of events at Apple had not changed that one bit. I had been rejected, but I was still in love. And so I decided to start over.
　　</p>

<p>我把事情弄得糟糕透顶了。但是我渐渐发现了曙光, 我仍然喜爱我从事的这些东西。苹果公司发生的这些事情丝毫的没有改变这些, 一点也没有。我被驱逐了,但是我仍然钟爱它。所以我决定从头再来。</p>

<p>　　I didn&rsquo;t see it then, but it turned out that getting fired from Apple was the best thing that could have ever happened to me. The heaviness of being successful was replaced by the lightness of being a beginner again, less sure about everything. It freed me to enter one of the most creative periods of my life.
　　</p>

<p>我当时没有觉察, 但是事后证明, 从苹果公司被炒是我这辈子发生的最棒的事情。因为，作为一个成功者的极乐感觉被作为一个创业者的轻松感觉所重新代替: 对任何事情都不那么特别看重。这让我觉得如此自由, 进入了我生命中最有创造力的一个阶段。</p>

<p>　　During the next five years, I started a company named NeXT, another company named Pixar, and fell in love with an amazing woman who would become my wife. Pixar went on to create the worlds first computer animated feature film, Toy Story, and is now the most successful animation studio in the world.
　　</p>

<p>在接下来的五年里, 我创立了一个名叫NeXT的公司, 还有一个叫Pixar的公司, 然后和一个后来成为我妻子的优雅女人相识。Pixar 制作了世界上第一个用电脑制作的动画电影——“”玩具总动员”,Pixar现在也是世界上最成功的电脑制作工作室。</p>

<p>　　In a remarkable turn of events, Apple bought NeXT, I retuned to Apple, and the technology we developed at NeXT is at the heart of Apple&rsquo;s current renaissance. And Laurene and I have a wonderful family together.
　　</p>

<p>在后来的一系列运转中,Apple收购了NeXT, 然后我又回到了Apple公司。我们在NeXT发展的技术在Apple的复兴之中发挥了关键的作用。我还和Laurence 一起建立了一个幸福的家庭。</p>

<p>　　I&rsquo;m pretty sure none of this would have happened if I hadn&rsquo;t been fired from Apple. It was awful tasting medicine, but I guess the patient needed it. Sometimes life hits you in the head with a brick. Don&rsquo;t lose faith. I&rsquo;m convinced that the only thing that kept me going was that I loved what I did. You&rsquo;ve got to find what you love.
　　</p>

<p>我可以非常肯定,如果我不被Apple开除的话, 这其中一件事情也不会发生的。这个良药的味道实在是太苦了,但是我想病人需要这个药。有些时候, 生活会拿起一块砖头向你的脑袋上猛拍一下。不要失去信心。我很清楚唯一使我一直走下去的，就是我做的事情令我无比钟爱。你需要去找到你所爱的东西</p>

<p>　　And that is as true for your work as it is for your lovers. Your work is going to fill a large part of your life, and the only way to be truly satisfied is to do what you believe is great work. And the only way to do great work is to love what you do. If you haven&rsquo;t found it yet, keep looking. Don&rsquo;t settle. As with all matters of the heart, you&rsquo;ll know when you find it. And, like any great relationship, it just gets better and better as the years roll on. So keep looking until you find it. Don&rsquo;t settle.
　　</p>

<p>对于工作是如此, 对于你的爱人也是如此。你的工作将会占据生活中很大的一部分。你只有相信自己所做的是伟大的工作, 你才能怡然自得。如果你现在还没有找到, 那么继续找、不要停下来、全心全意的去找, 当你找到的时候你就会知道的。就像任何真诚的关系, 随着岁月的流逝只会越来越紧密。所以继续找，直到你找到它，不要停下来!</p>

<h3>　　My third story is about death.</h3>

<h3>　　我的第三个故事是关于死亡的。</h3>

<p>　　When I was 17, I read a quote that went something like: &ldquo;If you live each day as if it was your last, someday you&rsquo;ll most certainly be right.&rdquo; It made an impression on me, and since then, for the past 33 years, I have looked in the mirror every morning and asked myself: &ldquo;If today were the last day of my life, would I want to do what I am about to do today?&rdquo; And whenever the answer has been &ldquo;No&rdquo; for too many days in a row, I know I need to change something.
　　</p>

<p>当我十七岁的时候, 我读到了一句话:“如果你把每一天都当作生命中最后一天去生活的话,那么有一天你会发现你是正确的。”这句话给我留下了深刻的印象。从那时开始,过了33年,我在每天早晨都会对着镜子问自己:“如果今天是我生命中的最后一天, 你会不会完成你今天想做的事情呢?”当答案连续很多次被给予“不是”的时候, 我知道自己需要改变某些事情了。</p>

<p>　　Remembering that I&rsquo;ll be dead soon is the most important tool I&rsquo;ve ever encountered to help me make the big choices in life. Because almost everything – all external expectations, all pride, all fear of embarrassment or failure - these things just fall away in the face of death, leaving only what is truly important. Remembering that you are going to die is the best way I know to avoid the trap of thinking you have something to lose. You are already naked. There is no reason not to follow your heart.
　　</p>

<p>“记住你即将死去”是我一生中遇到的最重要箴言。它帮我指明了生命中重要的选择。因为几乎所有的事情, 包括所有的荣誉、所有的骄傲、所有对难堪和失败的恐惧,这些在死亡面前都会消失。我看到的是留下的真正重要的东西。你有时候会思考你将会失去某些东西,“记住你即将死去”是我知道的避免这些想法的最好办法。你已经赤身裸体了, 你没有理由不去跟随自己的心一起跳动。</p>

<p>　　About a year ago I was diagnosed with cancer. I had a scan at 7:30 in the morning, and it clearly showed a tumor on my pancreas. I didn&rsquo;t even know what a pancreas was. The doctors told me this was almost certainly a type of cancer that is incurable, and that I should expect to live no longer than three to six months. My doctor advised me to go home and get my affairs in order, which is doctor&rsquo;s code for prepare to die. It means to try to tell your kids everything you thought you&rsquo;d have the next 10 years to tell them in just a few months. It means to make sure everything is buttoned up so that it will be as easy as possible for your family. It means to say your goodbyes.
　　</p>

<p>大概一年以前, 我被诊断出癌症。我在早晨七点半做了一个检查, 检查清楚的显示在我的胰腺有一个肿瘤。我当时都不知道胰腺是什么东西。医生告诉我那很可能是一种无法治愈的癌症, 我还有三到六个月的时间活在这个世界上。我的医生叫我回家, 然后整理好我的一切, 那就是医生准备死亡的程序。那意味着你将要把未来十年对你小孩说的话在几个月里面说完.;那意味着把每件事情都搞定, 让你的家人会尽可能轻松的生活;那意味着你要说“再见了”。</p>

<p>　　I lived with that diagnosis all day. Later that evening I had a biopsy, where they stuck an endoscope down my throat, through my stomach and into my intestines, put a needle into my pancreas and got a few cells from the tumor. I was sedated, but my wife, who was there, told me that when they viewed the cells under a microscope the doctors started crying because it turned out to be a very rare form of pancreatic cancer that is curable with surgery. I had the surgery and I&rsquo;m fine now.
　　</p>

<p>我整天和那个诊断书一起生活。后来有一天早上我作了一个活切片检查，医生将一个内窥镜从我的喉咙伸进去,通过我的胃, 然后进入我的肠子, 用一根针在我的胰腺上的肿瘤上取了几个细胞。我当时很镇静,因为我被注射了镇定剂。但是我的妻子在那里, 后来告诉我，当医生在显微镜地下观察这些细胞的时候他们开始尖叫, 因为这些细胞最后竟然是一种非常罕见的可以用手术治愈的胰腺癌症。我做了这个手术, 现在我痊愈了。</p>

<p>　　This was the closest I&rsquo;ve been to facing death, and I hope its the closest I get for a few more decades. Having lived through it, I can now say this to you with a bit more certainty than when death was a useful but purely intellectual concept:</p>

<p>那是我最接近死亡的时候, 我还希望这也是以后的几十年最接近的一次。从死亡线上又活了过来, 死亡对我来说，只是一个有用但是纯粹是知识上的概念的时候，我可以更肯定一点地对你们说：</p>

<p>　　No one wants to die. Even people who want to go to heaven don&rsquo;t want to die to get there. And yet death is the destination we all share. No one has ever escaped it. And that is as it should be, because Death is very likely the single best invention of Life. It is Life&rsquo;s change agent. It clears out the old to make way for the new. Right now the new is you, but someday not too long from now, you will gradually become the old and be cleared away. Sorry to be so dramatic, but it is quite true.
　　</p>

<p>没有人愿意死, 即使人们想上天堂, 人们也不会为了去那里而死。但是死亡是我们每个人共同的终点。从来没有人能够逃脱它。也应该如此。 因为死亡就是生命中最好的一个发明。它将旧的清除以便给新的让路。你们现在是新的, 但是从现在开始不久以后, 你们将会逐渐的变成旧的然后被清除。我很抱歉这很戏剧性, 但是这十分的真实。</p>

<p>　　Your time is limited, so don&rsquo;t waste it living someone else&rsquo;s life. Don&rsquo;t be trapped by dogma - which is living with the results of other people&rsquo;s thinking. Don&rsquo;t let the noise of other&rsquo;s opinions drown out your own inner voice. And most important, have the courage to follow your heart and intuition. They somehow already know what you truly want to become. Everything else is secondary.
　　</p>

<p>When I was young, there was an amazing publication called The Whole Earth Catalog, which was one of the bibles of my generation. It was created by a fellow named Stewart Brand not far from here in Menlo Park, and he brought it to life with his poetic touch. This was in the late 1960&rsquo;s, before personal computers and desktop publishing, so it was all made with typewriters, scissors, and polaroid cameras. It was sort of like Google in paperback form, 35 years before Google came along: it was idealistic, and overflowing with neat tools and great notion</p>

<p>　　Stewart and his team put out several issues of The Whole Earth Catalog, and then when it had run its course, they put out a final issue. It was the mid-1970s, and I was your age. On the back cover of their final issue was a photograph of an early morning country road, the kind you might find yourself hitchhiking on if you were so adventurous. Beneath it were the words: &ldquo;Stay Hungry. Stay Foolish.&rdquo; It was their farewell message as they signed off. Stay Hungry. Stay Foolish. And I have always wished that for myself. And now, as you graduate to begin anew, I wish that for you.
　　</p>

<p>Stay Hungry. Stay Foolish.</p>

<p>Thank you all very much.</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[博客升级了]]></title>
        <link href="http://swplzj.github.io/blog/2015/07/31/bo-ke-sheng-ji-liao/"/>
        <updated>2015-07-31T19:17:56+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/07/31/bo-ke-sheng-ji-liao</id>
        <content type="html"><![CDATA[<p>博客其实早就搭建了，中间发布过一些文章，可是博客一直没有升级，现在针对以下几个功能进行了添加及优化。</p>

<ul>
<li>更换主题</li>
<li>添加站长统计</li>
<li>添加多说评论</li>
<li>添加七牛云图片存储服务</li>
<li>自动为图片添加url前缀</li>
<li>写在最后</li>
</ul>


<!--more-->


<h3>更换主题</h3>

<p>搭建完博客之后，接着就要更换为自己喜欢的主题了，选择的主题是 <a href="http://sofreshandsogreen.herokuapp.com">So Fresh and So Green</a>，喜欢这种带有活力的色调。具体设置步骤如下：</p>

<p><code>Step 1</code></p>

<p>使用命令安装主题；</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git clone https://github.com/johnkeith/sofreshandsogreen.git .themes/sofreshandsogreen
</span><span class='line'>  
</span><span class='line'>$ bundle exec rake install['sofreshandsogreen']</span></code></pre></td></tr></table></div></figure>


<p><code>Step 2</code></p>

<p>更改博客配置文件  <code>_config.yml</code>，需要移除默认主题的侧边栏，</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>default_asides: []
</span><span class='line'>sidebar: collapse</span></code></pre></td></tr></table></div></figure>


<p><code>Step 3</code></p>

<p>在首页显示显示圆形头像，首先到 <code>source/images</code>目录下面，使用你选择的头像替换掉 <code>portrait.jpg</code>, 然后再配置文件 <code>_config.yml</code> 中，添加下面一句代码：</p>

<pre><code>portrait: true
</code></pre>

<p>（BTW：我选择的头像使我们几个朋友一起亲手绘画的梵高的向日葵，色调与博客主题色调完美搭配，赞一个~~）</p>

<p>至此，博客主题安装完成。</p>

<h3>添加站长统计</h3>

<p>博客搭建完成之后，需要看自己博客被访问次数，访问页面，访问速度，页面停留时间&hellip;等等，都需要借助第三方的统计工具来完成的，类似于移动端 App 使用的友盟统计一样，这个还要简单只需要注册相应的账号，然后，在自己博客中添加官方提供的 JS 代码。我选择的是国内使用很广的 <a href="http://www.cnzz.com">CNZZ</a>，注册后，添加并验证你的网站就可以添加统计代码了，选好自己喜欢的样式，获得代码，可添加到 <code>source/_includes/custom/footer.html</code> 中。即可查看每天你的博客的流量，进行相应的优化了。</p>

<pre><code>&lt;script type="text/javascript"&gt;var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1255930196'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1255930196%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));&lt;/script&gt;
</code></pre>

<h3>添加多说评论</h3>

<p>Octopress默认自带了 <code>DISQUS</code> ，但是对于国内不是很好用，于是选择了多说作为评论插件，这个还是很接地气的。多说官网账号无需注册，我是使用的百度账号来进行设置，添加站点，获取站点 <code>short_name</code>。这个</p>

<p>在配置文件 <code>_config.yml</code> 中，添加以下代码：</p>

<pre><code>duoshuo_comments: true
duoshuo_short_name: yoursite (多说二级域名 yoursite.duoshuo.com)(yoursite是你在多说中添加的站点名称)
</code></pre>

<p>在 <code>source/_layouts/post.html</code> 中 <code>disqus</code> 代码下方添加<a href="https://github.com/swplzj/swplzj.github.io/blob/source/source/_layouts/post.html">多说代码本想粘贴出代码，但是一直显示不全只能留源文件地址了。</a></p>

<p>然后，在路径 <code>source/_includes/post</code>下创建一个 <code>duoshuo.html</code>, <a href="https://github.com/swplzj/swplzj.github.io/blob/source/source/_includes/post/duoshuo.html">直接上文件地址</a></p>

<p>到此为止，添加多说评论完成。</p>

<h3>添加七牛云存储作为图床</h3>

<p>博客其实已经可以正常发布博文，展示，数据统计，评论，归档等功能了，但是一直有个特殊情景，在困扰着我，假如我想发布一篇博文，博文中包含很多图片，大家都知道在 Markdown 语言中添加一张图片，是很简单的，直接使用语法，发一个图片地址就可以了。但是这个图片放到本地，然后随博客同步到 GitHub 上的话，就会造成两个主要问题，第一，在国内由于网络问题，加载图片特别缓慢；第二，GitHub 免费存储是固定的，用来当做图床，不是明智之举，鉴于此，就寻找国内比较稳定优秀的图床。最终选择了七牛云存储，优点：访问速度极快，支持日志、防盗链和水印。然后有了图床，就解决了图片存储的问题，流程就是，先把博文中所要使用的图片，先上传到七牛上，然后拿到获取此资源的链接，写到博文中，就可以了。</p>

<h3>自动为图片添加url前缀</h3>

<p>我把图片资源都放在了七牛云存储上，写博客时候就是用七牛的外链。但是这样有几个问题：
每次写博客插入图片外链地址时候都很麻烦，需要给每张图片都添加七牛外链地址url前缀；
如果以后更换了存储，那就麻烦了，需要依次编辑替换每个图片的url前缀
现在我们就使用一种灵活的方式来配置并自动生成图片的url前缀：</p>

<p>1.修改 <code>/plugins/image_tag.rb</code> 文件，在</p>

<pre><code>@img['class'].gsub!(/"/, '') if @img['class']
</code></pre>

<p>后添加下面一行代码：</p>

<pre><code>@img['src'] = Jekyll.configuration({})['static_file_prefix'] + @img['src'] if @img['src'][0] == '/'
</code></pre>

<p>2.再修改根目录下的 <code>_config.yml</code> 文件，添加如下配置：</p>

<pre><code>static_file_prefix: http://7u2i08.com1.z0.glb.clouddn.com
</code></pre>

<p>这样在生成文章的时候，以 <code>/</code> 开头的图片会自动加上 <code>http://7u2i08.com1.z0.glb.clouddn.com</code> 前缀。</p>

<p>3.我们在插入图片的时候要记住不能再使用 Markdown 语法来写了，要使用 Ocotpress 自定义的 <code>Image Tag</code> 来插入图片。</p>

<p>4.使用 <a href="http://developer.qiniu.com/docs/v6/tools/qrsync.html"><code>qrsync</code></a> 同步图片资源。<code>qrsync</code> 是一个根据七牛云存储API实现的简易命令行辅助上传同步工具，支持断点续上传，增量同步，它可将用户本地的某目录的文件同步到七牛云存储中，同步或上传几百GB甚至上TB的文件毫无鸭梨。
下载对应的命令行辅助同步工具，我使用的Mac，下载完成后，解压出命令执行文件，放到 <code>/usr/local/bin</code> 目录下。</p>

<p>5.创建一个配置文件（<a href="http://json.org/json-zh.html">JSON格式</a>）,可以命名为 <code>qrsync.json</code>,输入以下配置</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>{
</span><span class='line'>  "debug_level" : 1,
</span><span class='line'>  "deletable" : 0,
</span><span class='line'>  "dest" : "qiniu:access_key=yourAccessKey&secret_key=yourSecretKey&bucket=yourSpaceName",
</span><span class='line'>  "src" : "/Users/yourname/octopress/source/images"
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>其中，<code>AccessKey</code> 和 <code>SecretKey</code> 就是之前咱们在七牛云存储平台上申请的。如图所示：</p>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_03_qi_niu_key.png"></p>

<table>
<thead>
<tr>
<th>参数              </th>
<th> 备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>debug_level     </td>
<td>  日志输出等级（通常设置1，只输出必要的日志）</td>
</tr>
<tr>
<td>deletable       </td>
<td> 是否同步删除七牛云上的文件（通常设置0，当本地文件删除时并不删除存储在七牛的对应文件）</td>
</tr>
<tr>
<td>src             </td>
<td> 本地源目录路径（本地需要同步上传目录的完整的绝对路径）</td>
</tr>
<tr>
<td>bucket          </td>
<td> 目标空间名称</td>
</tr>
</tbody>
</table>


<p>这样就可以使用七牛的资源同步辅助命令了。
本地预览先 <code>rake generate</code> 后 <code>rake preview</code> ，这样插入图片就灵活方便多了。</p>

<p><code>注意1</code></p>

<p>在 <code>rake generate</code> 时，我这里遇到一个错误，报错如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Configuration file: /Users/lizhenjie/octopress/_config.yml
</span><span class='line'>  Liquid Exception: undefined method `+' for nil:NilClass in _posts/2015-07-30-test.markdown/#excerpt
</span><span class='line'>jekyll 2.5.3 | Error:  undefined method `+' for nil:NilClass</span></code></pre></td></tr></table></div></figure>


<p>经过搜索，发现如果要把两个字符串连接在一起。如</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a = “abc”
</span><span class='line'>b = a + “de”</span></code></pre></td></tr></table></div></figure>


<p>此时b的值为 <code>abcde</code>
但如果 <code>a = nil</code> 时，就会抛出未定义“+”的异常，因为此时a为nil。仔细检查发现修改完 <code>/plugins/image_tag.rb</code> 文件后，没有做保存，没有关闭文件，造成的问题，还好我没有放弃，O(∩_∩)O哈哈~</p>

<p><code>注意2</code></p>

<p>我们在插入图片的时候要记住不能再使用 Markdown 语法来写了，要使用 Ocotpress 自定义的 <a href="http://octopress.org/docs/plugins/image-tag/">Image Tag</a> 来插入图片。
然后在发布博文之前，先同步自己的图片，</p>

<pre><code>qrsync qrsync.json 
</code></pre>

<p>然后，生成博文，发布博文</p>

<pre><code>rake generate
rake deploy
</code></pre>

<h3>写在最后</h3>

<p>终于大功告成，通过设置博客，也看到了很多优秀的博客，也看到自己与优秀极客的差距，这也更加坚定了我写博客，记录自己学习的点点滴滴的决心。希望能帮助到你们。有什么问题可以反馈。 Have fun！</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[iOS - UIWebView 动态载入/删除/更新外部 JavaScript/CSS 文件]]></title>
        <link href="http://swplzj.github.io/blog/2015/03/12/ios-uiwebview-dong-tai-zai-ru-slash-shan-chu-slash-geng-xin-wai-bu-javascript-slash-css-wen-jian/"/>
        <updated>2015-03-12T19:59:54+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/03/12/ios-uiwebview-dong-tai-zai-ru-slash-shan-chu-slash-geng-xin-wai-bu-javascript-slash-css-wen-jian</id>
        <content type="html"><![CDATA[<h5>动态载入 JavaScript/CSS 文件</h5>

<p>传统加载外部 <code>JavaScript(*.js)</code> 或者 <code>CSS(*.css)</code> 文件的方法是直接在 <code>&lt;head&gt;</code> 标签里面进行添加:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;head&gt; 
</span><span class='line'>&lt;script type="text/javascript" src="myscript.js"&gt;&lt;/script&gt; 
</span><span class='line'>&lt;link rel="stylesheet" type="text/css" href="main.css" /&gt; 
</span><span class='line'>&lt;/head&gt; </span></code></pre></td></tr></table></div></figure>




<!--more-->


<p>这些文件用这种方式会同步加载到当前这个页面。</p>

<h5>用动态的方式载入 JavaScript/CSS 文件：</h5>

<p>用 DOM createElement 方法创建一个 “script” 或者 ”link” 元素
设置相应的属性
使用 appendChild 方法, 把创建的元素插入到 head 标签的末尾</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function loadjscssfile(filename, filetype){ 
</span><span class='line'>//如果文件类型为 .js ,则创建 script 标签，并设置相应属性 
</span><span class='line'>if (filetype=="js"){ 
</span><span class='line'>var fileref=document.createElement('script'); 
</span><span class='line'>fileref.setAttribute("type","text/javascript"); 
</span><span class='line'>fileref.setAttribute("src", filename); 
</span><span class='line'>} 
</span><span class='line'>//如果文件类型为 .css ,则创建 script 标签，并设置相应属性 
</span><span class='line'>else if (filetype=="css"){ 
</span><span class='line'>var fileref=document.createElement("link"); 
</span><span class='line'>fileref.setAttribute("rel", "stylesheet"); 
</span><span class='line'>fileref.setAttribute("type", "text/css"); 
</span><span class='line'>fileref.setAttribute("href", filename); 
</span><span class='line'>} 
</span><span class='line'>if (typeof fileref!="undefined") 
</span><span class='line'>document.getElementsByTagName("head")[0].appendChild(fileref); 
</span><span class='line'>} 
</span><span class='line'>//动态添加一个.js 文件 
</span><span class='line'>loadjscssfile("myscript.js", "js"); 
</span><span class='line'>//像添加.js文件一样，动态添加一个.php文件 
</span><span class='line'>loadjscssfile("javascript.php", "js"); 
</span><span class='line'>//动态一个.css文件 
</span><span class='line'>loadjscssfile("mystyle.css", "css"); </span></code></pre></td></tr></table></div></figure>


<h5>为了防止多次载入同一个js/css文件， 添加以下判断（这只是粗略检测）</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//临时载入的文件名 
</span><span class='line'>var filesadded=""; 
</span><span class='line'>function checkloadjscssfile(filename, filetype){ 
</span><span class='line'>if (filesadded.indexOf("["+filename+"]")==-1){ 
</span><span class='line'>loadjscssfile(filename, filetype); 
</span><span class='line'>//把 [filename] 存入 filesadded 
</span><span class='line'>filesadded+="["+filename+"]"; 
</span><span class='line'>} 
</span><span class='line'>else{ 
</span><span class='line'>alert("file already added!"); 
</span><span class='line'>} 
</span><span class='line'>//第一次载入 
</span><span class='line'>checkloadjscssfile("myscript.js", "js"); 
</span><span class='line'>//重复载入同一个文件， 失败 
</span><span class='line'>checkloadjscssfile("myscript.js", "js"); </span></code></pre></td></tr></table></div></figure>


<h5>动态删除 JavaScript/Csss 文件</h5>

<p>注意：ie6/7 下动态删除样式时有bug. 2种解决方案：1.样式表里不要有import的样式表 2.把link的type属性设置为空值， 然后再修改 href 的地， 或者直接设置href为空， 最后再把type值设置成”text/css” 强制让ie解释新的样式表。</p>

<p>取得相应的 DOM 元素
根据 文件名&amp;文件类型 定位元素
用 DOM removeChild 删除一个 “script” 或者 ”link” 元素</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function removejscssfile(filename, filetype){ 
</span><span class='line'>//判断文件类型 
</span><span class='line'>var targetelement=(filetype=="js")? "script" : (filetype=="css")? "link" : "none"; 
</span><span class='line'>//判断文件名 
</span><span class='line'>var targetattr=(filetype=="js")? "src" : (filetype=="css")? "href" : "none"; 
</span><span class='line'>var allsuspects=document.getElementsByTagName(targetelement); 
</span><span class='line'>//遍历元素， 并删除匹配的元素 
</span><span class='line'>for (var i=allsuspects.length; i&gt;=0; i--){ 
</span><span class='line'>if (allsuspects[i] && allsuspects[i].getAttribute(targetattr)!=null && allsuspects[i].getAttribute(targetattr).indexOf(filename)!=-1) 
</span><span class='line'>allsuspects[i].parentNode.removeChild(allsuspects[i]); 
</span><span class='line'>} 
</span><span class='line'>} 
</span><span class='line'>removejscssfile("somescript.js", "js"); 
</span><span class='line'>removejscssfile("somestyle.css", "css"); </span></code></pre></td></tr></table></div></figure>


<h5>动态更新 JavaScript/Csss 文件</h5>

<p>使用 createElement 创建 要更新的 JavaScript/Css 元素
查找要被替换的元素
用 replaceChild 替换元素</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function createjscssfile(filename, filetype){ 
</span><span class='line'>if (filetype=="js"){ //if filename is a external JavaScript file 
</span><span class='line'>var fileref=document.createElement('script') 
</span><span class='line'>fileref.setAttribute("type","text/javascript") 
</span><span class='line'>fileref.setAttribute("src", filename) 
</span><span class='line'>} 
</span><span class='line'>else if (filetype=="css"){ //if filename is an external CSS file 
</span><span class='line'>var fileref=document.createElement("link") 
</span><span class='line'>fileref.setAttribute("rel", "stylesheet") 
</span><span class='line'>fileref.setAttribute("type", "text/css") 
</span><span class='line'>fileref.setAttribute("href", filename) 
</span><span class='line'>} 
</span><span class='line'>return fileref 
</span><span class='line'>} 
</span><span class='line'>
</span><span class='line'>function replacejscssfile(oldfilename, newfilename, filetype){ 
</span><span class='line'>var targetelement=(filetype=="js")? "script" : (filetype=="css")? "link" : "none"; 
</span><span class='line'>var targetattr=(filetype=="js")? "src" : (filetype=="css")? "href" : "none"; 
</span><span class='line'>var allsuspects=document.getElementsByTagName(targetelement); 
</span><span class='line'>for (var i=allsuspects.length; i&gt;=0; i--){ 
</span><span class='line'>if (allsuspects[i] && allsuspects[i].getAttribute(targetattr)!=null && allsuspects[i].getAttribute(targetattr).indexOf(oldfilename)!=-1){ 
</span><span class='line'>var newelement=createjscssfile(newfilename, filetype); 
</span><span class='line'>allsuspects[i].parentNode.replaceChild(newelement, allsuspects[i]); 
</span><span class='line'>} 
</span><span class='line'>} 
</span><span class='line'>} 
</span><span class='line'>//用 "newscript.js" 替换 "oldscript.js" 
</span><span class='line'>replacejscssfile("oldscript.js", "newscript.js", "js")； 
</span><span class='line'>//用 "newscript.css" 替换 "oldscript.css" 
</span><span class='line'>replacejscssfile("oldstyle.css", "newscript.css","css"); </span></code></pre></td></tr></table></div></figure>

]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Mac翻墙技巧]]></title>
        <link href="http://swplzj.github.io/blog/2015/03/08/macfan-qiang-ji-qiao/"/>
        <updated>2015-03-08T10:57:41+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/03/08/macfan-qiang-ji-qiao</id>
        <content type="html"><![CDATA[<h4>困扰</h4>

<p>自己一直在寻找Mac上的免费翻墙工具，尝试过很多，但最终都没办法实现，对自己也造成了一些影响，比如需要在国外网站查询一些资料，下载一些应用，观看Youtube视频，刷Facebook，最要命的就是最近自己的Gmail也收不到邮件了，不想购买VPN，那只能尝试找免费翻墙工具了。</p>

<p>终于找到免费翻墙的工具了</p>

<p>不敢独享，故贴出来和大家分享一下。</p>

<!--more-->


<h4>终于等到你，还好我没放弃</h4>

<h5>这种翻墙方法的优点：</h5>

<ul>
<li>免费</li>
<li>无需下载任何软件</li>
<li>配置门槛低，简单</li>
</ul>


<h5>工具使用方法</h5>

<p><code>工具网址</code></p>

<p>首先打开网站：<a href="http://vcup.in/nyve">VPNCUP</a></p>

<p><code>使用方法</code></p>

<h6>注册账号</h6>

<p>在这个网站上注册一个账号。</p>

<h6>设置VPN登录密码</h6>

<p>因为在配置网络的时候，都会使用到VPN的登录密码来进行验证，这个密码不是你的账号登录密码，你需要在我的账户里面来开启，并进行设置。</p>

<p>1、进入<code>我的账户</code>中的<code>VPN账户</code>;</p>

<p>2、将<code>VPN账户状态</code>设置为<code>开放</code>;</p>

<p>3、设置<code>VPN登录密码</code>;</p>

<h6>配置电脑网络设置</h6>

<p>关于如何配置电脑的网络设置，在官网有详细的说明，下面给出相应的链接，大家跟着说明一步步做就好了</p>

<ul>
<li><a href="https://www.vcup136.com/config/windows-xp">Windows XP设置登录VPN服务器图文介绍</a></li>
<li><a href="https://www.vcup136.com/config/iphone-l2tp">Apple Iphone和Apple iTouch设置登录VPN服务器图文介绍(L2TP模式)</a></li>
<li><a href="https://www.vcup136.com/config/iphone">Apple Iphone和Apple iTouch设置登录VPN服务器图文介绍(PPTP模式)</a></li>
<li><a href="https://www.vcup136.com/config/macosx">mac系统下的配置指南</a></li>
<li><a href="https://www.vcup136.com/config/ubuntu">Ubuntu设置VPN</a></li>
<li><a href="https://www.vcup136.com/config/windows">windows系统下的配置指南</a></li>
<li><a href="https://www.vcup136.com/config/android">Android系统设置VPN</a></li>
</ul>


<h4>总结</h4>

<p>设置完成了，大家可以享受墙外的世界了，希望能帮助到你。</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[面向 iOS 开发的优秀 XCode 插件]]></title>
        <link href="http://swplzj.github.io/blog/2015/02/13/mian-xiang-ios-kai-fa-de-you-xiu-xcode-cha-jian/"/>
        <updated>2015-02-13T21:05:50+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/02/13/mian-xiang-ios-kai-fa-de-you-xiu-xcode-cha-jian</id>
        <content type="html"><![CDATA[<p>一套理想的插件架构几乎能够决定整个集成开发环境的差异与特性。Sublime Text与TextMate就是很好的实例。但大家可能不了解的是，Xcode也支持插件。哈哈，如果各位真的前所未闻，我也不会感到惊讶，毕竟苹果并没有把太多精力用在Xcode的宣传之上。事实上，我们几乎找不到多少用于指导Xcode创建的说明文档。</p>

<p>幸运的是，这并没有妨碍开发人员在Xcode这片土地上耕耘并构建自己的插件果实。目前市面上存在大量插件，能够让我们的Xcode使用之旅更加平坦也更富乐趣，甚至足以弥合苹果在其中留下的所有沟壑。在今天的文章中，我将向大家展示自己在日常工作中频繁用到的几款优秀插件。</p>

<!--more-->


<h5>Alcatraz</h5>

<p>过去，安装Xcode插件往往令人抓狂不已，但Alcatraz的出现彻底改写了这一历史。今年早些时候，Alcatraz迎来了发展道路上的里程碑——1.0版本，现在如今已经可以与Xcode 5相兼容。如果大家还没有安装Alcatraz，我建议大家首先完成这项工作。</p>

<p>官方网站：<a href="http://alcatraz.io/">http://alcatraz.io/</a></p>

<h5>XToDo</h5>

<p>这款插件不仅能够着力强调TODO、FIXME、？？？以及！！！注释，同时可以按住 control + T 可以快速查看专用列表，并且可以自定义一些标签。</p>

<p><img src="http://s9.51cto.com/wyfs02/M00/46/84/wKioL1Pyvc2iUbyMAABLbcwVzmM494.jpg" alt="id1" /></p>

<p>官方网站：<a href="https://github.com/trawor/XToDo">https://github.com/trawor/XToDo</a></p>

<h5>Dash for Xcode</h5>

<p>Dash是一款用于浏览文档的优秀软件，我每天都会反复加以运用。更让人喜出望外的是，它现在已经与Xcode相集成，这要归功于其Xcode插件。大家可能知道，我们可以在Xcode编辑器中按住Option键同时点击以直接前往对应文档。不过我对于Xcode自带来的文档浏览器评价不高，在这种情况下Dash插件就成了最理想的解决方案。</p>

<p><img src="http://s2.51cto.com/wyfs02/M00/46/83/wKiom1PyvYOBTuZFAACLZqMVukQ768.jpg" alt="id2" /></p>

<p>该插件能够在我们按住Option并点击对应文档后利用Dash而非Xcode自带文档浏览器将其打开。Dash不仅运行速度极快，同时还能与CocoaDocs相集成。举例来说，如果大家用这种方式点击AFNetworking库中的一个方法，那么Dash将显示出该方法的说明文档。我超爱这项功能。</p>

<p>官方网站：<a href="http://kapeli.com/dash">http://kapeli.com/dash</a></p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[即时通讯类移动APP开发要点]]></title>
        <link href="http://swplzj.github.io/blog/2015/02/06/ji-shi-tong-xun-lei-yi-dong-appkai-fa-yao-dian/"/>
        <updated>2015-02-06T16:05:06+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/02/06/ji-shi-tong-xun-lei-yi-dong-appkai-fa-yao-dian</id>
        <content type="html"><![CDATA[<p>即时通讯（IM）软件作为满足人们沟通需求的工具，十几年来一直长盛不衰，并随着移动时代的到来迎来了新的增长。如在国内广泛使用的微信，在北美广泛使用的Whatsapp、Kik，在亚洲广泛使用的Line、KakaoTalk。另外还有其他一些以独特视角切入移动IM市场的APP，主打阅后即焚、私密消息等。</p>

<p>试着从技术的角度来总结这一类应用的开发要点，或者说是相比桌面版的IM软件，移动IM应用开发需要注意的地方，欢迎指正和补充。</p>

<!--more-->


<h5>网络</h5>

<h6>移动APP经常随着移动设备在不同的网络之间切换，所以处理好网络切换、断网、重连就至关重要。</h6>

<p>解决这个问题的办法，就是要求移动APP能以尽量少的通讯量、尽快的速度重新注册服务器。</p>

<p>比如不再从服务器获取配置信息、联系人信息和联系人状态等。</p>

<p>但是如果这段时间服务器端有变化发生，就需要服务器有推送变化信息的能力。</p>

<p>同时，服务器对客户端重连间隔要保持宽容态度，不要因为客户端在给定的较短时间内没有重连上就移除这个会话。要知道，在移动环境下，客户端断掉连接只是不得已，一有机会，它就会努力重连上来的。</p>

<p>另外，由于网络的不稳定性，消息的发送方和接受方一定要有确认机制，不管这种确认机制是端对端的的还是通过服务器中转，以避免客户端突然掉线，而服务器还未及时知晓的情况。</p>

<h5>电池</h5>

<h6>移动APP必须尽量减少电池的消耗。</h6>

<p>以iOS为例，它以三个规则来强制APP最小化电池消耗：</p>

<ol>
<li><p>APP在后台是不能主动运行的，特定功能的APP可以设置timer唤醒，但最频繁也只能每10分钟运行若干秒。</p></li>
<li><p>APP在后台被唤醒的次数有严格限制，不能在300秒内被唤醒超过15次，否则被系统终止。</p></li>
<li><p>APP即使申请后台任务，最多也只有60秒的运行时间。</p></li>
</ol>


<p>满足这些要求的最好办法，就是不要试图让移动IM应用在后台运行。而把网络监听这样的任务，在APP进入后台的时候转交给iOS系统来完成。</p>

<p>而服务器则要有灵活的过滤机制，不管是主动还是被动的，过滤掉绝大多数试图发给客户端的网络通讯，以保持客户端睡眠的状态。而仅仅把必要的信息，如即时消息，推送给客户端。</p>

<h5>内存</h5>

<h6>移动APP要尽量减少内存消耗。</h6>

<p>以iOS为例，系统会保持尽可能多的APP在内存中，但是内存不足时它就会终止已被挂起的APP来回收内存。这种情况下，首先被回收的就是占内存多的后台APP。</p>

<p>解决这个问题的一个办法，就是在内存消耗较多的模块，通常是模型层的组件，提供持久化机制。当APP切换到后台的时候保存大多数暂时不会用到的数据到文件系统，等回到前台的时候再重建这些数据结构。</p>

<p>比如所有联系人的详细信息就适合这么做。</p>

<h5>系统资源</h5>

<h6>移动APP要尽量减少对系统资源的占有。</h6>

<p>应该以最少使用时间为原则来使用系统资源，以iOS为例，在APP切换到后台之前就要放弃对地址簿的访问。</p>

<h5>后台运行</h5>

<p>以上几点都跟APP在后台运行有关，其实这也是移动IM应用的一大特点。所谓养兵千日、用兵一时，移动IM应用绝大多数时间都躺在后台，所以处理好后台运行就处理好了移动IM应用的大部分。</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[valueForKeyPath的使用总结]]></title>
        <link href="http://swplzj.github.io/blog/2015/01/16/valueforkeypathde-shi-yong-zong-jie/"/>
        <updated>2015-01-16T21:10:46+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/01/16/valueforkeypathde-shi-yong-zong-jie</id>
        <content type="html"><![CDATA[<p>可能大家对- (id)valueForKeyPath:(NSString *)keyPath方法不是很了解。
其实这个方法非常的强大，具体有以下几个功能:</p>

<h5>对数组中的每个元素执行成员实例方法</h5>

<!--more-->




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSArray *array = @[@"name", @"w", @"aa", @"jimsa"];
</span><span class='line'>NSLog(@"%@", [array valueForKeyPath:@"uppercaseString"]);</span></code></pre></td></tr></table></div></figure>


<p>输出</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(
</span><span class='line'>    NAME,
</span><span class='line'>    W,
</span><span class='line'>    AA,
</span><span class='line'>    JIMSA
</span><span class='line'>)</span></code></pre></td></tr></table></div></figure>


<p>相当于数组中的每个成员执行了uppercaseString方法，然后把返回的对象组成一个新数组返回。既然可以用uppercaseString方法，那么NSString的其他方法也可以，比如</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[array valueForKeyPath:@"length"]</span></code></pre></td></tr></table></div></figure>


<p>返回每个字符串长度的组成的数组。只要你能想到的成员实例方法都可以这么用。</p>

<h5>对NSNumber数组快速计算数组求和、平均数、最大值、最小值</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSArray *array = @[@1, @2, @3, @4, @10];
</span><span class='line'>NSNumber *sum = [array valueForKeyPath:@"@sum.self"];
</span><span class='line'>NSNumber *avg = [array valueForKeyPath:@"@avg.self"];
</span><span class='line'>NSNumber *max = [array valueForKeyPath:@"@max.self"];
</span><span class='line'>NSNumber *min = [array valueForKeyPath:@"@min.self"];</span></code></pre></td></tr></table></div></figure>


<p></p>

<h5>或者指定输出类型</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSNumber *sum = [array valueForKeyPath:@"@sum.floatValue"];
</span><span class='line'>NSNumber *avg = [array valueForKeyPath:@"@avg.floatValue"];
</span><span class='line'>NSNumber *max = [array valueForKeyPath:@"@max.floatValue"];
</span><span class='line'>NSNumber *min = [array valueForKeyPath:@"@min.floatValue"];</span></code></pre></td></tr></table></div></figure>


<h5>剔除重复数据</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSArray *array = @[@"name", @"w", @"aa", @"jimsa", @"aa"];
</span><span class='line'>NSLog(@"%@", [array valueForKeyPath:@"@distinctUnionOfObjects.self"]);</span></code></pre></td></tr></table></div></figure>


<p>打印</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(
</span><span class='line'>name,
</span><span class='line'>w,
</span><span class='line'>jimsa,
</span><span class='line'>aa
</span><span class='line'>)</span></code></pre></td></tr></table></div></figure>


<h5>对NSDictionary数组快速找出相应key对的值</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSArray *array = @[@{@"name" : @"cookeee",@"code" : @1},
</span><span class='line'>                           @{@"name": @"jim",@"code" : @2},
</span><span class='line'>                           @{@"name": @"jim",@"code" : @1},
</span><span class='line'>                           @{@"name": @"jbos",@"code" : @1}];
</span><span class='line'>NSLog(@"%@", [array valueForKeyPath:@"name"]);</span></code></pre></td></tr></table></div></figure>


<p>直接得到字典中namekey对应的值组成的数组，显然比循环取值再加入到新数组中方便快捷</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(
</span><span class='line'>    cookeee,
</span><span class='line'>    jim,
</span><span class='line'>    jim,
</span><span class='line'>    jbos
</span><span class='line'>)</span></code></pre></td></tr></table></div></figure>


<p>同样可以嵌套使用，先剔除name对应值的重复数据再取值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> NSArray *array = @[@{@"name" : @"cookeee",@"code" : @1},
</span><span class='line'>                           @{@"name": @"jim",@"code" : @2},
</span><span class='line'>                           @{@"name": @"jim",@"code" : @1},
</span><span class='line'>                           @{@"name": @"jbos",@"code" : @1}];
</span><span class='line'>
</span><span class='line'>NSLog(@"%@", [array valueForKeyPath:@"@distinctUnionOfObjects.name"]);</span></code></pre></td></tr></table></div></figure>


<p>打印</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(
</span><span class='line'>cookeee,
</span><span class='line'>jim,
</span><span class='line'>jbos
</span><span class='line'>)</span></code></pre></td></tr></table></div></figure>


<h5>改变UITextfiedl的placeholder的颜色</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[searchField setValue:[UIColor whiteColor] forKeyPath:@"_placeholderLabel.textColor"];</span></code></pre></td></tr></table></div></figure>


<p>比起重写</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)drawPlaceholderInRect:(CGRect)rect;</span></code></pre></td></tr></table></div></figure>


<p>要方便很多</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Objective-C中的Selector和SEL]]></title>
        <link href="http://swplzj.github.io/blog/2015/01/07/objective-czhong-de-selectorhe-sel/"/>
        <updated>2015-01-07T10:32:05+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/01/07/objective-czhong-de-selectorhe-sel</id>
        <content type="html"><![CDATA[<h4>Objective-C中Selector基本概念和操作</h4>

<p>简而言之，你可以理解 @selector()就是取类方法的编号,他的行为基本可以等同C语言的中函数指针,只不过C语言中，可以把函数名直接赋给一个函数指针，而Objective-C的类不能直接应用函数指针，这样只能做一个@selector语法来取.</p>

<!--more-->


<p></p>

<p>它的结果是一个SEL类型。这个类型本质是类方法的编号(函数地址)?因此我们有如下代码。</p>

<h5>一、取得selector值.</h5>

<p>C函数指针</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int add(int val)  
</span><span class='line'>{  
</span><span class='line'>  return val+1;  
</span><span class='line'>}  
</span><span class='line'>int (* c_func)(int val); //定义一个函数指针变量  
</span><span class='line'>_func = add ;  //把函数addr地址直接赋给c_func </span></code></pre></td></tr></table></div></figure>


<p>Objective-C的选择器,</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface foo  
</span><span class='line'>-(int)add:int val;  
</span><span class='line'>@end  
</span><span class='line'> 
</span><span class='line'>SEL class_func ; //定义一个类方法指针  
</span><span class='line'>class_func = @selector(add:int); </span></code></pre></td></tr></table></div></figure>


<p><code>注意:</code></p>

<ol>
<li>@selector是查找当前类的方法，而[object @selector(方法名:方法参数..) ] ;是取object对应类的相庆方法;</li>
<li>查找类方法时，除了方法名,方法参数也查询条件之一.</li>
<li>可以用字符串来找方法 SEL　变量名　=　NSSelectorFromString(方法名字的字符串);</li>
<li>可以运行中用SEL变量反向查出方法名字字符串</li>
</ol>


<p>NSString　*变量名　=　NSStringFromSelector(SEL参数);</p>

<h5>二、执行selector值.</h5>

<p>取得相庆值后，怎么处理SEL值呢，这一点仍然与函数指针一样，就是执行它</p>

<p>函数指针执行，（以下有几种等效形式）</p>

<ul>
<li>*c_func(10);</li>
<li>c_func(10);</li>
<li>SEL变量的执行.用performSelecor方法来执行.</li>
<li>[对象　performSelector:SEL变量　withObject:参数1　withObject:参数2];</li>
</ul>


<h5>三.selector的应用场合</h5>

<p>selector本质是跟C的回调函数一样。主要用于两个对象之间进行松耦合的通讯.这种方法很多开发环境用到。比如GTK，Delphi.基本上整个Cocoa库之间对象，控制之间通讯都是在这个基础构建的。</p>

<h4>SEL</h4>

<p>在Objective-C中，SEL是选择器（selector）的一个类型。选择器就是指向方法的一个指针，读者可以简单理解为程序运行到这里就会执行指定的方法，可以这样定义一个选择器：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SEL action = [button action]; </span></code></pre></td></tr></table></div></figure>


<p>我们这样使用一个选择器，下面的选择器都叫做action：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[Foo action]  
</span><span class='line'>[Bar action] </span></code></pre></td></tr></table></div></figure>


<p>在Target-Action 模式（Cocoa 程序中的一种常用模式）中：Target 指定了一个类，Action指定一个方法。在一个对象上设置Action就是通过选择器完成的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-（void）setTarget:（id）target;  
</span><span class='line'>-（void）setAction:（SEL）action; </span></code></pre></td></tr></table></div></figure>


<p>下述语句设置了一个button对象上的Action为“@selector（start:）”，即它调用start方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[button setAction:@selector（start:）]; </span></code></pre></td></tr></table></div></figure>


<p>如果你的方法上有两个参数，比如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-（void）setName:（NSString *）name age:（int）age; </span></code></pre></td></tr></table></div></figure>


<p>那么，你的选择器应该这样书写：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SEL sel = @selector（setName:age:）; </span></code></pre></td></tr></table></div></figure>


<p>如果方法不存在的话，调用该方法的应用可能会异常中止。所以，需要使用respondsToSelector 方法来判断该对象是否存在对应的方法，使用performSelector:withObject:方法来调用选择器：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SEL sel = @selector (start:) ; // 指定action  
</span><span class='line'>if ([obj respondsToSelector:sel]) { //判断该对象是否有相应的方法  
</span><span class='line'>[obj performSelector:sel withObject:self]; //调用选择器方法  
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>下面来看一个应用选择器的实例。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import &lt;Foundation/Foundation.h&gt; 
</span><span class='line'>@interface ClassA : NSObject {  
</span><span class='line'>}  
</span><span class='line'>- (void) print;  
</span><span class='line'>@end  
</span><span class='line'>@implementation ClassA  
</span><span class='line'>- (void) print{  
</span><span class='line'>NSLog (@"I'm ClassA.") ;  
</span><span class='line'>}  
</span><span class='line'>@end  
</span><span class='line'>int main (int argc, const char * argv[]) {  
</span><span class='line'>NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];  
</span><span class='line'>SEL sel = @selector (print) ;  
</span><span class='line'>ClassA *classA = [[ClassA alloc]init];  
</span><span class='line'>[classA performSelector:sel withObject:nil]; //调用选择器指定的方法  
</span><span class='line'>[pool drain];  
</span><span class='line'>return 0;  
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>【程序结果】</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>I'm ClassA. </span></code></pre></td></tr></table></div></figure>


<p>下面解释一下这段代码，读者有可能看不明白，因为到目前为止并没有讲述类相关的知识。读者只需要了解上述例子中选择器的用法即可，关于类的知识，会在后面的章节详细阐述。</p>

<p>代码首先创建了一个名字叫ClassA 的类，它只包含一个方法print。在随后的实现文件中，我们实现了这个方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void) print{  
</span><span class='line'>NSLog (@"I'm ClassA.") ;  
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>读者不难看出，这个方法仅仅是打印到控制台上一句话。在接下来的main方法中，定义了一个选择器sel，它指向的是一个名叫print 的方法。我们并不知道这个方法是哪个类的，因为具体的信息是在运行期间系统自动帮我们判断的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SEL sel = @selector (print) ; </span></code></pre></td></tr></table></div></figure>


<p>随后构建了一个对象（读者不用拘泥于语法，我们会在后面的章节详细阐述），并调用这个对象performSelector:withObject:的方法。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ClassA *classA = [[ClassA alloc]init];  
</span><span class='line'>[classA performSelector:sel withObject:nil]; </span></code></pre></td></tr></table></div></figure>


<p>这时候，系统就会自动调用classA对象的print方法，最终得到程序运行结果。</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[使用神奇的PONYDEBUGGER调试iOS应用]]></title>
        <link href="http://swplzj.github.io/blog/2014/12/14/shi-yong-shen-qi-de-ponydebugger-tiao-shi-ios-ying-yong/"/>
        <updated>2014-12-14T17:30:40+08:00</updated>
        <id>http://swplzj.github.io/blog/2014/12/14/shi-yong-shen-qi-de-ponydebugger-tiao-shi-ios-ying-yong</id>
        <content type="html"><![CDATA[<h3>前言</h3>

<p>Debug算是开发者的基本技能之一吧，对于iOS开发者而言，可能会遇到如下一些debug需求：</p>

<p>调试网络请求问题
调试一个层次结构复杂的用户界面
查看应用内Core Data数据变化
虽然你可以通过NSLog日志，打断点，抑或LLDB的调试命令等一些常见手段来解决以上问题，但这些方式始终不够直观，效率也不高，特别是对于调试UI这个需求。要提高效率，我们可以使用一些第三方的调试工具，比如本文要介绍的PonyDebugger。</p>

<!--more-->


<h3>关于PonyDebugger</h3>

<p>PonyDebugger是Square开源的一个远程调试工具包，它可以通过Chrome开发者工具来调试iOS应用的网络流量，数据存储以及用户界面。</p>

<h3>安装和使用</h3>

<h4>服务端安装</h4>

<p>curl -sk <a href="https://cloud.github.com/downloads/square/PonyDebugger/bootstrap-ponyd.py">https://cloud.github.com/downloads/square/PonyDebugger/bootstrap-ponyd.py</a> | \ python - &ndash;ponyd-symlink=/usr/local/bin/ponyd ~/Library/PonyDebugger</p>

<p>安装时遇到的一些坑记录如下：</p>

<p>移动宽带下偶尔出现连接不上pypi的情况，使用电信宽带则正常，移动宽带用户可以改用国内的镜像地址，比如V2EX的pypi镜像<a href="http://pypi.v2ex.com/simple">http://pypi.v2ex.com/simple</a>
服务端依赖pybonjour，但是在zsh终端下使用pip安装会提示找不到这个包，需要手动安装，添加allow-external和allow-unverified
手动安装方法如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>source ~/Library/PonyDebugger/bin/activate
</span><span class='line'>
</span><span class='line'>pip install -U -e git+https://github.com/square/PonyDebugger.git#egg=ponydebugger --allow-external pybonjour --allow-unverified pybonjour
</span><span class='line'>
</span><span class='line'>ponyd update-devtools</span></code></pre></td></tr></table></div></figure>


<h4>客户端安装</h4>

<p>使用CocoaPods，在PodFile中添加以下依赖：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod 'PonyDebugger', '~&gt; 0.3.1'</span></code></pre></td></tr></table></div></figure>


<p>也可以直接指向Github开源地址，这样可以随时使用最新版本的代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod 'PonyDebugger', :git =&gt; 'https://github.com/square/PonyDebugger.git'</span></code></pre></td></tr></table></div></figure>


<h4>使用</h4>

<p>终端输入以下命令启动服务端，然后Chrome打开<a href="http://localhost:9000">http://localhost:9000</a> ，使用开发者工具即可进行调试</p>

<p>ponyd serve &ndash;listen-interface=127.0.0.1</p>

<p>为了便于随时开启和关闭PonyDebugger，客户端在Preprocessor Macros中定义了一个宏ENABLE_PONYDEBUGGER</p>

<p>在AppDeleagate的didFinishLaunchingWithOptions方法中使用如下代码进行一些初始化工作：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#if ENABLE_PONYDEBUGGER
</span><span class='line'>
</span><span class='line'>    PDDebugger *debugger = [PDDebugger defaultInstance];
</span><span class='line'>    
</span><span class='line'>    // Enable Network debugging, and automatically track network traffic that comes through any classes that NSURLConnectionDelegate methods.
</span><span class='line'>    [debugger enableNetworkTrafficDebugging];
</span><span class='line'>    [debugger forwardAllNetworkTraffic];
</span><span class='line'>    
</span><span class='line'>    // Enable Core Data debugging, and broadcast the main managed object context.
</span><span class='line'>    [debugger enableCoreDataDebugging];
</span><span class='line'>    [debugger addManagedObjectContext:self.managedObjectContext withName:@"Twitter Test MOC"];
</span><span class='line'>    
</span><span class='line'>    // Enable View Hierarchy debugging. This will swizzle UIView methods to monitor changes in the hierarchy
</span><span class='line'>    // Choose a few UIView key paths to display as attributes of the dom nodes
</span><span class='line'>    [debugger enableViewHierarchyDebugging];
</span><span class='line'>    [debugger setDisplayedViewAttributeKeyPaths:@[@"frame", @"hidden", @"alpha", @"opaque", @"accessibilityLabel", @"text"]];
</span><span class='line'>    
</span><span class='line'>    // Connect to a specific host
</span><span class='line'>    [debugger connectToURL:[NSURL URLWithString:@"ws://localhost:9000/device"]];
</span><span class='line'>    // Or auto connect via bonjour discovery
</span><span class='line'>    //[debugger autoConnect];
</span><span class='line'>    // Or to a specific ponyd bonjour service
</span><span class='line'>    //[debugger autoConnectToBonjourServiceNamed:@"MY PONY"];
</span><span class='line'>
</span><span class='line'>    // Enable remote logging to the DevTools Console via PDLog()/PDLogObjects().
</span><span class='line'>    [debugger enableRemoteLogging];
</span><span class='line'>    
</span><span class='line'>#endif</span></code></pre></td></tr></table></div></figure>


<p>Chrome看到网页显示如下说明连接成功：</p>

<p><img src="http://ww4.sinaimg.cn/large/674a21d2gw1eemkgp4t9rj216c0ea40f.jpg" alt="id1" /></p>

<p>点击网页中间的应用名即可跳转到debug工具</p>

<h4>实现原理</h4>

<p>简单看了一下PonyDebugger的源码，服务端使用Tornado框架提供WebSocket服务，客户端则是基于Square自家开源的SocketRocket，关于WebSocket相关的知识，可以参考我之前的这篇博文。</p>

<p>网络请求抓包功能是通过注入到NSURLConnectionDelegate中实现的，代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (void)injectIntoAllNSURLConnectionDelegateClasses;
</span><span class='line'>{
</span><span class='line'>    // Only allow swizzling once.
</span><span class='line'>    static BOOL swizzled = NO;
</span><span class='line'>    if (swizzled) {
</span><span class='line'>        return;
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    swizzled = YES;
</span><span class='line'>
</span><span class='line'>    // Swizzle any classes that implement one of these selectors.
</span><span class='line'>    const SEL selectors[] = {
</span><span class='line'>        @selector(connectionDidFinishLoading:),
</span><span class='line'>        @selector(connection:didReceiveResponse:)
</span><span class='line'>    };
</span><span class='line'>    
</span><span class='line'>    const int numSelectors = sizeof(selectors) / sizeof(SEL);
</span><span class='line'>
</span><span class='line'>    Class *classes = NULL;
</span><span class='line'>    NSInteger numClasses = objc_getClassList(NULL, 0);
</span><span class='line'>    
</span><span class='line'>    if (numClasses &gt; 0) {
</span><span class='line'>        classes = (__unsafe_unretained Class *)malloc(sizeof(Class) * numClasses);
</span><span class='line'>        numClasses = objc_getClassList(classes, numClasses);
</span><span class='line'>        for (NSInteger classIndex = 0; classIndex &lt; numClasses; ++classIndex) {
</span><span class='line'>            Class class = classes[classIndex];
</span><span class='line'>            
</span><span class='line'>            if (class_getClassMethod(class, @selector(isSubclassOfClass:)) == NULL) {
</span><span class='line'>                continue;
</span><span class='line'>            }
</span><span class='line'>            
</span><span class='line'>            if (![class isSubclassOfClass:[NSObject class]]) {
</span><span class='line'>                continue;
</span><span class='line'>            }
</span><span class='line'>            
</span><span class='line'>            if ([class isSubclassOfClass:[PDNetworkDomainController class]]) {
</span><span class='line'>                continue;
</span><span class='line'>            }
</span><span class='line'>            
</span><span class='line'>            for (int selectorIndex = 0; selectorIndex &lt; numSelectors; ++selectorIndex) {
</span><span class='line'>                if ([class instancesRespondToSelector:selectors[selectorIndex]]) {
</span><span class='line'>                    [self injectIntoDelegateClass:class];
</span><span class='line'>                    break;
</span><span class='line'>                }
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>        
</span><span class='line'>        free(classes);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>从这个实现也可以发现，像ASIHttpRequest这样的直接基于底层CFNetwork封装的库，以及iOS 7中新引入的NSURLSession都是无法抓到请求包的，这种情况下如果需要抓包就只能使用Charles这类工具了。</p>

<p>调试视图功能调用了一些runtime的私有API，部分代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (void)startMonitoringUIViewChanges;
</span><span class='line'>{
</span><span class='line'>    // Swizzle UIView add/remove methods to monitor changes in the view hierarchy
</span><span class='line'>    // Only do it once to avoid swapping back if this method is called again
</span><span class='line'>    static dispatch_once_t onceToken;
</span><span class='line'>    dispatch_once(&onceToken, ^{
</span><span class='line'>        Method original, swizzle;
</span><span class='line'>        Class viewClass = [UIView class];
</span><span class='line'>
</span><span class='line'>        // Using sel_registerName() because compiler complains about the swizzled selectors not being found.
</span><span class='line'>        original = class_getInstanceMethod(viewClass, @selector(addSubview:));
</span><span class='line'>        swizzle = class_getInstanceMethod(viewClass, sel_registerName("pd_swizzled_addSubview:"));
</span><span class='line'>        method_exchangeImplementations(original, swizzle);
</span><span class='line'>        
</span><span class='line'>        ···
</span><span class='line'>                  
</span><span class='line'>        original = class_getInstanceMethod(viewClass, @selector(exchangeSubviewAtIndex:withSubviewAtIndex:));
</span><span class='line'>        swizzle = class_getInstanceMethod(viewClass, sel_registerName("pd_swizzled_exchangeSubviewAtIndex:withSubviewAtIndex:"));
</span><span class='line'>        method_exchangeImplementations(original, swizzle);
</span><span class='line'>    });
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这部分可以看到是通过Method Swizzling来动态交换了UIView的方法实现，以addSubview为例，替换成了pd_swizzled_addSubview，至于pd_swizzled_addSubview的实现请看下面</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)pd_swizzled_addSubview:(UIView *)subview;
</span><span class='line'>{
</span><span class='line'>    [[PDDOMDomainController defaultInstance] removeView:subview];
</span><span class='line'>    [self pd_swizzled_addSubview:subview];
</span><span class='line'>    [[PDDOMDomainController defaultInstance] addView:subview];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>替换后的removeView和addView方法都是重新实现的，里面会将UIView的变动以DOM形式写到PDDOMDomain对象中输出。</p>

<p>除了以上两个主要功能，还有Core Data远程调试，日志远程输出等功能，其实现方式大同小异，就不一一赘述了。</p>

<p>总的来说，PonyDebugger的功能还是十分强大的，也能够有效地提高开发者的调试效率，有类似需求的很值得一试。</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[使用VIPER构建iOS应用]]></title>
        <link href="http://swplzj.github.io/blog/2014/12/07/shi-yong-viper-chuang-jian-kuang-jia/"/>
        <updated>2014-12-07T22:03:17+08:00</updated>
        <id>http://swplzj.github.io/blog/2014/12/07/shi-yong-viper-chuang-jian-kuang-jia</id>
        <content type="html"><![CDATA[<p>建筑领域流行这样一句话，“我们虽然在营造建筑，但建筑也会重新塑造我们”。正如所有开发者最终领悟到的，这句话同样适用于构建软件。</p>

<p>编写代码中至关重要的是，需要使每一部分容易被识别，赋有一个特定而明显的目的，并与其他部分在逻辑关系中完美契合。这就是我们所说的软件架构。好的架构不仅让一个产品成功投入使用，还可以让产品具有可维护性，并让人不断头脑清醒的对它进行维护！</p>

<!--more-->


<p>在这篇文章中，我们介绍了一种称之为 <a href="http://mutualmobile.github.io/blog/2013/12/04/viper-introduction/">VIPER</a> 的 iOS 应用架构的方式。VIPER 已经在很多大型的项目上成功实践，但是出于本文的目的我们将通过一个待办事项清单 (to-do app) 来介绍 VIPER 。你可以在 <a href="https://github.com/objcio/issue-13-viper">GitHub</a> 上关注这个项目。</p>

<h5>什么是 VIPER？</h5>

<p>测试永远不是构建 iOS 应用的主要部分。当我们 <a href="https://github.com/mutualmobile/">Mutual Mobile</a> 着手改善我们的测试实践时，我们发现给 iOS 应用写测试代码非常困难。因此如果想要设法改变测试的现状，我们首先需要一个更好的方式来架构应用，我们称之为 VIPER。</p>

<p>VIPER 是一个创建 iOS 应用<a href="http://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html">简明构架</a>的程序。VIPER 可以是视图 (View)，交互器 (Interactor)，展示器 (Presenter)，实体 (Entity) 以及路由 (Routing) 的首字母缩写。简明架构将一个应用程序的逻辑结构划分为不同的责任层。这使得它更容易隔离依赖项 (如数据库)，也更容易测试各层间的边界处的交互：
<img src="http://www.cocoachina.com/cms/uploads/allimg/140703/8370_140703100012_1.jpg" alt="id1" /></p>

<p>大部分 iOS 应用利用 MVC 构建，使用 MVC 应用程序架构可以引导你将每一个类看做模型，视图或控制器中的一个。但由于大部分应用程序的逻辑不会存在于模型或视图中，所以通常最终总是在控制器里实现。这就导致一个称为<a href="https://twitter.com/Colin_Campbell/status/293167951132098560">重量级视图控制器</a>的问题，在这里，视图控制器做了太多工作。为这些重量级视图控制器<a href="http://www.objc.io/issue-1/lighter-view-controllers.html">瘦身</a>并不是 iOS 开发者寻求提高代码的质量所要面临的唯一挑战，但至少这是一个很好的开端。</p>

<p>VIPER 的不同层提供了明确的程序逻辑以及导航控制代码来应对这个挑战，利用 VIPER ，你会注意到在我们的待办事项示例清单中的视图控制器可以简洁高效，意义明确地控制视图。你也会发现视图控制器中代码和所有的其他类很容易理解，容易测试，理所当然也更易维护。</p>

<h5>基于用例的应用设计</h5>

<p>应用通常是一些用户用例的集合。用例也被称为验收标准，或行为集，它们用来描述应用的用途。清单可以根据时间，类型以及名字排序，这就是一个用例。用例是应用程序中用来负责业务逻辑的一层，应独立于用户界面的实现，同时要足够小，并且有良好的定义。决定如何将一个复杂的应用分解成较小的用例非常具有挑战性，并且需要长期实践，但这对于缩小你解决的问题时所要面临的范围及完成的每个类的所要涉及的内容来说，是很有帮助的。</p>

<p>利用 VIPER 建立一个应用需要实施一组套件来满足所有的用例，应用逻辑是实现用例的主要组成部分，但却不是唯一。用例也会影响用户界面。另一个重要的方面，是要考虑用例如何与其他应用程序的核心组件相互配合，例如网络和数据持久化。组件就好比用例的插件，VIPER 则用来描述这些组件的作用是什么，如何进行交互。</p>

<p>我们其中一个用例，或者说待办事项清单中其中的一个需求是可以基于用户的选择来将待办事项分组。通过分离的逻辑将数据组织成一个用例，我们能够在测试时使用户界面代码保持干净，用例更易组装，从而确保它如我们预期的方式工作。</p>

<h5>VIPER 的主要部分</h5>

<p>VIPER 的主要部分是：</p>

<p>视图：根据展示器的要求显示界面，并将用户输入反馈给展示器。
交互器：包含由用例指定的业务逻辑。
展示器：包含为显示（从交互器接受的内容）做的准备工作的相关视图逻辑，并对用户输入进行反馈（从交互器获取新数据）。
实体：包含交互器要使用的基本模型对象。
路由：包含用来描述屏幕显示和显示顺序的导航逻辑。</p>

<p>这种分隔形式同样遵循<a href="http://www.objectmentor.com/resources/articles/srp.pdf">单一责任原则</a>。交互器负责业务分析的部分，展示器代表交互设计师，而视图相当于视觉设计师。</p>

<p>以下则是不同组件的相关图解，并展示了他们之间是如何关联的：</p>

<p><img src="http://www.cocoachina.com/cms/uploads/allimg/140703/8370_140703100110_1.png" alt="id2" /></p>

<p>虽然在应用中 VIPER 的组件可以以任意顺序实现，我们在这里选择按照我们推荐的顺序来进行介绍。你会注意到这个顺序与构建整个应用的进程大致符合 &ndash; 首先要讨论的是产品需要做什么，以及用户会如何与之交互。</p>

<h5>交互器</h5>

<p>交互器在应用中代表着一个独立的用例。它具有业务逻辑以操纵模型对象（实体）执行特定的任务。交互器中的工作应当独立与任何用户界面，同样的交互器可以同时运用于 iOS 应用或者 OS X 应用中。</p>

<p>由于交互器是一个 PONSO (Plain Old NSObject，普通的 NSObject)，它主要包含了逻辑，因此很容易使用 TDD 进行开发。</p>

<p>示例应用的主要用例是向用户展示所有的待办事项（比如任何截止于下周末的任务）。此类用例的业务逻辑主要是找出今天至下周末之间将要到期的待办事项，然后为它们分配一个相对的截止日期，比如今天，明天，本周以内，或者下周。</p>

<p>以下是来自 VTDListInteractor 的对应方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)findUpcomingItems 
</span><span class='line'>{ 
</span><span class='line'>    __weak typeof(self) welf = self; 
</span><span class='line'>    NSDate* today = [self.clock today]; 
</span><span class='line'>    NSDate* endOfNextWeek = [[NSCalendar currentCalendar] dateForEndOfFollowingWeekWithDate:today]; 
</span><span class='line'>    [self.dataManager todoItemsBetweenStartDate:today endDate:endOfNextWeek completionBlock:^(NSArray* todoItems) { 
</span><span class='line'>        [welf.output foundUpcomingItems:[welf upcomingItemsFromToDoItems:todoItems]]; 
</span><span class='line'>    }]; 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<h5>实体</h5>

<p>实体是被交互器操作的模型对象，并且它们只被交互器所操作。交互器永远不会传输实体至表现层 (比如说展示器)。</p>

<p>实体也应该是 PONSOs。如果你使用 Core Data，最好是将托管对象保持在你的数据层之后，交互器不应与 NSManageObjects 协同工作。</p>

<p>这里是我们的待办事项服务的实体：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface VTDTodoItem : NSObject 
</span><span class='line'> 
</span><span class='line'>@property (nonatomic, strong)   NSDate*     dueDate; 
</span><span class='line'>@property (nonatomic, copy)     NSString*   name; 
</span><span class='line'> 
</span><span class='line'>+ (instancetype)todoItemWithDueDate:(NSDate*)dueDate name:(NSString*)name; 
</span><span class='line'> 
</span><span class='line'>@end 
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>不要诧异于你的实体仅仅是数据结构，任何依赖于应用的逻辑都应该放到交互器中。</p>

<h5>展示器</h5>

<p>展示器是一个主要包含了驱动用户界面的逻辑的 PONSO，它总是知道何时呈现用户界面。基于其收集来自用户交互的输入功能，它可以在合适的时候更新用户界面并向交互器发送请求。</p>

<p>当用户点击 “+” 键新建待办事项时，addNewEntry 被调用。对于此项操作，展示器会要求 wireframe 显示用户界面以增加新项目：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)addNewEntry 
</span><span class='line'>{ 
</span><span class='line'>    [self.listWireframe presentAddInterface]; 
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>展示器还会从交互器接收结果并将结果转换成能够在视图中有效显示的形式。</p>

<p>下面是如何从交互器接受待办事项的过程，其中包含了处理数据的过程并决定展现给用户哪些内容：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)foundUpcomingItems:(NSArray*)upcomingItems 
</span><span class='line'>{ 
</span><span class='line'>    if ([upcomingItems count] == 0) 
</span><span class='line'>    { 
</span><span class='line'>        [self.userInterface showNoContentMessage]; 
</span><span class='line'>    } 
</span><span class='line'>    else 
</span><span class='line'>    { 
</span><span class='line'>        [self updateUserInterfaceWithUpcomingItems:upcomingItems]; 
</span><span class='line'>    } 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>实体永远不会由交互器传输给展示器，取而代之，那些无行为的简单数据结构会从交互器传输到展示器那里。这就防止了那些“真正的工作”在展示器那里进行，展示器只能负责准备那些在视图里显示的数据。</p>

<h5>视图</h5>

<p>视图一般是被动的，它通常等待展示器下发需要显示的内容，而不会向其索取数据。视图（例如登录界面的登录视图控件）所定义的方法应该允许展示器在高度抽象的层次与之交流。展示器通过内容进行表达，而不关心那些内容所显示的样子。展示器不知道 UILabel，UIButton 等的存在，它只知道其中包含的内容以及何时需要显示。内容如何被显示是由视图来进行控制的。</p>

<p>视图是一个抽象的接口 (Interface)，在 Objective-C 中使用协议被定义。一个 UIViewController 或者它的一个子类会实现视图协议。比如我们的示例中 “添加” 界面会有以下接口：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@protocol VTDAddViewInterface  
</span><span class='line'> 
</span><span class='line'>- (void)setEntryName:(NSString *)name; 
</span><span class='line'>- (void)setEntryDueDate:(NSDate *)date; 
</span><span class='line'> 
</span><span class='line'>@end </span></code></pre></td></tr></table></div></figure>


<p>视图和视图控制器同样会操纵用户界面和相关输入。因为通常来说视图控制器是最容易处理这些输入和执行某些操作的地方，所以也就不难理解为什么视图控制器总是这么大了。为了使视图控制器保持苗条，我们需要使它们在用户进行相关操作的时候可以有途径来通知相关部分。视图控制器不应当根据这些行为进行相关决定，但是它应当将发生的事件传递到能够做决定的部分。</p>

<p>在我们的例子中，Add View Controller 有一个事件处理的属性，它实现了如下接口：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@protocol VTDAddModuleInterface  
</span><span class='line'> 
</span><span class='line'>- (void)cancelAddAction; 
</span><span class='line'>- (void)saveAddActionWithName:(NSString *)name dueDate:(NSDate *)dueDate 
</span><span class='line'> 
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>当用户点击取消键的时候，视图控制器告知这个事件处理程序用户需要其取消这次添加的动作。这样一来，事件处理程序便可以处理关闭 add view controller 并告知列表视图进行更新。</p>

<p>视图和展示器之间边界处是一个使用 <a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a> 的好地方。在这个示例中，视图控制器可以返回一个代表按钮操作的信号。这将允许展示器在不打破职责分离的前提下轻松地对那些信号进行响应。</p>

<h5>路由</h5>

<p>屏幕间的路径会在交互设计师创建的线框 (wireframes) 里进行定义。在 VIPER 中，路由是由两个部分来负责的：展示器和线框。一个线框对象包括 UIWindow，UINavigationController，UIViewController 等部分，它负责创建视图/视图控制器并将其装配到窗口中。</p>

<p>由于展示器包含了响应用户输入的逻辑，因此它就拥有知晓何时导航至另一个屏幕以及具体是哪一个屏幕的能力。而同时，线框知道如何进行导航。在两者结合起来的情况下，展示器可以使用线框来进行实现导航功能，它们两者一起描述了从一个屏幕至另一个屏幕的路由过程。</p>

<p>线框同时也明显是一个处理导航转场动画的地方。来看看这个 add wireframe 中的例子吧：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@implementation VTDAddWireframe 
</span><span class='line'> 
</span><span class='line'>- (void)presentAddInterfaceFromViewController:(UIViewController *)viewController  
</span><span class='line'>{ 
</span><span class='line'>    VTDAddViewController *addViewController = [self addViewController]; 
</span><span class='line'>    addViewController.eventHandler = self.addPresenter; 
</span><span class='line'>    addViewController.modalPresentationStyle = UIModalPresentationCustom; 
</span><span class='line'>    addViewController.transitioningDelegate = self; 
</span><span class='line'> 
</span><span class='line'>    [viewController presentViewController:addViewController animated:YES completion:nil]; 
</span><span class='line'> 
</span><span class='line'>    self.presentedViewController = viewController; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>#pragma mark - UIViewControllerTransitioningDelegate Methods 
</span><span class='line'> 
</span><span class='line'>- (id)animationControllerForDismissedController:(UIViewController *)dismissed  
</span><span class='line'>{ 
</span><span class='line'>    return [[VTDAddDismissalTransition alloc] init]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (id)animationControllerForPresentedController:(UIViewController *)presented 
</span><span class='line'>                                                                  presentingController:(UIViewController *)presenting 
</span><span class='line'>                                                                      sourceController:(UIViewController *)source  
</span><span class='line'>{ 
</span><span class='line'>    return [[VTDAddPresentationTransition alloc] init]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>@end 
</span></code></pre></td></tr></table></div></figure>


<p>应用使用了自定义的视图控制器转场来呈现 add view controller。因为线框部件负责实施这个转场，所以它成为了 add view controller 转场的委托，并且返回适当的转场动画。</p>

<h5>利用 VIPER 组织应用组件</h5>

<p>iOS 应用的构架需要考虑到 UIKit 和 Cocoa Touch 是建立应用的主要工具。架构需要和应用的所有组件都能够和平相处，但又需要为如何使用框架的某些部分以及它们应该在什么位置提供一些指导和建议。</p>

<p>iOS 应用程序的主力是 UIViewController，我们不难想象找一个竞争者来取代 MVC 就可以避免大量使用视图控制器。但是视图控制器现在是这个平台的核心：它们处理设备方向的变化，回应用户的输入，和类似导航控制器之类的系统系统组件集成得很好，而现在在 iOS 7 中又能实现自定义屏幕之间的转换，功能实在是太强大了。</p>

<p>有了 VIPER，视图控制器便就能真正的做它本来应该做的事情了，那就是控制视图。 我们的待办事项应拥有两个视图控制器，一个是列表视图，另一个是新建待办。因为 add view controller 要做的所有事情就是控制视图，所以实现起来非常的简单基础：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@implementation VTDAddViewController 
</span><span class='line'> 
</span><span class='line'>- (void)viewDidAppear:(BOOL)animated  
</span><span class='line'>{ 
</span><span class='line'>    [super viewDidAppear:animated]; 
</span><span class='line'> 
</span><span class='line'>    UITapGestureRecognizer *gestureRecognizer = [[UITapGestureRecognizer alloc] initWithTarget:self 
</span><span class='line'>                                                                                        action:@selector(dismiss)]; 
</span><span class='line'>    [self.transitioningBackgroundView addGestureRecognizer:gestureRecognizer]; 
</span><span class='line'>    self.transitioningBackgroundView.userInteractionEnabled = YES; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (void)dismiss  
</span><span class='line'>{ 
</span><span class='line'>    [self.eventHandler cancelAddAction]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (void)setEntryName:(NSString *)name  
</span><span class='line'>{ 
</span><span class='line'>    self.nameTextField.text = name; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (void)setEntryDueDate:(NSDate *)date  
</span><span class='line'>{ 
</span><span class='line'>    [self.datePicker setDate:date]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (IBAction)save:(id)sender  
</span><span class='line'>{ 
</span><span class='line'>    [self.eventHandler saveAddActionWithName:self.nameTextField.text 
</span><span class='line'>                                     dueDate:self.datePicker.date]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (IBAction)cancel:(id)sender  
</span><span class='line'>{ 
</span><span class='line'>    [self.eventHandler cancelAddAction]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'> 
</span><span class='line'>#pragma mark - UITextFieldDelegate Methods 
</span><span class='line'> 
</span><span class='line'>- (BOOL)textFieldShouldReturn:(UITextField *)textField  
</span><span class='line'>{ 
</span><span class='line'>    [textField resignFirstResponder]; 
</span><span class='line'> 
</span><span class='line'>    return YES; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>@end </span></code></pre></td></tr></table></div></figure>


<p>应用在接入网络以后会变得更有用处，但是究竟该在什么时候联网呢？又由谁来负责启动网络连接呢？典型的情况下，由交互器来启动网络连接操作的项目，但是它不会直接处理网络代码。它会寻找一个像是 network manager 或者 API client 这样的依赖项。交互器可能聚合来自多个源的数据来提供所需的信息，从而完成一个用例。最终，就由展示器来采集交互器反馈的数据，然后组织并进行展示。</p>

<p>数据存储模块负责提供实体给交互器。因为交互器要完成业务逻辑，因此它需要从数据存储中获取实体并操纵它们，然后将更新后的实体再放回数据存储中。数据存储管理实体的持久化，而实体应该对数据库全然不知，正因如此，实体并不知道如何对自己进行持久化。</p>

<p>交互器同样不需要知道如何将实体持久化，有时交互器更希望使用一个 data manager 来使其与数据存储的交互变得容易。Data manager 可以处理更多的针对存储的操作，比如创建获取请求，构建查询等等。这就使交互器能够将更多的注意力放在应用逻辑上，而不必再了解实体是如何被聚集或持久化的。下面我们举一个例子来说明使用 data manager 有意义的，这个例子假设你在使用 Core Data。这是示例应用程序的 data manager 的接口：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface VTDListDataManager : NSObject 
</span><span class='line'> 
</span><span class='line'>@property (nonatomic, strong) VTDCoreDataStore *dataStore; 
</span><span class='line'> 
</span><span class='line'>- (void)todoItemsBetweenStartDate:(NSDate *)startDate endDate:(NSDate *)endDate completionBlock:(void (^)(NSArray *todoItems))completionBlock; 
</span><span class='line'> 
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>当使用 TDD 来开发一个交互器时，是可以用一个测试用的模拟存储来代替生产环境的数据存储的。避免与远程服务器通讯（网络服务）以及避免读取磁盘（数据库）可以加快你测试的速度并加强其可重复性。</p>

<p>将数据存储保持为一个界限清晰的特定层的原因之一是，这可以让你延迟选择一个特定的持久化技术。如果你的数据存储是一个独立的类，那你就可以使用一个基础的持久化策略来开始你的应用，然后等到有意义的时候升级至 SQLite 或者 Core Data。而因为数据存储层的存在，你的应用代码库中就不需要改变任何东西。</p>

<p>在 iOS 的项目中使用 Core Data 经常比构架本身还容易引起更多争议。然而，利用 VIPER 来使用 Core Data 将给你带来使用 Core Data 的前所未有的良好体验。在持久化数据的工具层面上，Core Data 可以保持快速存取和低内存占用方面，简直是个神器。但是有个很恼人的地方，它会像触须一样把 NSManagedObjectContext 延伸至你所有的应用实现文件中，特别是那些它们不该待的地方。VIPER 可以使 Core Data 待在正确的地方：数据存储层。</p>

<p>在待办事项示例中，应用仅有的两部分知道使用了 Core Data，其一是数据存储本身，它负责建立 Core Data 堆栈；另一个是 data manager。Data manager 执行了获取请求，将数据存储返回的 NSManagedObject 对象转换为标准的 PONSO 模型对象，并传输回业务逻辑层。这样一来，应用程序核心将不再依赖于 Core Data，附加得到的好处是，你也再也不用担心过期数据 (stale) 和没有良好组织的多线程 NSManagedObjects 来糟蹋你的工作成果了。</p>

<p>在通过请求访问 Core Data 存储时，data manager 中看起来是这样的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@implementation VTDListDataManager 
</span><span class='line'> 
</span><span class='line'>- (void)todoItemsBetweenStartDate:(NSDate *)startDate endDate:(NSDate*)endDate completionBlock:(void (^)(NSArray *todoItems))completionBlock 
</span><span class='line'>{ 
</span><span class='line'>    NSCalendar *calendar = [NSCalendar autoupdatingCurrentCalendar]; 
</span><span class='line'> 
</span><span class='line'>    NSPredicate *predicate = [NSPredicate predicateWithFormat:@"(date &gt;= %@) AND (date &lt;= %@)", [calendar dateForBeginningOfDay:startDate], [calendar dateForEndOfDay:endDate]]; 
</span><span class='line'>    NSArray *sortDescriptors = @[]; 
</span><span class='line'> 
</span><span class='line'>    __weak typeof(self) welf = self; 
</span><span class='line'>    [self.dataStore 
</span><span class='line'>     fetchEntriesWithPredicate:predicate 
</span><span class='line'>     sortDescriptors:sortDescriptors 
</span><span class='line'>     completionBlock:^(NSArray* entries) { 
</span><span class='line'>         if (completionBlock) 
</span><span class='line'>         { 
</span><span class='line'>             completionBlock([welf todoItemsFromDataStoreEntries:entries]); 
</span><span class='line'>         } 
</span><span class='line'>     }]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (NSArray*)todoItemsFromDataStoreEntries:(NSArray *)entries 
</span><span class='line'>{ 
</span><span class='line'>    return [entries arrayFromObjectsCollectedWithBlock:^id(VTDManagedTodoItem *todo) { 
</span><span class='line'>        return [VTDTodoItem todoItemWithDueDate:todo.date name:todo.name]; 
</span><span class='line'>    }]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>@end </span></code></pre></td></tr></table></div></figure>


<p>与 Core Data 一样极富争议的恐怕就是 UI 故事板了。故事板具有很多有用的功能，如果完全忽视它将会是一个错误。然而，调用故事版所能提供的所有功能来完成 VIPER 的所有目标仍然是很困难的。</p>

<p>我们所能做出的妥协就是选择不使用 segues 。有时候使用 segues 是有效的，但是使用 segues 的危险性在于它们很难原封不动地保持屏幕之间的分离，以及 UI 和应用逻辑之间的分离。一般来说，如果实现 prepareForSegue 方法是必须的话，我们就尽量不去使用 segues。</p>

<p>除此之外，故事板是一个实现用户界面布局有效方法，特别是在使用自动布局的时候。我们选择在实现待办事项两个界面的实例中使用故事板，并且使用这样的代码来执行自己的导航操作。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static NSString *ListViewControllerIdentifier = @"VTDListViewController"; 
</span><span class='line'> 
</span><span class='line'>@implementation VTDListWireframe 
</span><span class='line'> 
</span><span class='line'>- (void)presentListInterfaceFromWindow:(UIWindow *)window  
</span><span class='line'>{ 
</span><span class='line'>    VTDListViewController *listViewController = [self listViewControllerFromStoryboard]; 
</span><span class='line'>    listViewController.eventHandler = self.listPresenter; 
</span><span class='line'>    self.listPresenter.userInterface = listViewController; 
</span><span class='line'>    self.listViewController = listViewController; 
</span><span class='line'> 
</span><span class='line'>    [self.rootWireframe showRootViewController:listViewController 
</span><span class='line'>                                      inWindow:window]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (VTDListViewController *)listViewControllerFromStoryboard  
</span><span class='line'>{ 
</span><span class='line'>    UIStoryboard *storyboard = [self mainStoryboard]; 
</span><span class='line'>    VTDListViewController *viewController = [storyboard instantiateViewControllerWithIdentifier:ListViewControllerIdentifier]; 
</span><span class='line'>    return viewController; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (UIStoryboard *)mainStoryboard  
</span><span class='line'>{ 
</span><span class='line'>    UIStoryboard *storyboard = [UIStoryboard storyboardWithName:@"Main" 
</span><span class='line'>                                                         bundle:[NSBundle mainBundle]]; 
</span><span class='line'>    return storyboard; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>@end </span></code></pre></td></tr></table></div></figure>


<h5>使用 VIPER 构建模块</h5>

<p>一般在使用 VIPER 的时候，你会发现一个屏幕或一组屏幕倾向于聚在一起作为一个模块。模块可以以多种形式体现，但一般最好把它想成是一种特性。在播客应用中，一个模块可能是音频播放器或订阅浏览器。然而在我们的待办事项应用中，列表和添加事项的屏幕都将作为单独的模块被建立。</p>

<p>将你的应用作为一组模块来设计有很多好处，其中之一就是模块可以有非常明确和定义良好的接口，并且独立于其他的模块。这就使增加或者移除特性变得更加简单，也使在界面中向用户展示各种可变模块变得更加简单。</p>

<p>我们希望能将待办事项中各模块之间分隔更加明确，我们为添加模块定义了两个协议。一个是模块接口，它定义了模块可以做什么；另一个则是模块的代理，用来描述该模块做了什么。例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@protocol VTDAddModuleInterface  
</span><span class='line'> 
</span><span class='line'>- (void)cancelAddAction; 
</span><span class='line'>- (void)saveAddActionWithName:(NSString *)name dueDate:(NSDate *)dueDate; 
</span><span class='line'> 
</span><span class='line'>@end 
</span><span class='line'> 
</span><span class='line'> 
</span><span class='line'>@protocol VTDAddModuleDelegate  
</span><span class='line'> 
</span><span class='line'>- (void)addModuleDidCancelAddAction; 
</span><span class='line'>- (void)addModuleDidSaveAddAction; 
</span><span class='line'> 
</span><span class='line'>@end </span></code></pre></td></tr></table></div></figure>


<p>因为模块必须要被展示，才能对用户产生价值，所以模块的展示器通常需要实现模型的接口。当另一个模型想要展现当前模块时，它的展示器就需要实现模型的委托协议，这样它就能在展示时知道当前模块做了些什么。</p>

<p>一个模块可能包括实体，交互器和管理器的通用应用逻辑层，这些通常可用于多个屏幕。当然，这取决于这些屏幕之间的交互及它们的相似度。一个模块可以像在待办事项列表里面一样，简单的只代表一个屏幕。这样一来，应用逻辑层对于它的特定模块的行为来说就非常特有了。</p>

<p>模块同样是组织代码的简便途径。将模块所有的编码都放在它自己的文件夹中并在 Xcode 中建一个 group，这会在你需要寻找和改变更加容易。当你在要寻找一个类时，它恰到好处地就在你所期待的地方，这种感觉真是无法形容的棒。</p>

<p>利用 VIPER 建立模块的另一个好处是它使得扩展到多平台时变得更加简单。独立在交互器层中的所有用例的应用逻辑允许你可以专注于为平板，电话或者 Mac 构建新的用户界面，同时可以重用你的应用层。</p>

<p>进一步来说，iPad 应用的用户界面能够将部分 iPhone 应用的视图，视图控制器及展示器进行再利用。在这种情况下，iPad 屏幕将由 ‘super’ 展示器和线框来代表，这样可以利用 iPhone 使用过的展示器和线框来组成屏幕。建立进而维护一个跨多平台的应用是一个巨大的挑战，但是好的构架可以对整个模型和应用层的再利用有大幅度的提升，并使其实现起来更加容易。</p>

<h5>利用 VIPER 进行测试</h5>

<p>VIPER 的出现激发了一个关注点的分离，这使得采用 TDD 变得更加简便。交互器包含独立与任何 UI 的纯粹逻辑，这使测试驱动开发更加简单。同时展示器包含用来为显示准备数据的逻辑，并且它也独立于任何一个 UIKit 部件。对于这个逻辑的开发也很容易用测试来驱动。</p>

<p>我们更倾向于先从交互器下手。用户界面里所有部分都服务于用例，而通过采用 TDD 来测试驱动交互器的 API 可以让你对用户界面和用例之间的关系有一个更好的了解。</p>

<p>作为实例，我们来看一下负责待办事项列表的交互器。寻找待办事项的策略是要找出所有的将在下周末前截止的项目，并将这些项目分别归类至截止于今天，明天，本周或者下周。</p>

<p>我们编写的第一个测试是为了保证交互器能够找到所有的截止于下周末的待办事项：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)testFindingUpcomingItemsRequestsAllToDoItemsFromTodayThroughEndOfNextWeek 
</span><span class='line'>{ 
</span><span class='line'>    [[self.dataManager expect] todoItemsBetweenStartDate:self.today endDate:self.endOfNextWeek completionBlock:OCMOCK_ANY]; 
</span><span class='line'>    [self.interactor findUpcomingItems]; 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>一旦知道了交互器找到了正确的待办事项后，我们就需要编写几个小测试用来确认它确实将待办事项分配到了正确的相对日期组内（比如说今天，明天，等等）。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)testFindingUpcomingItemsWithOneItemDueTodayReturnsOneUpcomingItemsForToday 
</span><span class='line'>{ 
</span><span class='line'>    NSArray *todoItems = @[[VTDTodoItem todoItemWithDueDate:self.today name:@"Item 1"]]; 
</span><span class='line'>    [self dataStoreWillReturnToDoItems:todoItems]; 
</span><span class='line'> 
</span><span class='line'>    NSArray *upcomingItems = @[[VTDUpcomingItem upcomingItemWithDateRelation:VTDNearTermDateRelationToday dueDate:self.today title:@"Item 1"]]; 
</span><span class='line'>    [self expectUpcomingItems:upcomingItems]; 
</span><span class='line'> 
</span><span class='line'>    [self.interactor findUpcomingItems]; 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>既然我们已经知道了交互器的 API 长什么样，接下来就是开发展示器。一旦展示器接收到了交互器传来的待办事项，我们就需要测试看看我们是否适当的将数据进行格式化并且在用户界面中正确的显示它。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)testFoundZeroUpcomingItemsDisplaysNoContentMessage 
</span><span class='line'>{ 
</span><span class='line'>    [[self.ui expect] showNoContentMessage]; 
</span><span class='line'> 
</span><span class='line'>    [self.presenter foundUpcomingItems:@[]]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (void)testFoundUpcomingItemForTodayDisplaysUpcomingDataWithNoDay 
</span><span class='line'>{ 
</span><span class='line'>    VTDUpcomingDisplayData *displayData = [self displayDataWithSectionName:@"Today" 
</span><span class='line'>                                                          sectionImageName:@"check" 
</span><span class='line'>                                                                 itemTitle:@"Get a haircut" 
</span><span class='line'>                                                                itemDueDay:@""]; 
</span><span class='line'>    [[self.ui expect] showUpcomingDisplayData:displayData]; 
</span><span class='line'> 
</span><span class='line'>    NSCalendar *calendar = [NSCalendar gregorianCalendar]; 
</span><span class='line'>    NSDate *dueDate = [calendar dateWithYear:2014 month:5 day:29]; 
</span><span class='line'>    VTDUpcomingItem *haircut = [VTDUpcomingItem upcomingItemWithDateRelation:VTDNearTermDateRelationToday dueDate:dueDate title:@"Get a haircut"]; 
</span><span class='line'> 
</span><span class='line'>    [self.presenter foundUpcomingItems:@[haircut]]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (void)testFoundUpcomingItemForTomorrowDisplaysUpcomingDataWithDay 
</span><span class='line'>{ 
</span><span class='line'>    VTDUpcomingDisplayData *displayData = [self displayDataWithSectionName:@"Tomorrow" 
</span><span class='line'>                                                          sectionImageName:@"alarm" 
</span><span class='line'>                                                                 itemTitle:@"Buy groceries" 
</span><span class='line'>                                                                itemDueDay:@"Thursday"]; 
</span><span class='line'>    [[self.ui expect] showUpcomingDisplayData:displayData]; 
</span><span class='line'> 
</span><span class='line'>    NSCalendar *calendar = [NSCalendar gregorianCalendar]; 
</span><span class='line'>    NSDate *dueDate = [calendar dateWithYear:2014 month:5 day:29]; 
</span><span class='line'>    VTDUpcomingItem *groceries = [VTDUpcomingItem upcomingItemWithDateRelation:VTDNearTermDateRelationTomorrow dueDate:dueDate title:@"Buy groceries"]; 
</span><span class='line'> 
</span><span class='line'>    [self.presenter foundUpcomingItems:@[groceries]]; 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>同样需要测试的是应用是否在用户想要新建待办事项时正确启动了相应操作：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)testAddNewToDoItemActionPresentsAddToDoUI 
</span><span class='line'>{ 
</span><span class='line'>    [[self.wireframe expect] presentAddInterface]; 
</span><span class='line'> 
</span><span class='line'>    [self.presenter addNewEntry]; 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>这时我们可以开发视图功能了，并且在没有待办事项的时候我们想要展示一个特殊的信息。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)testShowingNoContentMessageShowsNoContentView 
</span><span class='line'>{ 
</span><span class='line'>    [self.view showNoContentMessage]; 
</span><span class='line'> 
</span><span class='line'>    XCTAssertEqualObjects(self.view.view, self.view.noContentView, @"the no content view should be the view"); 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>有待办事项出现时，我们要确保列表是显示出来的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)testShowingUpcomingItemsShowsTableView 
</span><span class='line'>{ 
</span><span class='line'>    [self.view showUpcomingDisplayData:nil]; 
</span><span class='line'> 
</span><span class='line'>    XCTAssertEqualObjects(self.view.view, self.view.tableView, @"the table view should be the view"); 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>首先建立交互器是一种符合 TDD 的自然规律。如果你首先开发交互器，紧接着是展示器，你就可以首先建立一个位于这些层的套件测试，并且为实现这是实例奠定基础。由于你不需要为了测试它们而去与用户界面进行交互，所以这些类可以进行快速迭代。在你需要开发视图的时候，你会有一个可以工作并测试过的逻辑和表现层来与其进行连接。在快要完成对视图的开发时，你会发现第一次运行程序时所有部件都运行良好，因为你所有已通过的测试已经告诉你它可以工作。</p>

<h5>结论</h5>

<p>我们希望你喜欢这篇对 VIPER 的介绍。或许你们都很好奇接下来应该做什么，如果你希望通过 VIPER 来对你下一个应用进行设计，该从哪里开始呢？</p>

<p>我们竭尽全力使这篇文章和我们利用 VIPER 实现的应用实例足够明确并且进行了很好的定义。我们的待办事项里列表程序相当直接简单，但是它准确地解释了如何利用 VIPER 来建立一个应用。在实际的项目中，你可以根据你自己的挑战和约束条件来决定要如何实践这个例子。根据以往的经验，我们的每个项目在使用 VIPER 时都或多或少地改变了一些策略，但它们无一例外的都从中得益，找到了正确的方向。</p>

<p>很多情况下由于某些原因，你可能会想要偏离 VIPER 所指引的道路。可能你遇到了很多 &lsquo;bunny&rsquo; 对象，或者你的应用使用了故事板的 segues。没关系的，在这些情况下，你只需要在做决定时稍微考虑下 VIPER 所代表的精神就好。VIPER 的核心在于它是建立在单一责任原则上的架构。如果你碰到了些许麻烦，想想这些原则再考虑如何前进。</p>

<p>你一定想知道在现有的应用中能否只用 VIPER 。在这种情况下，你可以考虑使用 VIPER 构建新的特性。我们许多现有项目都使用了这个方法。你可以利用 VIPER 建立一个模块，这能帮助你发现许多建立在单一责任原则基础上造成难以运用架构的现有问题。</p>

<p>软件开发最伟大的事情之一就是每个应用程序都是不同的，而设计每个应用的架构的方式也是不同的。这就意味着每个应用对于我们来说都是一个学习和尝试的机遇，如果你决定开始使用 VIPER，你会受益匪浅。感谢你的阅读。</p>

<h5>Swift 补充</h5>

<p>苹果上周在 WWDC 介绍了一门称之为 Swift 的编程语言来作为 Cocoa 和 Cocoa Touch 开发的未来。现在发表关于 Swift 的完整意见还为时尚早，但众所周知编程语言对我们如何设计和构建应用有着重大影响。我们决定使用 Swift 重写我们的待办事项清单，帮助我们学习它对 VIPER 意味着什么。至今为止，收获颇丰。Swift 中的一些特性对于构建应用的体验有着显著的提升。</p>

<h5>结构体</h5>

<p>在 VIPER 中我们使用小型，轻量级的 model 类来在比如从展示器到视图这样不同的层间传递数据。这些 PONSOs 通常是只是简单地带有少量数据，并且通常这些类不会被继承。Swift 的结构体非常适合这个情况。下面的结构体的例子来自 VIPER Swift。这个结构体需要被判断是否相等，所以我们重载了 == 操作符来比较这个类型的两个实例。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct UpcomingDisplayItem : Equatable, Printable { 
</span><span class='line'>    let title : String = "" 
</span><span class='line'>    let dueDate : String = "" 
</span><span class='line'> 
</span><span class='line'>    var description : String { get { 
</span><span class='line'>        return "\(title) -- \(dueDate)" 
</span><span class='line'>    }} 
</span><span class='line'> 
</span><span class='line'>    init(title: String, dueDate: String) { 
</span><span class='line'>        self.title = title 
</span><span class='line'>        self.dueDate = dueDate 
</span><span class='line'>    } 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>func == (leftSide: UpcomingDisplayItem, rightSide: UpcomingDisplayItem) -&gt; Bool { 
</span><span class='line'>    var hasEqualSections = false 
</span><span class='line'>    hasEqualSections = rightSide.title == leftSide.title 
</span><span class='line'> 
</span><span class='line'>    if hasEqualSections == false { 
</span><span class='line'>        return false 
</span><span class='line'>    } 
</span><span class='line'> 
</span><span class='line'>    hasEqualSections = rightSide.dueDate == rightSide.dueDate 
</span><span class='line'> 
</span><span class='line'>    return hasEqualSections 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p></p>

<h5>类型安全</h5>

<p>也许 Objective-C 和 Swift 的最大区别是它们在对于类型处理上的不同。 Objective-C 是动态类型，而 Swift 故意在编译时做了严格的类型检查。对于一个类似 VIPER 的架构， 应用由不同层构成，类型安全是提升程序员效率和设计架构有非常大的好处。编译器帮助你确保正确类型的容器和对象在层的边界传递。如上所示，这是一个使用结构体的好地方。如果一个结构体的被设计为存在于两层之间，那么由于类型安全，你可以保证它将永远无法脱离这些层之间。</p>

<h5>扩展阅读</h5>

<p><a href="https://github.com/objcio/issue-13-viper">VIPER TODO, 文章示例</a></p>

<p><a href="https://github.com/objcio/issue-13-viper-swift">VIPER SWIFT, 基于 Swift 的文章示例</a></p>

<p><a href="https://github.com/mutualmobile/Counter">另一个计数器应用</a></p>

<p><a href="http://mutualmobile.github.io/blog/2013/12/04/viper-introduction/">Mutual Mobile 关于 VIPER 的介绍</a></p>

<p><a href="http://blog.8thlight.com/uncle-bob/2011/11/22/Clean-Architecture.html">简明架构</a></p>

<p><a href="http://objccn.io/issue-1-1/">更轻量的 View Controllers</a></p>

<p><a href="http://objccn.io/issue-1-3/">测试 View Controllers</a></p>

<p><a href="http://inessential.com/2014/03/16/smaller_please">Bunnies</a></p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[优秀开源项目：FACEBOOK PAPER动画引擎 – POP]]></title>
        <link href="http://swplzj.github.io/blog/2014/11/14/you-xiu-kai-yuan-xiang-mu-facebook-paper-dong-hua-yin-qing-pop/"/>
        <updated>2014-11-14T19:02:27+08:00</updated>
        <id>http://swplzj.github.io/blog/2014/11/14/you-xiu-kai-yuan-xiang-mu-facebook-paper-dong-hua-yin-qing-pop</id>
        <content type="html"><![CDATA[<p><img src="http://cc.cocimg.com/cms/uploads/allimg/140429/4196_140429142234_1.gif" alt="id1" /></p>

<p>Pop是一个适用于iOS和OS X平台的可扩展动画引擎，是一个成熟的经过多重测试的，可实现Facebook Paper中的所有动画和过渡效果。除了基本的静态动画，Pop还支持spring和decay动画，有助于打造一个逼真的，基于物理的交互。你可以通过Pop的API把Pop快速集成到现有的Objective-C代码库中，并在任何对象上实现动画的任何属性。</p>

<!--more-->


<p></p>

<h5>开始，停止以及更新</h5>

<p>开始动画–把它添加到你想要动画的对象上：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>POPSpringAnimation *anim = [POPSpringAnimation animation]; 
</span><span class='line'>… 
</span><span class='line'>[layer pop_addAnimation:anim forKey:@"myKey"]; </span></code></pre></td></tr></table></div></figure>


<p>停止动画–把它从key在刚开始时指定的对象引用中移除。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[layer pop_removeAnimationForKey:@"myKey"]; 
</span><span class='line'>key可以用来查询现有的动画。更新运行中动画的toValue，为改变进程提供了很好的方式：
</span><span class='line'>anim = [layer pop_animationForKey:@"myKey"]; 
</span><span class='line'>if (anim) { 
</span><span class='line'>  /* update to value to new destination */ 
</span><span class='line'>  anim.toValue = @(42.0); 
</span><span class='line'>} else { 
</span><span class='line'>  /* create and start a new animation */ 
</span><span class='line'>  …. 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>虽然上述代码中使用了layer，但是Pop接口作为一个NSObject上附加类别执行。任何NSObject或者子类可以被动画。</p>

<h5>类型</h5>

<p>Pop有四个具体的动画类型：spring, decay, basic和custom
Spring动画可以用来给对象一个令人愉悦的弹跳效果。在这个例子中，我们用spring动画来动画一个层次的弹跳效果，从现有的值设定为(0, 0, 400, 400)。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>POPSpringAnimation *anim = [POPSpringAnimation animationWithPropertyNamed:kPOPLayerBounds]; 
</span><span class='line'>anim.toValue = [NSValue valueWithCGRec 
</span><span class='line'>t:CGRectMake(0, 0, 400, 400)]; 
</span><span class='line'>[layer pop_addAnimation:anim forKey:@"size"]; </span></code></pre></td></tr></table></div></figure>


<p>Decay动画能用于逐渐减慢一个对象直至停止。在这个例子中，我们将layer的速率减小为每秒钟1000pts。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>POPDecayAnimation *anim = [POPDecayAnimation animationWithPropertyNamed:kPOPLayerPositionX]; 
</span><span class='line'>anim.velocity = @(1000.); 
</span><span class='line'>[layer pop_addAnimation:anim forKey:@"slide"]; </span></code></pre></td></tr></table></div></figure>


<p>基本动画能用于在指定的时间段插入值。使用一个淡入淡出动画在默认时间段将视图的透明度从0.0设置为1.0。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>POPBasicAnimation *anim = [POPBasicAnimation animationWithPropertyNamed:kPOPViewAlpha]; 
</span><span class='line'>anim.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]; 
</span><span class='line'>anim.fromValue = @(0.0); 
</span><span class='line'>anim.toValue = @(1.0); 
</span><span class='line'>[view pop_addAnimation:anim forKey:@"slide"]; </span></code></pre></td></tr></table></div></figure>


<p>通过处理CADisplayLink和相关的time-step管理，POPCustomAnimation使创建自定义动画和过渡变得更加容易。更多详情请查看header。</p>

<h5>属性</h5>

<p>属性由POPAnimatableProperty类指定动画。在这个例子中，我们创建一个spring动画，明确地设置与-[CALayer bounds]一致的动画属性：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>POPSpringAnimation *anim = [POPSpringAnimation animation]; 
</span><span class='line'>anim.property = [POPAnimatableProperty propertyWithName:kPOPLayerBounds]; </span></code></pre></td></tr></table></div></figure>


<p>这个框架提供了很多常见的层以及额外的视图动画属性。你可以通过创建类的新实例来动画一个自定义属性。在这个例子中，我声明了一个自定义音量属性：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>prop = [POPAnimatableProperty propertyWithName:@"com.foo.radio.vo 
</span><span class='line'>lume" initializer:^(POPMutableAnimatableProperty *prop) { 
</span><span class='line'>  // read value 
</span><span class='line'>  prop.readBlock = ^(id obj, CGFloat values[]) { 
</span><span class='line'>    values[0] = [obj volume]; 
</span><span class='line'>  }; 
</span><span class='line'>  // write value 
</span><span class='line'>  prop.writeBlock = ^(id obj, const CGFloat values[]) { 
</span><span class='line'>    [obj setVolume:values[0]]; 
</span><span class='line'>  }; 
</span><span class='line'>  // dynamics threshold 
</span><span class='line'>  prop.threshold = 0.01; 
</span><span class='line'>}]; 
</span><span class='line'>anim.property = prop; </span></code></pre></td></tr></table></div></figure>


<p>关于动画属性的完整列表以及声明自定义属性的更多信息，请看POPAnimatableProperty.h。</p>

<h5>调试</h5>

<p>这里有一些关于调试的技巧。Pop遵循模拟器的Toggle Slow Animations设置。试着用它放慢动画，将能更容易查看交互。
考虑给你的动画命名。当你通过日志查看动画或者调试动画时，这将使你更容易识别它们。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>anim.name = @“springOpen”; </span></code></pre></td></tr></table></div></figure>


<p>每个动画都有一个关联的tracer，它以一种快速高效的方式允许你记录所有的动画相关事件，还允许你在动画完成后对其进行查询和分析。下边的例子展示启动和配置tracer，以记录所有动画事件。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>POPAnimationTracer *tracer = anim.tracer; 
</span><span class='line'>tracer.shouldLogAndResetOnCompletion = YES; 
</span><span class='line'>[tracer start]; </span></code></pre></td></tr></table></div></figure>


<p>更多详情，请查看POPAnimationTracer.h。
假设已经安装了CocoaPods，这将在单元测试目标中包含必要的OCMock依赖。</p>

<h5>相关资源</h5>

<p><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html">Core Animation Programming Guide</a>
<a href="http://tapity.com/tutorial-getting-started-with-pop/">Tapity Tutorial – Getting Started with Pop</a>
<a href="https://github.com/facebook/tweaks">Tweaks – Easily adjust parameters for iOS apps in development</a>
<a href="http://facebook.github.io/rebound/">Rebound – Springs Animations for Android</a></p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[理解 OBJECTIVE-C RUNTIME]]></title>
        <link href="http://swplzj.github.io/blog/2014/11/11/li-jie-objective-c-runtime/"/>
        <updated>2014-11-11T21:34:12+08:00</updated>
        <id>http://swplzj.github.io/blog/2014/11/11/li-jie-objective-c-runtime</id>
        <content type="html"><![CDATA[<p>当人们初学 Cocoa/Objective-C 时，Objective-C Runtime 是被忽略的特性之一。原因是 Objective-C（这门语言）很容易在几小时内就熟悉，新学 Cocoa 的人花费他们大部分的时间学习 Cocoa 框架和适应它是如何工作的。然而每个人至少应该知道一些 runtime 的工作细节，需要比知道编译器会把 [target doMethodWith:var1]; 转换为 objc_msgSend(target,@selector(doMethodWith:),var1); 更深入一些。知道 Objective-C 正在做的会让你更深入的理解 Objective-C 和你正在运行的 app。我认为 Mac/iPhone 的开发者不管你现在是什么水平，都会有收获的。</p>

<!--more-->


<h4>Objective-C Runtime 是开源的</h4>

<p>Objective-C 是开源的，任何时候你都能从 <a href="http://opensource.apple.com.">http://opensource.apple.com.</a> 获取。事实上查看 Objective-C 源码是我理解它是如何工作的第一种方式，在这个问题上要比读苹果的文档要好。你可以下载适合 Mac OS X 10.6.2 的 objc4-437.1.tar.gz。（译注：最新objc4-551.1.tar.gz）</p>

<h4>动态 vs 静态语言</h4>

<p>Objective-C 是面相运行时的语言（runtime oriented language），就是说它会尽可能的把编译和链接时要执行的逻辑延迟到运行时。这就给了你很大的灵活性，你可以按需要把消息重定向给合适的对象，你甚至可以交换方法的实现，等等（译注：在 Objective-C 中调用一个对象的方法可以看成向一个对象发送消息, Method Swizzling 具体实现可以参看 jrswizzle ）。这就需要使用 runtime，runtime 可以做对象自省查看他们正在做的和不能做的（don’t respond to）并且合适的分发消息（译注：感兴趣的同学可以查看 NSObject 类的 – forwardingTargetForSelector: 和 – forwardInvocation: 方法。P.S. 不是 NSObject 协议！ ）。如果我们和 C 这样的语言对比。在 C 里，你从 main() 方法开始写然后就是从上到下的写逻辑了并按你写代码的顺序执行程序。一个 C 的结构体不能转发函数执行请求到其他的目标上（other targets）。很可能你的程序是这样的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt; stdio.h &gt;
</span><span class='line'>int main(int argc, const char **argv[])
</span><span class='line'>{        
</span><span class='line'>    printf("Hello World!");
</span><span class='line'>    return 0;
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>编译器解析，优化然后把优化后的代码转成汇编：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.text
</span><span class='line'> .align 4,0x90
</span><span class='line'> .globl _main
</span><span class='line'>_main:
</span><span class='line'>Leh_func_begin1:
</span><span class='line'> pushq %rbp
</span><span class='line'>Llabel1:
</span><span class='line'> movq %rsp, %rbp
</span><span class='line'>Llabel2:
</span><span class='line'> subq $16, %rsp
</span><span class='line'>Llabel3:
</span><span class='line'> movq %rsi, %rax
</span><span class='line'> movl %edi, %ecx 
</span><span class='line'> movl %ecx, -8(%rbp)
</span><span class='line'> movq %rax, -16(%rbp) 
</span><span class='line'> xorb %al, %al 
</span><span class='line'> leaq LC(%rip), %rcx 
</span><span class='line'> movq %rcx, %rdi 
</span><span class='line'> call _printf 
</span><span class='line'> movl $0, -4(%rbp) 
</span><span class='line'> movl -4(%rbp), %eax 
</span><span class='line'> addq $16, %rsp 
</span><span class='line'> popq %rbp 
</span><span class='line'> ret
</span><span class='line'>Leh_func_end1: 
</span><span class='line'> .cstring
</span><span class='line'>LC: 
</span><span class='line'> .asciz "Hello World!"</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>然后链接库并生成可执行程序（译注：如果你对 C 的编译链接过程还不熟悉可以参看 Deep C and C++）。要和 Objective-C 对比的话，处理过程很相似，生成的代码依赖于是否有 Objective-C Runtime 库。当刚学 Objective-C 时，我们最先了解的(最简单的那种)是 Objective-C 中用括号包起来的代码像这样…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[self doSomethingWithVar:var1];</span></code></pre></td></tr></table></div></figure>


<p>被转换为…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>objc_msgSend(self,@selector(doSomethingWithVar:),var1);</span></code></pre></td></tr></table></div></figure>


<p>但除了这些，我们就不知道之后在运行时做了什么了。</p>

<h4>Objective-C Runtime 是什么？</h4>

<p>Objective-C 的 Runtime 是一个运行时库（Runtime Library），它是一个主要使用 C 和汇编写的库，为 C 添加了面相对象的能力并创造了 Objective-C。这就是说它在类信息（Class information） 中被加载，完成所有的方法分发，方法转发，等等。Objective-C runtime 创建了所有需要的结构体，让 Objective-C 的面相对象编程变为可能。</p>

<h4>Objective-C Runtime 术语</h4>

<p>更深入之前，咱们先了解点术语。Mac 和 iPhone 开发者关心的有两个 runtime：Modern Runtime（现代的 Runtime） 和 Legacy Runtime（过时的 Runtime）。Modern Runtime：覆盖所有 64 位的 Mac OS X 应用和所有 iPhone OS 的应用。 Legacy Runtime: 覆盖其他的所有应用（所有 32 位的 Mac OS X 应用） Method 有 2 种基本类型的方法。Instance Method（实例方法）：以 ‘-’ 开始，比如 -(void)doFoo; 在对象实例上操作。Class Method（类方法）：以 ‘+’ 开始，比如 +(id)alloc。方法（Methods）和 C 的函数很像，是一组代码，执行一个小的任务，如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (NSString *)movieTitle
</span><span class='line'>{
</span><span class='line'>    return @"Futurama: Into the Wild Green Yonder";
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Selector 在 Objective-C 中 selector 只是一个 C 的数据结构，用于表示一个你想在一个对象上执行的 Objective-C 方法。在 runtime 中的定义像这样…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef struct objc_selector  *SEL; </span></code></pre></td></tr></table></div></figure>


<p>像这样使用…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SEL aSel = @selector(movieTitle); </span></code></pre></td></tr></table></div></figure>


<h4>Message（消息）</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[target getMovieTitleForObject:obj];</span></code></pre></td></tr></table></div></figure>


<p>消息是方括号 ‘[]’ 中的那部分，由你要向其发送消息的对象（target），你想要在上面执行的方法（method）还有你发送的参数（arguments）组成。Objective-C 的消息和 C 函数调用是不同的。事实上，你向一个对象发送消息并不意味着它会执行它。Object（对象）会检查消息的发送者，基于这点再决定是执行一个不同的方法还是转发消息到另一个目标对象上。Class 如果你查看一个类的runtime信息，你会看到这个…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef struct objc_class *Class;
</span><span class='line'>typedef struct objc_object {
</span><span class='line'>    Class isa;
</span><span class='line'>} *id; </span></code></pre></td></tr></table></div></figure>


<p>这里有几个事情。我们有一个 Objective-C 类的结构体和一个对象的结构体。objc_object 只有一个指向类的 isa 指针，就是我们说的术语 “isa pointer”（isa 指针）。这个 isa 指针是当你向对象发送消息时，Objective-C Runtime 检查一个对象并且查看它的类是什么然后开始查看它是否响应这些 selectors 所需要的一切。最后我么看到了 id 指针。默认情况下 id 指针除了告诉我们它们是 Objective-C 对象外没有其他用了。当你有一个 id 指针，然后你就可以问这个对象是什么类的，看看它是否响应一个方法，等等，然后你就可以在知道这个指针指向的是什么对象后执行更多的操作了。你可以在 LLVM/Clang 的文档中的 Block 中看到</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Block_literal_1 {
</span><span class='line'>    void *isa; // initialized to &_NSConcreteStackBlock or &_NSConcreteGlobalBlock    
</span><span class='line'>    int flags;    
</span><span class='line'>    int reserved;     
</span><span class='line'>    void (*invoke)(void *, ...); 
</span><span class='line'>    struct Block_descriptor_1 { 
</span><span class='line'>        unsigned long int reserved; // NULL     
</span><span class='line'>        unsigned long int size;  // sizeof(struct Block_literal_1)
</span><span class='line'>        // optional helper functions     
</span><span class='line'>        void (*copy_helper)(void *dst, void *src);
</span><span class='line'>        void (*dispose_helper)(void *src);     
</span><span class='line'>    } *descriptor;    
</span><span class='line'>    // imported variables
</span><span class='line'>}; </span></code></pre></td></tr></table></div></figure>


<p>Blocks 被设计为兼容 Objective-C 的 runtime，所以他们被作为对象对待，因此他们可以响应消息，比如 -retain，-release，-copy ，等等。IMP（方法实现 MethodImplementations）</p>

<p>typedef id (*IMP)(id self,SEL _cmd,&hellip;);
IMP 是指向方法实现的函数指针，由编译器为你生成。如果你新接触 Objective-C 你现在不需要直接接触这些，但是我们将会看到，Objective-C runtime 将如何调用你的方法的。Objective-C Classes（Objective-C 类） 那么什么是 Objective-C 类？在 Objective-C 中的一个类实现看起来像这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface MyClass : NSObject {
</span><span class='line'>    // vars
</span><span class='line'>    NSInteger counter;
</span><span class='line'>}
</span><span class='line'>// methods
</span><span class='line'>-(void)doFoo;
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>//但是 runtime 不只要追踪这些
</span><span class='line'>
</span><span class='line'>#if !__OBJC2__   
</span><span class='line'>    Class super_class                        OBJC2_UNAVAILABLE;
</span><span class='line'>    const char *name                         OBJC2_UNAVAILABLE;
</span><span class='line'>    long version                             OBJC2_UNAVAILABLE;
</span><span class='line'>    long info                                OBJC2_UNAVAILABLE;
</span><span class='line'>    long instance_size                       OBJC2_UNAVAILABLE;    
</span><span class='line'>    struct objc_ivar_list *ivars             OBJC2_UNAVAILABLE;    
</span><span class='line'>    struct objc_method_list **methodLists    OBJC2_UNAVAILABLE;    
</span><span class='line'>    struct objc_cache *cache                 OBJC2_UNAVAILABLE;    
</span><span class='line'>    struct objc_protocol_*protocols          OBJC2_UNAVAILABLE;
</span><span class='line'>#endif </span></code></pre></td></tr></table></div></figure>


<p>我们可以看到，一个类有其父类的引用，它的名字，实例变量，方法，缓存还有它遵循的协议。runtime 在响应类或实例的方法时需要这些信息。</p>

<h4>那么 Class 定义的是对象还是对象本身？它是如何实现的 （译注：读者需要区分 Class 和 class 是不同的，正如 Nil 和 nil 的用途是不同的）</h4>

<p>是的，之前我说过 Objective-C 类也是对象，runtime 通过创建 Meta Classes 来处理这些。当你发送一个消息像这样 [NSObject alloc] 你正在向类对象发送一个消息，这个类对象需要是 MetaClass 的实例，MetaClass 也是 root meta class 的实例。当你说继承自 NSObject 时，你的类指向 NSObject 作为自己的 superclass。然而，所有的 meta class 指向 root metaclass 作为自己的 superclass。所有的 meta class 只是简单的有一个自己响应的方法列表。所以当你向一个类对象发送消息如 [NSObject alloc]，然后实际上 objc_msgSend() 会检查 meta class 看看它是否响应这个方法，如果他找到了一个方法，就在这个 Class 对象上执行（译注：class 是一个实例对象的类型，Class 是一个类（class）的类型。对于完全的 OO 来说，类也是个对象，类是类类型(MetaClass)的实例，所以类的类型描述就是 meta class）。</p>

<h4>为什么我们继承自苹果的类</h4>

<p>从你开始 Cocoa 开发时，那些教程就说如继承自 NSObject 然后开始写一些代码，你享受了很多继承自苹果的类所带来的便利。有一件事你从未意识到的是你的对象被设置为使用 Objective-C 的 runtime。当我们为我们的类的一个实例分配了内存，像这样…</p>

<p>MyObject *object = [[MyObject alloc] init];
最先执行的消息是 +alloc。如果你查看下文档，它说“新的实例对象的 isa 实例变量被初始化为指向一个数据结构，那个数据结构描述了这个类；其他的实例变量被初始化为 0。”所以继承自苹果的类不仅仅是继承了一些重要的属性，也继承了能在内存中轻松分配内存的能力和在内存中创建满足 runtime 期望的对象结构（设置 isa 指针指向我们的类）。</p>

<h4>那么 Class Cache 是什么？（objc_cache *cache）</h4>

<p>当 Objective-C runtime 沿着一个对象的 isa 指针检查时，它会发现一个对象实现了许多的方法。然而你可能只调用其中一小部分的方法，也没有意义每次检查时搜索这个类的分发表（dispatch table）中的所有 selector。所以这个类实现了一个缓存，当你搜索一个类的分发表，并找到合适的 selector 后，就会把它放进缓存中。所以当 objc_msgSend() 在一个类中查找 selector 时会先查找类缓存。有个理论是，当你在一个类上调用了一个消息，你很可能之后还会调用它。所以如果我们考虑到这点，就意味着当我们有个子类继承自 NSObject 叫做 MyObject 并且运行了以下的代码</p>

<p>MyObject *obj = [[MyObject alloc] init];</p>

<p>@implementation MyObject
- (id)init {
    if(self = [super init]) {
        [self setVarA:@”blah”];  <br/>
    }
    return self;
}
@end
发生了以下的事：</p>

<p>(1) [MyObject alloc] 首先被执行。MyObject 没有实现 alloc 方法，所以我们不能在这个类中找到 +alloc 方法，然后沿着 superclass 指针会指向 NSObject。</p>

<p>(2) 我们询问 NSObject 是否响应 +alloc 方法，它可以。+alloc 检查消息的接收者类，是 MyObject，然后分配一块和我们的类同样大小的内存空间，并初始化它的 isa 指针指向 MyObject 类，我们现在有了一个实例对象，最终把类对象的 +alloc 方法加入 NSObject 的类缓存（class cache）中（lastly we put +alloc in NSObject’s class cache for the class object ）。</p>

<p>(3) 到现在为止，我们发送了一个类消息，但是现在我们发送一个实例消息，只是简单的调用 -init 或者我们设计的初始化方法。当然，我们的类会响应这个方法，所以 -(id)init 加入到缓存中。（译注：要是 MyObject 实现了 init 方法，就会把 init 方法加入到 MyObject 的 class cache 中，要是没有实现，只是因为继承才有了这个方法，init 方法还是会加入到 NSObject 的 class cache 中）。</p>

<p>(4) 然后 self = [super init] 被调用。super 是个 magic keyword，指向对象的父类，所以我们得到了 NSObject 并调用它的的 init 方法。这样可以确保 OOP（面相对象编程） 的继承功能正常，这个方法可以正确的初始化父类的变量，之后你（在子类中）可以初始化自己的变量，如果需要可以覆盖父类的方法。在 NSObject 的例子中，没什么重要的要做，但并不总是这样。有时要做些重要的初始化。比如…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import &lt;Foundation/Foundation.h&gt; 
</span><span class='line'>
</span><span class='line'>@interface MyObject : NSObject {
</span><span class='line'>    NSString *aString;
</span><span class='line'>} 
</span><span class='line'>    @property(retain) NSString *aString; 
</span><span class='line'>
</span><span class='line'>@end 
</span><span class='line'>
</span><span class='line'>@implementation MyObject
</span><span class='line'>
</span><span class='line'>-(id)init 
</span><span class='line'>{ 
</span><span class='line'>    if (self = [super init]) {
</span><span class='line'>        [self setAString:nil];
</span><span class='line'>    }
</span><span class='line'>    return self;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@synthesize aString;
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>int main (int argc, const char * argv[]) 
</span><span class='line'>{
</span><span class='line'>    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
</span><span class='line'>
</span><span class='line'>    id obj1 = [NSMutableArray alloc]; 
</span><span class='line'>    id obj2 = [[NSMutableArray alloc] init];   
</span><span class='line'>    id obj3 = [NSArray alloc]; 
</span><span class='line'>    id obj4 = [[NSArray alloc] initWithObjects:@"Hello",nil];
</span><span class='line'>
</span><span class='line'>    NSLog(@"obj1 class is %@",NSStringFromClass([obj1 class]));
</span><span class='line'>    NSLog(@"obj2 class is %@",NSStringFromClass([obj2 class]));
</span><span class='line'>    NSLog(@"obj3 class is %@",NSStringFromClass([obj3 class]));
</span><span class='line'>    NSLog(@"obj4 class is %@",NSStringFromClass([obj4 class]));
</span><span class='line'>
</span><span class='line'>    id obj5 = [MyObject alloc]; 
</span><span class='line'>    id obj6 = [[MyObject alloc] init];   
</span><span class='line'>
</span><span class='line'>    NSLog(@"obj5 class is %@",NSStringFromClass([obj5 class]));    
</span><span class='line'>    NSLog(@"obj6 class is %@",NSStringFromClass([obj6 class]));   
</span><span class='line'>
</span><span class='line'>    [pool drain];
</span><span class='line'>    return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>现在如果你新接触 Cocoa ，我让你猜会会输出什么，你可能会说</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSMutableArray
</span><span class='line'>NSMutableArray 
</span><span class='line'>NSArray
</span><span class='line'>NSArray
</span><span class='line'>MyObject
</span><span class='line'>MyObject</span></code></pre></td></tr></table></div></figure>


<p>但是，实际上是</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>obj1 class is __NSPlaceholderArray
</span><span class='line'>obj2 class is NSCFArray
</span><span class='line'>obj3 class is __NSPlaceholderArray
</span><span class='line'>obj4 class is NSCFArray
</span><span class='line'>obj5 class is MyObject
</span><span class='line'>obj6 class is MyObject</span></code></pre></td></tr></table></div></figure>


<p>这是因为在 Objective-C 中 +alloc 方法可能会返回某个类的对象，然后在 -init 中返回另一个类的对象。
（译注：感兴趣的同学可以看下这两篇文章：Class Clusters, Make Your Own Abstract Factory Class Cluster in Objective-C, 第二篇文章需要自备小梯子。)</p>

<h4>那么在 objc_msgSend 中发生了什么？</h4>

<p>事实上在 objc_msgSend() 中发生了许多事儿。假设我们有这样的代码…</p>

<p>[self printMessageWithString:@&ldquo;Hello World!&rdquo;];
它实际上会被编译器翻译为…</p>

<p>objc_msgSend(self,@selector(printMessageWithString:),@&ldquo;Hello World!&rdquo;);
我们沿着目标对象的 isa 指针查找，看看是否这个对象响应 @selector(printMessageWithString:) selector。假设我们在类的分发表或者缓存中找到了这个 selector，我们沿着函数指针并且执行它。这样 objcmsgSend() 就永远不会返回，它开始执行，然后沿着指向方法的指针，然后你的方法返回，这样看起来 objcmsgSend() 方法返回了。Bill Bumgarner 比我讲了更多 objc_msgSend() 的细节（部分1，部分2 和 部分3）。</p>

<p>概括下他说的，并且你已经看过了 Objective-C 的 runtime 代码…</p>

<p>检查忽略的 Selector 和短路（Short Circut）—— 显然，如果我们运行在垃圾回收机制下，我们可以忽略调用 -retain, -release, 等等。
检查 nil 对象（target）。和其他的语言不一样的是，在 Objective-C 中向 nil 发送消息是完全合法的，并且有些原因下你会愿意这么做的。假设我们有个非 nil 的对象，然后我们继续…
然后我们需要在这个类上找到 IMP，所以我们先从 class cache 中找起，如果找到了就沿着指针跳到这个函数。
如果没有在缓存中找到 IMP，然后去查找类的分发表，如果找到了，就沿着指针跳到这个函数。
如果 IMP 没有在缓存和类的分发表中找到，然后我们跳到转发机制。这意味着最终你的代码被编译器转换为 C 函数。你写的方法会像这样…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-(int)doComputeWithNum:(int)aNum </span></code></pre></td></tr></table></div></figure>


<p>会被翻译为…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int aClass_doComputeWithNum(aClass *self,SEL _cmd,int aNum) </span></code></pre></td></tr></table></div></figure>


<p>Objective-C Runtime 通过调用（invoking）指向这些方法的函数指针调用你的方法（call your methods）。现在，我要说的是，你不能直接调用这些被翻译的方法，但是 Cocoa 框架提供了获得函数指针的方法…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//declare C function pointer
</span><span class='line'>int (computeNum *)(id,SEL,int);
</span><span class='line'>
</span><span class='line'>//methodForSelector is COCOA & not ObjC Runtime
</span><span class='line'>//gets the same function pointer objc_msgSend gets
</span><span class='line'>computeNum = (int (*)(id,SEL,int))[target methodForSelector:@selector(    doComputeWithNum:)]; 
</span><span class='line'>
</span><span class='line'>//execute the C function pointer returned by the runtime
</span><span class='line'>computeNum(obj,@selector(doComputeWithNum:),aNum); </span></code></pre></td></tr></table></div></figure>


<p>通过这种方法，你可以直接访问这个函数，并且可以在运行时直接调用，甚至可以使用这个避开 runtime 的动态特性，如果你绝对需要确保一个方法被执行。Objective-C 就是用这种途径去调用你的方法的，但是使用的是 objc_msgSend()。</p>

<h4>Objective-C 消息转发</h4>

<p>在 Objective-C 中向一个不知道如何响应这个方法的对象发送消息是完全合法的（甚至可能是一种潜在的设计决定）。苹果的文档中给出的一个原因是模拟多继承，Objective-C 不是原生支持的，或者你可能只是想抽象你的设计并且隐藏幕后处理这些消息的其他对象/类。这一点是 runtime 非常需要的。它是这样做的 1. Runtime 检查了你的类和所有父类的 class cache 和分发表，但是没找到指定的方法。2. Objective_C 的 Runtime 会在你的类上调用 + (BOOL) resolveInstanceMethod:(SEL)aSEL。 这就给了你一个机会去提供一个方法实现并且告诉 runtime 你已经解析了这个方法，如果它开始查找，这回就会找到这个方法。你可以像这样实现…定义一个函数…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void fooMethod(id obj, SEL _cmd)
</span><span class='line'>{ 
</span><span class='line'>    NSLog(@"Doing Foo");
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后你可以像这样使用 class_addMethod() 解析它…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+(BOOL)resolveInstanceMethod:(SEL)aSEL
</span><span class='line'>{
</span><span class='line'>    if(aSEL == @selector(doFoo:))
</span><span class='line'>    {
</span><span class='line'>            class_addMethod([self class],aSEL,(IMP)fooMethod,"v@:");
</span><span class='line'>            return YES;
</span><span class='line'>    }
</span><span class='line'>    return [super resolveInstanceMethod];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在 class_addMethod() 最后一部分的 “v@:” 是方法的返回和参数类型。你可以在 Runtime Guide 的 Type Encoding 章节看到完整介绍。 3. Runtime 然后调用 – (id)forwardingTargetForSelector:(SEL)aSelector。这样做是为了给你一次机会（因为我们不能解析这个方法（参见上面的 #2））引导 Objective-C runtime 到另一个可以响应这个消息的对象上，在花费昂贵的处理过程调用 – (void)forwardInvocation:(NSInvocation *)anInvocation 之前调用这个方法也是更好的。你可以像这样实现</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (id)forwardingTargetForSelector:(SEL)aSelector
</span><span class='line'>{
</span><span class='line'>    if(aSelector == @selector(mysteriousMethod:))
</span><span class='line'>    {        
</span><span class='line'>        return alternateObject;
</span><span class='line'>    }
</span><span class='line'>    return [super forwardingTargetForSelector:aSelector];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>显然你不想从这个方法直接返回 self，否则可能会产生一个死循环。 4. Runtime 最后一次会尝试在目标对象上调用 – (void)forwardInvocation:(NSInvocation *)anInvocation。如果你从没看过 NSInvocation，它是 Objective-C 消息的对象形式。一旦你有了一个 NSInvocation 你可以改变这个消息的一切，包括目标对象，selector 和参数。所以你可以这样做…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-(void)forwardInvocation:(NSInvocation *)invocation
</span><span class='line'>{  
</span><span class='line'>    SEL invSEL = invocation.selector;    
</span><span class='line'>    if([altObject respondsToSelector:invSEL]) {        
</span><span class='line'>        [invocation invokeWithTarget:altObject];    
</span><span class='line'>    } else {        
</span><span class='line'>        [self doesNotRecognizeSelector:invSEL];    
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如果你继承自 NSObject，默认它的 – (void)forwardInvocation:(NSInvocation *)anInvocation 实现只是简单的调用 -doesNotRecognizeSelector:，你可以在最后一次机会里覆盖这个方法去做一些事情。（译注：对这块内容有兴趣的同学可以参见：<a href="http://www.cnblogs.com/biosli/p/NSObjectinherit2.html%EF%BC%89">http://www.cnblogs.com/biosli/p/NSObjectinherit2.html%EF%BC%89</a></p>

<h4>Non Fragile ivars（Modern Runtime）（非脆弱的 ivar）</h4>

<p>我们最近在 Modern Runtime 里得到的是 Non Fragile ivars 的概念。当编译你的类时，编译器生成了一个 ivar 布局，显示了在你的类中从哪可以访问你的 ivars，获取指向你的对象的指针，查看 ivar 与对象起始字节的偏移关系，和获取读入的变量类型的总共字节大小等一些底层的细节。所以你的 ivar 布局可能看起来像这样，左侧的数字是字节偏移量。</p>

<p>我们有了 NSObject 的 ivar 布局，然后我们继承自 NSObject 去扩展它并且添加了我们自己的 ivars。在苹果发布更新前这都工作的很好，但是 Mac OS X 10.6 发布后，就成了这样</p>

<p>你的自定义对象被剔除了因为我们有了一个重叠的父类。唯一可以防止这个的办法是如果苹果坚持之前的布局，如果他们这么做了，那么他们的框架就不能改进，因为他们的 ivar 布局被冻住了。在 fragile ivar 下你不得不重新编译你继承自苹果类的类来恢复兼容性。所以在非 fragile ivar 时，会发生生么？</p>

<p>使用非 fragile ivars 时，编译器生成和 fragile ivars 相同的 ivar 布局。然而当 runtime 检测到一个重叠的超类时，它调整你在这个类中新增的 ivar 的偏移量，这样在子类中新增加的那部分就显示出来了。</p>

<h4>Objective-C 关联对象</h4>

<p>最近在 Mac OS X 10.6 雪豹 中新引入了关联引用。Objective-C 不能动态的添加一些属性到对象上，和其他的一些原生支持这点的语言不一样。所以之前你都不得不努力为未来要增加的变量预留好空间。在 Mac OS X 10.6 中，Objective-C 的 Runtime 已经原生的支持这个功能了。如果我们想向一个已有的类添加变量，看起来像这样…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import &lt;Cocoa/Cocoa.h&gt; //Cocoa
</span><span class='line'>#include &lt;objc/runtime.h&gt; //objc runtime api’s 
</span><span class='line'>
</span><span class='line'>@interface NSView (CustomAdditions)
</span><span class='line'>@property(retain) NSImage *customImage;
</span><span class='line'>@end 
</span><span class='line'>
</span><span class='line'>@implementation NSView (CustomAdditions) 
</span><span class='line'>
</span><span class='line'>static char img_key; //has a unique address (identifier)
</span><span class='line'>
</span><span class='line'>- (NSImage *)customImage
</span><span class='line'>{    
</span><span class='line'>    return objc_getAssociatedObject(self,&img_key);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)setCustomImage:(NSImage *)image
</span><span class='line'>{    
</span><span class='line'>    objc_setAssociatedObject(self, &img_key,image, OBJC_ASSOCIATION_RETAIN);
</span><span class='line'>} 
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>objc_setAssociatedObject() 的选项，你可以在 runtime.h 文件中找到。
</span><span class='line'>
</span><span class='line'>/* Associated Object support. */ 
</span><span class='line'>
</span><span class='line'>/* objc_setAssociatedObject() options */
</span><span class='line'>enum {    
</span><span class='line'>    OBJC_ASSOCIATION_ASSIGN = 0,    
</span><span class='line'>    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1,    
</span><span class='line'>    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,    
</span><span class='line'>    OBJC_ASSOCIATION_RETAIN = 01401,    
</span><span class='line'>    OBJC_ASSOCIATION_COPY = 01403
</span><span class='line'>}; </span></code></pre></td></tr></table></div></figure>


<p>这些和 @property 语法中的选项意思一样。</p>

<h4>混和的 vTable Dispatch</h4>

<p>如果你看过 modern runtime 的代码，你会发现这个（在 objc-runtime-new.m 中）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/***********************************************************************
</span><span class='line'>* vtable dispatch
</span><span class='line'>* 
</span><span class='line'>* Every class gets a vtable pointer. The vtable is an array of IMPs.
</span><span class='line'>* The selectors represented in the vtable are the same for all classes
</span><span class='line'>*   (i.e. no class has a bigger or smaller vtable).
</span><span class='line'>* Each vtable index has an associated trampoline which dispatches to 
</span><span class='line'>*   the IMP at that index for the receiver class's vtable (after 
</span><span class='line'>*   checking for NULL). Dispatch fixup uses these trampolines instead 
</span><span class='line'>*   of objc_msgSend.
</span><span class='line'>* Fragility: The vtable size and list of selectors is chosen at launch 
</span><span class='line'>*   time. No compiler-generated code depends on any particular vtable 
</span><span class='line'>*   configuration, or even the use of vtable dispatch at all.
</span><span class='line'>* Memory size: If a class's vtable is identical to its superclass's 
</span><span class='line'>*   (i.e. the class overrides none of the vtable selectors), then 
</span><span class='line'>*   the class points directly to its superclass's vtable. This means 
</span><span class='line'>*   selectors to be included in the vtable should be chosen so they are 
</span><span class='line'>*   (1) frequently called, but (2) not too frequently overridden. In 
</span><span class='line'>*   particular, -dealloc is a bad choice.
</span><span class='line'>* Forwarding: If a class doesn't implement some vtable selector, that 
</span><span class='line'>*   selector's IMP is set to objc_msgSend in that class's vtable.
</span><span class='line'>* +initialize: Each class keeps the default vtable (which always 
</span><span class='line'>*   redirects to objc_msgSend) until its +initialize is completed.
</span><span class='line'>*   Otherwise, the first message to a class could be a vtable dispatch, 
</span><span class='line'>*   and the vtable trampoline doesn't include +initialize checking.
</span><span class='line'>* Changes: Categories, addMethod, and setImplementation all force vtable 
</span><span class='line'>*   reconstruction for the class and all of its subclasses, if the 
</span><span class='line'>*   vtable selectors are affected.
</span><span class='line'>**********************************************************************/ </span></code></pre></td></tr></table></div></figure>


<p>背后的思想是，runtime 尝试在这个 vtable 中存储最近被调用的 selectors，这样就可以提升你的应用的速度，因为它使用了比 objc_msgSend 更少的指令（fewer instructions）。vtable 中保存 16 个全局最经常调用的 selectors，事实上顺着代码往下看你可以发现垃圾回收和非垃圾回收类型程序的默认 selectors …</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[移动App架构设计]]></title>
        <link href="http://swplzj.github.io/blog/2014/10/25/yi-dong-app-jia-gou-she-ji/"/>
        <updated>2014-10-25T21:47:01+08:00</updated>
        <id>http://swplzj.github.io/blog/2014/10/25/yi-dong-app-jia-gou-she-ji</id>
        <content type="html"><![CDATA[<p>Native app的开发相比传统的项目迭代周期要短很多, 需求的变化也频繁一些, 在开发的不同生命周期里采用不同的架构模式可以有效的节约开发时间, 提高开发效率, 这篇文章介绍几种常用的架构模式:</p>

<!--more-->


<h4>表现层</h4>

<h5>基本的MVC</h5>

<p>移动app一般都是采用经典的mvc架构</p>

<table>
<thead>
<tr>
<th>层次      </th>
<th> 作用     </th>
<th> 设计原则</th>
</tr>
</thead>
<tbody>
<tr>
<td>模型层(model)</td>
<td>   封装了应用的一系列数据, 并定义了操作, 处理这些数据的逻辑和计算规则。</td>
<td>通过Notification,KVO对控制器进行反馈</td>
</tr>
<tr>
<td>视图层(view) </td>
<td>视图对象是一个应用中, 用户可以看到的对象. 视图对象知道如何绘制自己, 也能够响应用户的操作. 视图对象的主要目的之一是将应用模型对象中的数据显示出来, 并允许用户编辑该数据 </td>
<td>视图通过不能直接操作模型层, 通过target-action, delegate, dataSource和控制器进行反馈</td>
</tr>
<tr>
<td>控制器层(controller)    </td>
<td>控制器层是在视图层和若干个模型层的中间人</td>
<td> c可以直接操作模型层和视图层</td>
</tr>
</tbody>
</table>


<p><img src="https://github.com/uxyheaven/NativeAppFrameworkDesign/raw/master/image/mvc.png" alt="id1" /></p>

<h5>总结:</h5>

<ul>
<li>C对M：API</li>
<li>C对V：Outlet</li>
<li>V对C：Target-action， Delegate，Datasource</li>
<li>M对C：Notification，KVO</li>
</ul>


<h5>MVC的改进版 MVVM</h5>

<p>MVVM是在MVC的基础上多了一个View Model: 表示逻辑, 将 model 的数据转换为 view 可以呈现的东西. 适合大量展示类的App.</p>

<p><img src="https://github.com/uxyheaven/NativeAppFrameworkDesign/raw/master/image/mvvm.png" alt="id2" /></p>

<h5>HMVC</h5>

<p>Hierarchical MVC, 把客户端应用程序分解为有层次的父子关系的MVC, 反复应用这个模式, 形成结构化的客户端架构. 适合重型B/S架构的WebApp.</p>

<p>一个MVC模块由应用程序的一个模块抽象而成. 其中很重要的一个概念就是 Parent MVC , 它可以对应界面上的实体, 也可以是一个抽象的对象. 设想一个app 有标签栏, 工具栏, 导航栏, 主工作区, 对应到HMVC上就是这个app最底部的标签栏 是 Layer1, Layer2 导航栏,主要工作区, 工具栏. 如果觉得 Layer2 太复杂可以吧主要工作区放到 Layer3, 依次类推.</p>

<p>Controller 是功能模块的总控室, 它负责和子Controller或父Controller通信，并通知它的 View 处理改变界面显示, Model 处理一些业务逻辑或数据库访问操作. 如才的例子里, 点击了工具栏里的一个按钮, 工具栏的Controller 响应这个event, 发现是要切换主工作区, 工具栏做不了,就传递他的父Controller处理(如果父Controller也处理不了, 就继续往上传递)然后标签栏的Controller处理切换主工作区.</p>

<p>优点:</p>

<p>把程序分成了几个部分, 降低了依赖性
支持鼓励重用代码, 组件或者模块。
在今后的维护中, 提高了可扩展性。</p>

<p><img src="https://github.com/uxyheaven/NativeAppFrameworkDesign/raw/master/image/hmvc.png" alt="id3" /></p>

<h4>分层设计</h4>

<h5>三层架构</h5>

<p>我们在来看一下经典的三层架构</p>

<p>从上至下为</p>

<ul>
<li>表现层(UI)</li>
<li>业务逻辑层或称为领域层(BLL)</li>
<li>数据访问层(DAL)</li>
</ul>


<table>
<thead>
<tr>
<th>层次  </th>
<th> 作用    </th>
<th>设计原则</th>
</tr>
</thead>
<tbody>
<tr>
<td>表现层(UI) </td>
<td> 向用户展现特定业务数据，采集用户的输入信息和操 </td>
<td>用户至上，兼顾简洁；不包含任何业务相关的逻辑处理</td>
</tr>
<tr>
<td>业务逻辑层(BLL)    </td>
<td>从ＤＡＬ中获取数据, 在ＵＩ显示; 从ＵＩ中获取用户指令和数据, 执行业务逻辑或通过ＤＡＬ写入数据源 </td>
<td> 作为U层与Ｄ层的桥梁,目的在于展现清晰的函数结构, 只负责数据处理传递, 不涉及ＳＱＬ语句和ＡＤＯ.ＮＥＴ</td>
</tr>
<tr>
<td>数据访问层(DAL)    </td>
<td> 直接操作数据库，针对数据的增添 删除 修改 查找; 具体为业务逻辑层或表示层提供数据服务。</td>
<td> 专门操作数据库, 不考虑数据合法性. 数据库错误返回－1, 逻辑错误返回0, 并告知错误原因, 成功返回1</td>
</tr>
</tbody>
</table>


<p><img src="https://github.com/uxyheaven/NativeAppFrameworkDesign/raw/master/image/mvc_vs_3.png" alt="id4" /></p>

<p>然后呢,我们现在的架构则是
<img src="https://github.com/uxyheaven/NativeAppFrameworkDesign/raw/master/image/3.png" alt="id5" /></p>

<h5>四层架构</h5>

<p>在三层架构的基础上多了业务规则层, 通常的三层是把业务逻辑和业务规则合并为一个层，统称为业务层. 业务规则层的提出,既可以及时处理用户输入的不合法信息, 又可以及时处理数据库错误, 增大了业务逻辑层的结构清晰度, 让业务逻辑人员专心致志做逻辑.</p>

<p>从上至下为</p>

<ul>
<li>表现层</li>
<li>业务规则层</li>
<li>业务逻辑层或称为领域层</li>
<li>数据访问层</li>
</ul>


<table>
<thead>
<tr>
<th>层次  </th>
<th>作用</th>
<th>    设计原则</th>
</tr>
</thead>
<tbody>
<tr>
<td>业务规则层(ECL)</td>
<td>   对于UI层传下来的参数来说，检查合法性。</td>
<td>用户至上，兼顾简洁；不包含任何业务相关的逻辑处理</td>
</tr>
</tbody>
</table>


<h5>五层架构</h5>

<p>一般情况下, 我们的业务逻辑放在中间层, 那么对内部的这些大量种类繁多，使用方法也各异的不同的类的调用任务，就完全落到了表示层. 这样势必会增加表示层的代码量, 将表示层的任务复杂化, 和表示层只负责接受用户的输入并返回结果的任务不太相称, 并增加了层与层之间的耦合程度. 因此呢,我们需要增加接口去去统一的管理这些业务, 是设计模式中Facade模式的思想.</p>

<p>从上至下为</p>

<ul>
<li>表现层</li>
<li>业务外观层</li>
<li>业务规则层</li>
<li>业务逻辑层或称为领域层</li>
<li>数据访问层</li>
</ul>


<table>
<thead>
<tr>
<th>层次</th>
<th> 作用</th>
<th>     设计原则</th>
</tr>
</thead>
<tbody>
<tr>
<td>业务外观层 </td>
<td>为负责子系统中的一组接口提供一个一致而且简单的接口。</td>
<td></td>
</tr>
</tbody>
</table>


<h5>引入service层</h5>

<p>引入service层的架构和普通的分层架构的不同是: service层内部有数据, 可以单独运行.</p>

<p>service</p>

<p>从上至下为</p>

<ul>
<li>表现层</li>
<li>服务层(service)</li>
<li>数据访问层</li>
<li>业务逻辑层</li>
</ul>


<table>
<thead>
<tr>
<th>层次</th>
<th> 作用  </th>
<th> 设计原则</th>
</tr>
</thead>
<tbody>
<tr>
<td>表现层   </td>
<td>显示与用户的互交   </td>
<td></td>
</tr>
<tr>
<td>服务层   </td>
<td>service层提供表现层的业务逻辑入口,通过定义接口服务的形式,通过接口调用来完成.</td>
<td></td>
</tr>
<tr>
<td>业务逻辑层 </td>
<td>1接收服务层传来的DTO, 然后根据业务规则, 对传入的DTO进行加工, 返回加工后的信息 2 需要为每个对象提供业务行为, 并且这些对象之间是独立的 3 业务对象之间的交互流程通过服务层来组织</td>
<td></td>
</tr>
<tr>
<td>数据访问层 </td>
<td>本地数据远程数据的访问接口    </td>
<td></td>
</tr>
</tbody>
</table>


<h5>新秀VIPER</h5>

<p>viper这里不多说了,请想了解的自行搜索
<img src="https://github.com/uxyheaven/NativeAppFrameworkDesign/raw/master/image/viper.png" alt="id6" /></p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[iOS多线程操作：锁 互斥 同步]]></title>
        <link href="http://swplzj.github.io/blog/2014/10/17/ios-duo-xian-cheng-cao-zuo/"/>
        <updated>2014-10-17T23:03:45+08:00</updated>
        <id>http://swplzj.github.io/blog/2014/10/17/ios-duo-xian-cheng-cao-zuo</id>
        <content type="html"><![CDATA[<p>在iOS中有几种方法来解决多线程访问同一个内存地址的互斥同步问题，本文简单介绍：</p>

<h5>方法一，@synchronized(id anObject),(最简单的方法)</h5>

<p>会自动对参数对象加锁，保证临界区内的代码线程安全</p>

<!--more-->




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@synchronized(self)  
</span><span class='line'>{  
</span><span class='line'>     // 这段代码对其他 @synchronized(self) 都是互斥的         
</span><span class='line'>     // self 指向同一个对象  
</span><span class='line'>}   </span></code></pre></td></tr></table></div></figure>


<p></p>

<h5>方法二，NSLock</h5>

<p>NSLock对象实现了NSLocking protocol，包含几个方法：
lock，加锁
unlock，解锁
tryLock，尝试加锁，如果失败了，并不会阻塞线程，只是立即返回NO
lockBeforeDate:，在指定的date之前暂时阻塞线程（如果没有获取锁的话），如果到期还没有获取锁，则线程被唤醒，函数立即返回NO
比如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSLock *theLock = [[NSLock alloc] init];   
</span><span class='line'>if ([thelock lock])   
</span><span class='line'>{  
</span><span class='line'>   //do something here  
</span><span class='line'>   [theLock unlock];   
</span><span class='line'>}   </span></code></pre></td></tr></table></div></figure>


<h5>方法三，NSRecursiveLock，递归锁</h5>

<p>NSRecursiveLock，多次调用不会阻塞已获取该锁的线程。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> NSRecursiveLock *theLock = [[NSRecursiveLock alloc] init];   
</span><span class='line'> void MyRecursiveFunction(int value)   
</span><span class='line'>{   
</span><span class='line'>  [theLock lock];   
</span><span class='line'>  if (value != 0)   
</span><span class='line'>  &lt;span style=“font-size:14px;”&gt; &lt;/span&gt;{   
</span><span class='line'>    –value;   
</span><span class='line'>    MyRecursiveFunction(value);   
</span><span class='line'> }  
</span><span class='line'>   [theLock unlock];   
</span><span class='line'>}   
</span><span class='line'> MyRecursiveFunction(5);  </span></code></pre></td></tr></table></div></figure>


<p></p>

<h5>方法四，NSConditionLock，条件锁</h5>

<p>NSConditionLock，条件锁，可以设置条件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//公共部分  
</span><span class='line'>id condLock = [[NSConditionLock alloc] initWithCondition:NO_DATA];       
</span><span class='line'> //线程一，生产者  
</span><span class='line'> while(true) {   
</span><span class='line'>        [condLock lockWhenCondition:NO_DATA];   
</span><span class='line'>        //生产数据  
</span><span class='line'>        [condLock unlockWithCondition:HAS_DATA];   
</span><span class='line'>}     
</span><span class='line'> //线程二，消费者  
</span><span class='line'> while (true) {   
</span><span class='line'>        [condLock lockWhenCondition:HAS_DATA];   
</span><span class='line'>        //消费  
</span><span class='line'>        [condLock unlockWithCondition:NO_DATA];   
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<h5>方法五，NSDistributedLock，分布锁</h5>

<p>NSDistributedLock，分布锁，文件方式实现，可以跨进程
用tryLock方法获取锁。
用unlock方法释放锁。
如果一个获取锁的进程在释放锁之前挂了，那么锁就一直得不到释放了，此时可以通过breakLock强行获取锁。</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Xcode中系统库文件libz.dylib的作用]]></title>
        <link href="http://swplzj.github.io/blog/2014/09/24/xcodezhong-xi-tong-ku-wen-jian-libz-dot-dylibde-zuo-yong/"/>
        <updated>2014-09-24T22:08:21+08:00</updated>
        <id>http://swplzj.github.io/blog/2014/09/24/xcodezhong-xi-tong-ku-wen-jian-libz-dot-dylibde-zuo-yong</id>
        <content type="html"><![CDATA[<p>libz.dylib这个Xcode系统库文件经常用到。这个其实是个动态链接库。</p>

<p>后缀名为.dylib的文件是一个动态库，这个库是运行时加载而不是编译时加载。这个也说明了obj-C是运行时语言，也就是数据的类型不是在编译时确定的，而是在运行时确定的。</p>

<p>libz.dylib也是zip压缩解压缩的库，开发中经常用到的压缩库，PDF可以使用这个库文件来压缩。</p>

<!--more-->


<p>在Finder中查看，你会发现libz.dylib,libz.1.dylib,libz.1.1.3.dylib其实只是一个“替身”，实际上还是指向libz.1.2.5.dylib(Xcode 4.5)
A file ending in the extension .dylib is a dynamic library: it&rsquo;s a library that&rsquo;s loaded at runtime instead of at compile time. If you&rsquo;re familiar with DLLs from Windows or DSOs, it&rsquo;s more or less the same type of thing with a few twists. <a href="https://developer.apple.com/library/mac/#documentation/DeveloperTools/Conceptual/DynamicLibraries/000-Introduction/Introduction.html#//apple_ref/doc/uid/TP40001908-SW1">The Dynamic Library Programming Topics</a> section of the Mac OS X Developer Library covers all the details about the format and what you should be aware of.</p>

<p>libz.dylib is the dynamic library for Zlib, a general compression library. PDFs can (and usually do) use zlib to compress different aspects of the data contained within them, but accessing the PDF data at that level is pretty low-level, and higher-level libraries would abstract most of that type of stuff.</p>

<p>总结：</p>

<ol>
<li><p>.dylib意味着这是一个动态链接库.</p></li>
<li><p>libz.dylib是提供zip压缩解压缩的库</p></li>
<li><p>库的接口请#import &ldquo;zlib.h&rdquo;</p></li>
</ol>

]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[INSTANCETYPE 与 ID 的区别。]]></title>
        <link href="http://swplzj.github.io/blog/2014/09/21/instancetype-yu-id-de-qu-bie/"/>
        <updated>2014-09-21T18:31:05+08:00</updated>
        <id>http://swplzj.github.io/blog/2014/09/21/instancetype-yu-id-de-qu-bie</id>
        <content type="html"><![CDATA[<p>新的LLVM编译器为我们带来了ARC, Object Literal and Scripting, Auto Synthesis等特性，同时也引入了instancetype关键字。instancetype用来表示Related Result Types(相关返回类型)，那么它与id有什么不同呢？</p>

<p>根据Cocoa的命名惯例，init, alloc这类的方法，如果以id作为返回类型，会返回类本身的类型。</p>

<!--more-->




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface Person
</span><span class='line'>- (id)initWithName:(NSString *)name;
</span><span class='line'>+ (id)personWithName:(NSString *)name;</span></code></pre></td></tr></table></div></figure>


<p>但类方法的返回类型，LLVM(或者说Clang)却无法判断，我们来看一段代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// You may get two warnings if you're using MRC rather than ARC
</span><span class='line'>
</span><span class='line'>[[[NSArray alloc] init] mediaPlaybackAllowsAirPlay]; //  "No visible @interface for `NSArray` declares the selector `mediaPlaybackAllowsAirPlay`"
</span><span class='line'>[[NSArray array] mediaPlaybackAllowsAirPlay]; // It's OK. But You'll get a runtime error instead of a compile time one</span></code></pre></td></tr></table></div></figure>


<p>[NSArray array]除非显式转换为(NSArray *)，否则编译器不会有错误提示。如果使用instancetype就不会有这样的问题：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface Person
</span><span class='line'>- (instancetype)initWithName:(NSString *)name;
</span><span class='line'>+ (instancetype)personWithName:(NSString *)name;</span></code></pre></td></tr></table></div></figure>


<p>简单来说，instancetype关键字，保证了编译器能够正确推断方法返回值的类型。这种技术基本从iOS 5的UINavigationController里就开始应用了。</p>

<p>Clang的文档里提到 instancetype
is a contextual keyword that is only permitted in the result type of an Objective-C method. 也就是说，instancetype只能作为返回值，不能像id那样作为参数。</p>

<ul>
<li><a href="http://clang.llvm.org/docs/LanguageExtensions.html#objective-c-features">ClangClang Language Extensions</a></li>
<li><a href="http://nshipster.com/instancetype/">NSHipster</a></li>
<li><a href="http://www.jonmsterling.com/posts/2012-02-05-typed-collections-with-self-types-in-objective-c.html">Typed Collections With Self Types in Objective-C</a></li>
</ul>

]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[《抬起头吧》]]></title>
        <link href="http://swplzj.github.io/blog/2014/09/17/look-up/"/>
        <updated>2014-09-17T18:54:32+08:00</updated>
        <id>http://swplzj.github.io/blog/2014/09/17/look-up</id>
        <content type="html"><![CDATA[<h4>《Look up》-《抬起头吧》很有感触</h4>

<p>我有好几百位手机好友，但我仍然常常感到孤独；我每天跟他们聊天，但是好像他们并不了解真正的我。我的疑问来自于人与人之间的相处方式，我究竟是想看着他们的眼睛，还是手机上的昵称？直到有一天我发现，所谓的社交网络，并不完全是我们看到的那样。当我们打开电脑或者手机，其实也就关上了彼此心灵沟通的大门。</p>

<!--more-->


<p>假如有一天，你离开了网络，你就会发现，我们生活在一个令人困惑的世界中，一个我们本该主宰却被其掌控的世界，一个只顾自身利益、自身形象和自我推销的世界。在这个世界里，商人兜售着我们的个人信息。我们只会分享自己最好的一面，却不带任何真实感情。人生最快乐的事就是和别人共享生活的美好，但如果其他人都不在现场，我们还会一样快乐吗？</p>

<p>我们经常转发一些经过修饰和夸大的信息，只是为了得到别人的赞美。我们不停地刷新朋友圈。那些流行的文字和图片，让生活看起来似乎很精彩，好像就发生在你我身边，只是不知道是否有人真正用心去看。</p>

<p>远离网络吧，好好利用你的时间去看一本书，去陪一陪父母或者去旅行。活在当下，留心你身边的每一件事，把宝贵的时光放在真实和有意义的事情上，与亲朋好友在一起，和他们聊聊天说说话，不要再一直盯着你的手机和电脑。你需要的只是开始与人交谈。我无法忍受朋友聚餐的时候，每个人都在低头看手机。我们开始变得不合群，不再满足于和他人进行言语上的交流。</p>

<p>我们身边的孩子们，自从出生的那一刻开始，就看着我们活着像被操控的机器人。当我们还是个孩子时，我们不会和现在的孩子一样宅在家里，我们会与小伙伴们到户外尽情地去玩耍，即使鞋子穿破了，膝盖也受了伤，我们依然会尽情享受那些真正属于我们的欢乐时光。而现在，这一切变得少之又少，我们这代人都是只愿玩手机的低头一族。
抬起头吧，放下手机。看看你身边的人和事，让他们成为你今天的焦点，也让自己成为他们的焦点。我们需要真实的交谈。即使身在那里，改变已经发生。你不需要去告诉几百人你刚才做了些什么。</p>

<p>当你有了家庭，当你第一次抱起你的宝贝孩子，你想休息，他却让你整夜都无法入睡的时候，那是幸福和甜蜜的烦恼。当他长大成人并有了自己的家室，当有一天你抱起你的孙辈，他用稚嫩的声音叫你一声爷爷的时候，你会觉得时光飞逝人生苦短。当你回顾此生，你庆幸自己没有碌碌无为虚度光阴。</p>

<p>我们的生命有限，请不要将你的时光浪费在虚拟的网络上。</p>

<p>此刻，我们仍在不停地发送和接收无用的讯息。我们花上一整天的时间，却没有跟亲朋好友有任何真实的联系，没有什么比这更糟糕。别让你的生活追随浮华的网络。给人们你的爱，不要给他们你的赞，不要再为没有人关注而烦恼。
抬起头吧，放下手机。走出门去面对真实的世界，放下令你分心的一切。</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[iOS面试题-干货]]></title>
        <link href="http://swplzj.github.io/blog/2014/09/17/ios-mian-shi-ti/"/>
        <updated>2014-09-17T17:29:15+08:00</updated>
        <id>http://swplzj.github.io/blog/2014/09/17/ios-mian-shi-ti</id>
        <content type="html"><![CDATA[<p>很全的面试题，有百度腾讯各大公司的真题，快来看看吧。</p>

<h4>Part 1</h4>

<p>1、说说OC内存管理；</p>

<p>2、ASIRequest是什么；</p>

<p>3、怎么输出json字符串；</p>

<!--more-->


<p>4、说说http头部有哪些内容；</p>

<p>5、说说OC生命周期；
6、运用第三方框架，到时候出了问题，谁来负责</p>

<p>7、自己写一个strcpy函数</p>

<p>8、字母统计(如，输入字符串“aabbbccddddaaaaa”，输出“2a3b2c4d5a”)</p>

<p>9、你用过哪些框架</p>

<p>10、进程与线程的区别</p>

<p>11、开辟线程的方式有哪些</p>

<p>12、实现进程同步的方式有哪些，或者说你怎么实现进程同步</p>

<p>13、请你谈谈同步和异步，用操作系统知识解释一下。</p>

<p>14、请你谈谈多态</p>

<p>15、怎么将数据写入文件（归档，解当）</p>

<p>16、写一个set方法（retain和copy权限）</p>

<p>17、</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Int* fun()
</span><span class='line'>{
</span><span class='line'>   Int a=5;
</span><span class='line'>   Int * p=&a;
</span><span class='line'>   Return p;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>请问：在主函数里面调用fun函数，这样可以吗？如果不可以，请说明为什么，并给出一种解决方案。</p>

<p>18、在颜色中，有GB8888和 GB565标准，前者32位，其中R占8位，G占8位，B占8位，透明度占8位，后者16位，其中，R占5位，G占6位，B占5位。现在要将一个GB8888类型颜色转换成GB565类型，怎么转</p>

<p>19、判断一个数是否为素数</p>

<p>20、优化代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   1、int a=b*4;
</span><span class='line'>   2、int a=b/8;
</span><span class='line'>   3、int a=b%1;
</span><span class='line'>   4、int a=b%16;
</span><span class='line'>   5、int a=(b*3)/8;</span></code></pre></td></tr></table></div></figure>


<p> 21、什么是内联函数？</p>

<p>22、assign,retain,copy的区别</p>

<p>23、面向对象的特性</p>

<p>24、实现一个view从顶部移到底部的动画</p>

<p>25、#ff3344转换成uicolor</p>

<p>26、判断一个链表是否有循环</p>

<p>27、写一个代理类</p>

<p>28、进程之间是怎么通信的</p>

<p>29、oc有哪些优点和缺点</p>

<p>30、什么时候用delegate,什么时候用Notification?</p>

<p>31、写一个”标准”宏MIN ，这个宏输入两个参数并返回较小的一个。当你写下面的代码时会发生什么事？</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>least = MIN(*p++, b);</span></code></pre></td></tr></table></div></figure>


<p>32、MVC模式的理解</p>

<p>33、堆和栈的区别</p>

<p>34、自动释放池是什么,如何工作</p>

<p>35、写一个委托的interface</p>

<p>36、objective-c的内存管理</p>

<p>37、什么是Notification？</p>

<p>38、下面的声明都是什么意思？</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>constint a;
</span><span class='line'>intconst a;
</span><span class='line'>constint *a;
</span><span class='line'>int* const a;
</span><span class='line'>intconst * a const;</span></code></pre></td></tr></table></div></figure>


<h4>Part 2</h4>

<p><img src="http://nsobject.u.qiniudn.com/wp-content/uploads/2014/11/ssss.jpg" alt="id1" /></p>

<h4>Part 3</h4>

<p>这个是百度面试</p>

<p>Objective C runtime library：Objective C的对象模型，block的底层实现结构，消息发送，消息转发，这些都需要背后C一层的描述，内存管理。
Core Data：中多线程中处理大量数据同步时的操作。
Multithreading：什么时候处理多线程，几种方式，优缺点。
Delegate， Notification，KVO， other 优缺点
设计一个progress bar解决方案，追问到 Core Graphic、CGPath、maskLayer。
设计一个popup view被追问到 keyWindow、UIWindow的layer、UIView hierarchy。
从设计模式的角度分析Delegate、Notification、KVO的区别。被追问到自己写的library和开源的项目中用到哪些设计模式，为什么使用，有哪些好处和坏处，现在能否改进。
算是问题3的追问，设计一个方案来检测KVO的同步异步问题。willChange和 didChange的不同点，然后被追问到有没有其他地方也有类似情况，被追问到Core Data 中falut object。
这个是问题4的追问，设计一个KVO系统。
Multithreading，什么时候采用Multithreading方案，以及理由。追问到系统还有哪些在后台运行的thread，被追问到view life cycle、iOS6之后的不同以及内存管理。
Multithreading中常常遇到的问题，追问到死锁，优先级翻转，线程池等。
百度有一个亿级别的APP需要统计用户行为的日志系统。不使用数据库，只是使用普通文件，设计一个系统。被追问到内存映射文件。这个问题本来是服务器的问题，我表示从来没做过，回答很瞎。
算法考了2个。一个是如何求2个集合的交集。另一个是百亿数据中查找相同的数字以及出现的次数。</p>

<p>为什么做Windows Mobile
为什么改iOS
为什么来百度
为什么iPhone 可以成功，那些吸引你
如何看待AppStore 现在的生态圈</p>

<h4>Part 4</h4>

<p>下边是腾讯初级工程师面试题</p>

<p>1。简述push原理，push的证书和其它的右什么不一样？
2。viewcontroller的一些方法的说明viewDidLoad, viewWillDisappear, viewWillAppear方法的 顺序和 作用？
3。frame 和 bounds 的 区别 ，bound的大小改变frame 改变吗？
4。sqlite中插入特殊字符的方法和接收到处理方法。
5。谈谈你对数组和连表认识，还有你是怎么用他们的？
6。冒泡算法。
7。socket编程简述
8。asihttp代码原理 ，异步请求的原理，异步请求最大数目，为什么只能这么多？
9。http请求方式？
10。uiview的圆角属性设置方法。
（m_mainImgView.layer.cornerRadius = 6;
m_mainImgView.layer.masksToBounds = YES;）
11。 masksToBounds属性的作用。（决定子layer是否被当前layer的边界剪切。默认是NO。）</p>

<p>1Objective－C内部的实现
2CALayer和View的关系
3 http协议，tcp/ip
4 UITableView的那些元素是可以自定义的？
5 c语言的，定义变量，比如int，在什么情况下，其最大值是不同的
6 比较32位平台和64位平台不同
7 iphone app为什么会被打回来，如何避免??
8 为啥离开团队？
1.针对第一个问题，可以看看下面的教程</p>

<p>Object c研究的比较深入的教程</p>

<p><a href="http://www.cnblogs.com/yaski/">http://www.cnblogs.com/yaski/</a></p>

<p>第6章写的尤其好</p>

<p><a href="http://archive.cnblogs.com/a/1886332/">KVO/KVC 实现机理分析</a></p>

<p>2.CALayer和View的关系
一个UIView包含CALayer树，CALayer是一个数据模型，包含了一些用于显示的对象，但本身不用于显示。</p>

<p>CALayer相当于photoshop的一个层，很多动画可以通过设置CALayer来实现。据说有人用CALayer显示图片来播放视频。</p>

<p>Core animation应该是用CAlayer来实现各种动画。</p>

<h4>Part 5</h4>

<p>下面都是很基础的问题</p>

<h5>1、Object-C有多继承吗？没有的话用什么代替？cocoa 中所有的类都是NSObject 的子类</h5>

<p>多继承在这里是用protocol 委托代理 来实现的</p>

<p>你不用去考虑繁琐的多继承 ,虚基类的概念.</p>

<p>ood的多态特性 在 obj-c 中通过委托来实现.</p>

<h5>2、Object-C有私有方法吗？私有变量呢？</h5>

<p>objective-c – 类里面的方法只有两种, 静态方法和实例方法. 这似乎就不是完整的面向对象了,按照OO的原则就是一个对象只暴露有用的东西. 如果没有了私有方法的话, 对于一些小范围的代码重用就不那么顺手了. 在类里面声名一个私有方法</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface Controller : NSObject { NSString *something; }
</span><span class='line'>+ (void)thisIsAStaticMethod;
</span><span class='line'>– (void)thisIsAnInstanceMethod;
</span><span class='line'>@end
</span><span class='line'>@interface Controller (private) -
</span><span class='line'>(void)thisIsAPrivateMethod;
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>@private可以用来修饰私有变量</p>

<p>在Objective‐C中，所有实例变量默认都是私有的，所有实例方法默认都是公有的</p>

<h5>3、关键字const什么含义？</h5>

<p>const意味着”只读”，下面的声明都是什么意思？</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>const int a;
</span><span class='line'>int const a;
</span><span class='line'>const int *a;
</span><span class='line'>int * const a;
</span><span class='line'>int const * a const;</span></code></pre></td></tr></table></div></figure>


<p>前两个的作用是一样，a是一个常整型数。第三个意味着a是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。第四个意思a是一个指向整 型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型 数是不可修改的，同时指针也是不可修改的）。</p>

<p>结论：</p>

<p>•; 关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用const的程序员很少会留下的垃圾让别人来清理的。）</p>

<p>•; 通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。</p>

<p>•; 合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。</p>

<p>欲阻止一个变量被改变，可以使用 const 关键字。在定义该 const 变量时，通常需要对它进行初</p>

<p>始化，因为以后就没有机会再去改变它了；</p>

<p>（2）对指针来说，可以指定指针本身为 const，也可以指定指针所指的数据为 const，或二者同时指定为 const；</p>

<p>（3）在一个函数声明中，const 可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；</p>

<p>（4）对于类的成员函数，若指定其为 const 类型，则表明其是一个常函数，不能修改类的成员变量；</p>

<p>（5）对于类的成员函数，有时候必须指定其返回值为 const 类型，以使得其返回值不为“左值”。</p>

<h5>4、关键字volatile有什么含义？并给出三个不同例子？</h5>

<p>一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到</p>

<p>这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：</p>

<p>并行设备的硬件寄存器（如：状态寄存器）</p>

<p>一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)</p>

<p>多线程应用中被几个任务共享的变量</p>

<p>一个参数既可以是const还可以是volatile吗？解释为什么。</p>

<p>一个指针可以是volatile 吗？解释为什么。</p>

<p>下面是答案：</p>

<p>是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。</p>

<p>是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。</p>

<h5>5.static作用？</h5>

<p>函数体内 static 变量的作用范围为该函数体，不同于 auto 变量，该变量的内存只被分配一次，</p>

<p>因此其值在下次调用时仍维持上次的值；</p>

<p>（2）在模块内的 static 全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；</p>

<p>（3）在模块内的 static 函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明</p>

<p>它的模块内；</p>

<p>（4）在类中的 static 成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；</p>

<p>（5）在类中的 static 成员函数属于整个类所拥有，这个函数不接收 this 指针，因而只能访问类的static 成员变量。</p>

<h5>6、#import和#include的区别，@class代表什么？</h5>

<p>@class一般用于头文件中需要声明该类的某个实例变量的时候用到，在m文件中还是需要使用#import</p>

<p>而#import比起#include的好处就是不会引起重复包含</p>

<h5>7、线程和进程的区别？</h5>

<p>进程和线程都是由操作系统所体会的程序运行的基本单元，系统利用该基本单元实现系统对应用的并发性。</p>

<p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一 个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程 序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p>

<h5>8、堆和栈的区别？</h5>

<p>管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。</p>

<p>申请大小：</p>

<p>栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因 此，能从栈获得的空间较小。</p>

<p>堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</p>

<p>碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出</p>

<p>分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。</p>

<p>分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的。</p>

<h5>9、Object-C的内存管理？</h5>

<p>1.当你使用new,alloc和copy方法创建一个对象时,该对象的保留计数器值为1.当你不再使用该对象时,你要负责向该对象发送一条release或autorelease消息.这样,该对象将在使用寿命结束时被销毁.</p>

<p>2.当你通过任何其他方法获得一个对象时,则假设该对象的保留计数器值为1,而且已经被设置为自动释放,你不需要执行任何操作来确保该对象被清理.如果你打算在一段时间内拥有该对象,则需要保留它并确保在操作完成时释放它.</p>

<p>3.如果你保留了某个对象,你需要(最终)释放或自动释放该对象.必须保持retain方法和release方法的使用次数相等.</p>

<h5>10、为什么很多内置的类，如TableViewController的delegate的属性是assign不是retain？</h5>

<p>循环引用</p>

<p>所有的引用计数系统，都存在循环应用的问题。例如下面的引用关系：</p>

<p>对象a创建并引用到了对象b.</p>

<p>对象b创建并引用到了对象c.</p>

<p>对象c创建并引用到了对象b.</p>

<p>这时候b和c的引用计数分别是2和1。当a不再使用b，调用release释放对b的所有权，因为c还引用了b，所以b的引用计数为1，b不会被释放。b不释放，c的引用计数就是1，c也不会被释放。从此，b和c永远留在内存中。</p>

<p>这种情况，必须打断循环引用，通过其他规则来维护引用关系。比如，我们常见的delegate往往是assign方式的属性而不是retain方式的属 性，赋值不会增加引用计数，就是为了防止delegation两端产生不必要的循环引用。如果一个UITableViewController 对象a通 过retain获取了UITableView对象b的所有权，这个UITableView对象b的delegate又是a，如果这个delegate是 retain方式的，那基本上就没有机会释放这两个对象了。自己在设计使用delegate模式时，也要注意这点。</p>

<h5>11、定义属性时，什么情况使用copy、assign、retain？</h5>

<p>assign用于简单数据类型，如NSInteger,double,bool,</p>

<p>retain和copy用于对象，</p>

<p>copy用于当a指向一个对象，b也想指向同样的对象的时候，如果用assign，a如果释放，再调用b会crash,如果用copy 的方式，a和b各自有自己的内存，就可以解决这个问题。</p>

<p>retain 会使计数器加一，也可以解决assign的问题。</p>

<p>另外：atomic和nonatomic用来决定编译器生成的getter和setter是否为原子操作。在多线程环境下，原子操作是必要的，否则有可能引起错误的结果。</p>

<p>加了atomic，setter函数会变成下面这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (property != newValue) {
</span><span class='line'>  [property release];
</span><span class='line'>  property = [newValue retain];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>12、对象是什么时候被release的？</h5>

<p>引用计数为0时。</p>

<p>autorelease实际上只是把对release的调用延迟了，对于每一个Autorelease，系统只是把该Object放入了当前的 Autorelease pool中，当该pool被释放时，该pool中的所有Object会被调用Release。对于每一个Runloop，系统会 隐式创建一个Autorelease pool，这样所有的release pool会构成一个象CallStack一样的一个栈式结构，在每一个 Runloop结束时，当前栈顶的Autorelease pool会被销毁，这样这个pool里的每个Object（就是autorelease的对 象）会被release。那什么是一个Runloop呢？一个UI事件，Timer call， delegate call， 都会是一个新的 Runloop</p>

<h5>13、iOS有没有垃圾回收？</h5>

<p>Objective-C 2.0也是有垃圾回收机制的，但是只能在Mac OS X Leopard 10.5 以上的版本使用。</p>

<h5>14、tableView的重用机制？</h5>

<p>查看UITableView头文件，会找到NSMutableArray<em>  visiableCells，和 NSMutableDictnery</em> reusableTableCells两个结构。visiableCells内保存当前显示的 cells，reusableTableCells保存可重用的cells。</p>

<p>TableView显示之初，reusableTableCells为空，那么 tableView dequeueReusableCellWithIdentifier:CellIdentifier返回nil。开始的cell都 是通过</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier] </span></code></pre></td></tr></table></div></figure>


<p>来创建，而且cellForRowAtIndexPath只是调用最大显示cell数的次数。</p>

<p>比如：有100条数据，iPhone一屏最多显示10个cell。程序最开始显示TableView的情况是：</p>

<p>1.用 [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier] 创建10次cell，并给cell指定同样的重用标识(当然，可以为不同显示类型的cell指定不同的标识)。并且10个cell全部都加入到 visiableCells数组，reusableTableCells为空。</p>

<p>2.向下拖动tableView，当cell1完全移出屏幕，并且cell11(它也是alloc出来的，原因同上)完全显示出来的时候。 cell11加入到visiableCells，cell1移出visiableCells，cell1加入到reusableTableCells。</p>

<p>3.接着向下拖动tableView，因为reusableTableCells中已经有值，所以，当需要显示新的 cell，cellForRowAtIndexPath再次被调用的时 候，tableView dequeueReusableCellWithIdentifier:CellIdentifier，返回cell1。 cell1加入到visiableCells，cell1移出reusableTableCells；cell2移出 visiableCells，cell2加入到reusableTableCells。之后再需要显示的Cell就可以正常重用了。</p>

<h5>15、ViewController 的loadView、viewDidLoad、viewDidUnload分别是什么时候调用的，在自定义ViewCointroller时在这几个函数中应该做什么工作？</h5>

<p>由init、loadView、viewDidLoad、viewDidUnload、dealloc的关系说起</p>

<p>init方法</p>

<p>在init方法中实例化必要的对象（遵从LazyLoad思想）</p>

<p>init方法中初始化ViewController本身</p>

<p>loadView方法</p>

<p>当view需要被展示而它却是nil时，viewController会调用该方法。不要直接调用该方法。</p>

<p>如果手工维护views，必须重载重写该方法</p>

<p>如果使用IB维护views，必须不能重载重写该方法</p>

<p>loadView和IB构建view</p>

<p>你在控制器中实现了loadView方法，那么你可能会在应用运行的某个时候被内存管理控制调用。 如果设备内存不足的时候， view 控制器会收到 didReceiveMemoryWarning的消息。 默认的实现是检查当前控制器的view是否在使用。如果它的view不在当前正在使用的 view hierarchy里面，且你的控制器实现了loadView方法，那么这个view将被release, loadView方法将被再次调用 来创建一个新的view。</p>

<p>viewDidLoad方法</p>

<p>viewDidLoad 此方法只有当view从nib文件初始化的时候才被调用。</p>

<p>重载重写该方法以进一步定制view</p>

<p>在iPhone OS 3.0及之后的版本中，还应该重载重写viewDidUnload来释放对view的任何索引</p>

<p>viewDidLoad后调用数据Model</p>

<p>viewDidUnload方法</p>

<p>当系统内存吃紧的时候会调用该方法（注：viewController没有被dealloc）</p>

<p>内存吃紧时，在iPhone OS 3.0之前didReceiveMemoryWarning是释放无用内存的唯一方式，但是OS 3.0及以后viewDidUnload方法是更好的方式</p>

<p>在该方法中将所有IBOutlet（无论是property还是实例变量）置为nil（系统release view时已经将其release掉了）</p>

<p>在该方法中释放其他与view有关的对象、其他在运行时创建（但非系统必须）的对象、在viewDidLoad中被创建的对象、缓存数据 等 release对象后，将对象置为nil（IBOutlet只需要将其置为nil，系统release view时已经将其release掉了）</p>

<p>一般认为viewDidUnload是viewDidLoad的镜像，因为当view被重新请求时，viewDidLoad还会重新被执行</p>

<p>viewDidUnload中被release的对象必须是很容易被重新创建的对象（比如在viewDidLoad或其他方法中创建的对象），不要release用户数据或其他很难被重新创建的对象</p>

<p>dealloc方法</p>

<p>viewDidUnload和dealloc方法没有关联，dealloc还是继续做它该做的事情</p>

<h5>16、ViewController的didReceiveMemoryWarning是在什么时候调用的？默认的操作是什么？</h5>

<p>当程序接到内存警告时View Controller将会收到这个消息：didReceiveMemoryWarning</p>

<p>从iOS3.0开始，不需要重载这个函数，把释放内存的代码放到viewDidUnload中去。</p>

<p>这个函数的默认实现是:检查controller是否可以安全地释放它的view(这里加粗的view指的是controller的view属性)，比如view本身没有superview并且可以被很容易地重建（从nib或者loadView函数）。</p>

<p>如果view可以被释放，那么这个函数释放view并调用viewDidUnload。</p>

<p>你可以重载这个函数来释放controller中使用的其他内存。但要记得调用这个函数的super实现来允许父类（一般是UIVIewController）释放view。</p>

<p>如果你的ViewController保存着view的子view的引用，那么，在早期的iOS版本中，你应该在这个函数中来释放这些引用。而在iOS3.0或更高版本中，你应该在viewDidUnload中释放这些引用。</p>

<h5>17、列举Cocoa中常见的集中多线程的实现，并谈谈多线程安全的几种解决办法，一般什么地方会用到多线程？</h5>

<p>NSThread,GCD等。尽量用上层分装好的方法去实现多线程而不是手动调用NSThread。</p>

<h5>18、怎么理解MVC，在Cocoa中MVC是怎么实现的？</h5>

<p>Model: 代表你的应用程序是什么（不是怎么展现）</p>

<p>Controller: 控制你的Model怎么展现给用户（UI逻辑）</p>

<p>View: Controller的奴隶。。。</p>

<p>1 Model，Controller，View相互通讯的规则：</p>

<p>Controller可以直接和Model通信</p>

<p>Controller也可以直接和View通信</p>

<p>Model和View永远不能直接通信</p>

<p>iOS中View和Controller的通信是透明和固定的，主要通过outlet和action实现</p>

<p>View使用Delegate接口和Controller同步信息</p>

<p>View不直接和数据通信，使用dataSource接口从Controller处获取数据</p>

<p>View的delegate和dataSource一般就是Controller</p>

<p>Controller负责为View翻译和格式化Model的数据</p>

<p>Model使用Notification &amp; KVO的方式分发数据更新信息，Controller可以有选择的监听自己感兴趣的信息。</p>

<p>View也可以监听广播信息，但一般不是Model发出的信息</p>

<p>一个完整的App就是很多MVC的集合</p>

<h5>19、delegate和notification区别，分别在什么情况下使用？</h5>

<p>Delegate:</p>

<p>消息的发送者(sender)告知接收者(receiver)某个事件将要发生，delegate同意然然后发送者响应事件，delegate机制使得接收者可以改变发送者的行为。通常发送者和接收者的关系是直接的一对多的关系。</p>

<p>Notification:</p>

<p>消息的发送者告知接收者事件已经发生或者将要发送，仅此而已，接收者并不能反过来影响发送者的行为。通常发送者和接收者的关系是间接的多对多关系。</p>

<ol>
<li><p>效率肯定是delegate比nsnotification高。</p></li>
<li><p>delegate方法比notification更加直接，最典型的特征是，delegate方法往往需要关注返回值，也就是delegate方法 的结果。比如-windowShouldClose:，需要关心返回的是yes还是no。所以delegate方法往往包含should这个很传神的词。 也就是好比你做我的delegate，我会问你我想关闭窗口你愿意吗？你需要给我一个答案，我根据你的答案来决定如何做下一步。相反 的，notification最大的特色就是不关心接受者的态度，我只管把通告放出来，你接受不接受就是你的事情，同时我也不关心结果。所以 notification往往用did这个词汇，比如NSWindowDidResizeNotification，那么nswindow对象放出这个 notification后就什么都不管了也不会等待接受者的反应。</p></li>
</ol>


<p>1）两个模块之间联系不是很紧密，就用notification传值，例如多线程之间传值用notificaiton。</p>

<p>2）delegate只是一种较为简单的回调，且主要用在一个模块中，例如底层功能完成了，需要把一些值传到上层去，就事先把上层的函数通过 delegate传到底层，然后在底层call这个delegate，它们都在一个模块中，完成一个功能，例如 说 NavgationController 从 B 界面到A 点返回按钮 (调用popViewController方法) 可以用delegate 比较好。</p>

<h5>20、self.跟self什么区别？</h5>

<h5>21、id、nil代表什么？</h5>

<p>id和void <em>并非完全一样。在上面的代码中，id是指向struct objc_object的一个指针，这个意思基本上是说，id是一个指向任何 一个继承了Object（或者NSObject）类的对象。需要注意的是id是一个指针，所以你在使用id的时候不需要加星号。比如id foo=nil 定义了一个nil指针，这个指针指向NSObject的一个任意子类。而id </em>foo=nil则定义了一个指针，这个指针指向另一个指针，被指向的这个 指针指向NSObject的一个子类。</p>

<p>nil和C语言的NULL相同，在objc/objc.h中定义。nil表示一个Objctive-C对象，这个对象的指针指向空（没有东西就是空）。</p>

<p>首字母大写的Nil和nil有一点不一样，Nil定义一个指向空的类（是Class，而不是对象）。</p>

<p>SEL是“selector”的一个类型，表示一个方法的名字</p>

<p>Method（我们常说的方法）表示一种类型，这种类型与selector和实现(implementation)相关</p>

<p>IMP定义为 id (*IMP) (id, SEL, …)。这样说来， IMP是一个指向函数的指针，这个被指向的函数包括id(“self”指针)，调用的SEL（方法名），再加上一些其他参数.说白了IMP就是实现方法。</p>

<h5>22、内存管理 Autorelease、retain、copy、assign的set方法和含义？</h5>

<p>1，你初始化(alloc/init)的对象，你需要释放(release)它。例如：</p>

<p>NSMutableArray aArray = [[NSArray alloc] init]; 后，需要 [aArray release];</p>

<p>2，你retain或copy的，你需要释放它。例如：</p>

<p>[aArray retain] 后，需要 [aArray release];</p>

<p>3，被传递(assign)的对象，你需要斟酌的retain和release。例如：</p>

<p>obj2 = [[obj1 someMethod] autorelease];</p>

<p>对象2接收对象1的一个自动释放的值，或传递一个基本数据类型(NSInteger，NSString)时：你或希望将对象2进行retain，以防止它在被使用之前就被自动释放掉。但是在retain后，一定要在适当的时候进行释放。</p>

<p>关于索引计数(Reference Counting)的问题</p>

<p>retain值 = 索引计数(Reference Counting)</p>

<p>NSArray对象会retain(retain值加一)任何数组中的对象。当NSArray被卸载(dealloc)的时候，所有数组中的对象会被 执行一次释放(retain值减一)。不仅仅是NSArray，任何收集类(Collection Classes)都执行类似操作。例如 NSDictionary，甚至UINavigationController。</p>

<p>Alloc/init建立的对象，索引计数为1。无需将其再次retain。</p>

<p>[NSArray array]和[NSDate date]等“方法”建立一个索引计数为1的对象，但是也是一个自动释放对象。所以是本地临时对象，那么无所谓了。如果是打算在全Class中使用的变量(iVar)，则必须retain它。</p>

<p>缺省的类方法返回值都被执行了“自动释放”方法。(*如上中的NSArray)</p>

<p>在类中的卸载方法“dealloc”中，release所有未被平衡的NS对象。(*所有未被autorelease，而retain值为1的)</p>

<h5>23、类别的作用？</h5>

<p>有时我们需要在一个已经定义好的类中增加一些方法，而不想去重写该类。比如，当工程已经很大，代码量比较多，或者类中已经包住很多方法，已经有其他代码调用了该类创建对象并使用该类的方法时，可以使用类别对该类扩充新的方法。</p>

<p>注意：类别只能扩充方法，而不能扩充成员变量。</p>

<h5>24、委托（举例）</h5>

<p>委托代理（degegate），顾名思义，把某个对象要做的事情委托给别的对象去做。那么别的对象就是这个对象的代理，代替它来打理要做的事。反映到程序中，首先要明确一个对象的委托方是哪个对象，委托所做的内容是什么。</p>

<p>委托机制是一种设计模式，在很多语言中都用到的，这只是个通用的思想，网上会有很多关于这方面的介绍。</p>

<p>那么在苹果开发过程中，用到委托的程序实现思想如下，我主要拿如何在视图之间传输信息做个例子。</p>

<p>譬如：在两个页面（UIIview视图对象）实现传值，用委托（delegate）可以很好做到！</p>

<p>方法：</p>

<p>类A</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface A：UIView
</span><span class='line'>id transparendValueDelegate;
</span><span class='line'>@property(nomatic, retain) id transparendValueDelegate;
</span><span class='line'>@end
</span><span class='line'>@implemtion A
</span><span class='line'>@synthesize transparendValueDelegate
</span><span class='line'>-(void)Function
</span><span class='line'>{
</span><span class='line'>  NSString* value = @”hello”;
</span><span class='line'>  //让代理对象执行transparendValue动作
</span><span class='line'>  [transparendValueDelegate transparendValue: value];
</span><span class='line'>}
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>类B</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface B：UIView
</span><span class='line'>NSString* value;
</span><span class='line'>@end
</span><span class='line'>@implemtion B
</span><span class='line'>-(void)transparendValue:(NSString*)fromValue
</span><span class='line'>{
</span><span class='line'>  value = fromValue;
</span><span class='line'>  NSLog(@”the value is %@ “,value);
</span><span class='line'>}
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>//下面的设置A代理委托对象为B</p>

<p>//在定义A和B类对象处：</p>

<p>A* a = [[A alloc] init];</p>

<p>B* b = [[B alloc] init];</p>

<ol type="a">
<li>transparendValueDelegate = b;//设置对象a代理为对象b</li>
</ol>


<p>这样在视图A和B之间可以通过委托来传值！</p>

<h5>25、retainCount？</h5>

<h5>26.属性readwrite，readonly，assign，retain，copy，nonatomic 各是什么作用，在那种情况下用</h5>

<p>assign：指定setter方法用简单的赋值，这是默认操作。你可以对标量类型（如int）使用这个属性。你可以想象一个float，它不是一个对象，所以它不能retain、copy。</p>

<p>retain：指定retain应该在后面的对象上调用，前一个值发送一条release消息。你可以想象一个NSString实例，它是一个对象，而且你可能想要retain它。</p>

<p>copy：指定应该使用对象的副本（深度复制），前一个值发送一条release消息。基本上像retain，但是没有增加引用计数，是分配一块新的内存来放置它。</p>

<p>readonly：将只生成getter方法而不生成setter方法（getter方法没有get前缀）。</p>

<p>readwrite：默认属性，将生成不带额外参数的getter和setter方法（setter方法只有一个参数）。</p>

<p>atomic：对于对象的默认属性，就是setter/getter生成的方法是一个原子操作。如果有多个线程同时调用setter的话，不会出现某一个线程执行setter全部语句之前，另一个线程开始执行setter的情况，相关于方法头尾加了锁一样。</p>

<p>nonatomic：不保证setter/getter的原子性，多线程情况下数据可能会有问题。</p>

<h5>27.类变量的@protected ,@private ,@public ,@package声明各有什么含义</h5>

<p>Objective-C 对存取权限的设定。也是变量的作用域。</p>

<p>protected 该类和所有的子类中的方法可以直接访问这样的变量，这是默认的。</p>

<p>private — 该类中的方法可以访问这样的变量，子类不可以。 public — 除了自己和子类中的方法外，也可以被其他类或者其他模块中的方法所访问。开放性最大。 package — 对于64位图像，这样的成员变量可以在实现这个类的图像中随意访问。</p>

<h5>28.浅拷贝和深拷贝区别是什么</h5>

<p>简单的来说就是，在有指针的情况下，浅拷贝只是增加了一个指针指向已经存在的内存，而深拷贝就是增加一个指针并且申请一个新的内存，使这个增加的指针指向这个新的内存，采用深拷贝的情况下，释放内存的时候就不会出现在浅拷贝时重复释放同一内存的错误</p>

<h5>29.Cocoa中与虚基类的概念么？怎么简洁的实现</h5>

<h5>30.NSString 和 NSMutableString 有什么区别</h5>

<p>NSString相当于一个const char* 不可以改变。</p>

<p>而 NSMutableString相当于 char* 可以改变内部的内容。</p>

<h5>31.自动释放池跟GC有什么区别？iPhone上有GC么？［pool release］ 和［pool drain］有什么区别</h5>

<p>”Autorelease Pools”(自动释放池)在应用中的使用技巧。</p>

<p>1，Autorelease Pools概要</p>

<p>一个”Autorelease Pool”实例中“包含”其它各种调用了”autorelease”方法的对象。当它释放时，其中所有被管理对象都会收 到”relrease”的消信。注意，同一个对象可以被多次调用”autorelease”方法，并可以放到同一个”Autorelease Pool” 中。引入这个自动释放池机制，对象的”autorelease”方法代替”relrease”方法可以延长它的生命周期，直接到当 前”Autorelrease Pool”释放。如果想让此对象的生命周期超过”Autorelease Pool”，还可以再次”retain”，呵 呵，有意思吧?且让我慢慢道来。</p>

<p>Cocoa总是认为当前至少有一个”Autorelease Pool”对象是可用的。若此对象并不存在，你调用的”autorelease”的所有对象都不会被自动释放掉，可想而知，造成内存泄露。Cocoa把这个错误信息写入日志??仅仅是为了以后分析。</p>

<p>你可以用”alloc”与”init”方法创建一个”NSAutoreleasePool”对象，并且可以调用”release”或”drain” （”release”与”drain”的区别是”drain”在有GC的环境中会引起GC回收操作，”release”反之。但在非GC环境中，两者相 同。官方的说法是为了程序的兼容性，应该考虑用”drain”代替”release”，）方法来回收它（调用它的”autorelease” 或”retain”方法会引起异常）。在一个完整的上下文最后”Autorelease Pool”对象应该被”release”掉（在方法内或一段循环 体内创建的”Autorelease Pool”对象）。</p>

<p>“Autorelease Pools”的所有实例在栈中管理（我们暂时叫他“自动释放池栈”），并且它们是可以被嵌套的（父生子，子生孙。。。子子孙 孙 ^_^）。例如，当我们创建一个”Autorelease Pool”对象后，它就被自动放到“自动释放池栈”的栈顶。当本池对象回收时，它就随之从 这个栈中POP掉。那么也就是说，当任何一个对象调用”autorelease”方法后，它会被放入当前线程中当前栈顶的自动释放池中。</p>

<p>接下来我们聊聊”Autorelease Pools”的嵌套问题。在你的应用中，你可以任意多的创建”Autorelease Pool”对象，而这些 对象被当前线程的“自动释放池栈”所管理。那么除了一个接一个的顺序创建并销毁它的情况外，还有一种使用方式，就是嵌套式的创建与使用。例如：在你的主函 数创建了一个”autorelease pool”，然后又调用了创建了”autorelease pool”实例的其它方法；或是在外循环中创建 了”Autorelease Pool”的实例，而内循环中也做了相同的事情。有意思吧，呵呵，嵌套的机制使父Pool实例释放后，它的所有子Pool也 将释放。但这里还存在一些副作用，后续文章会详细讨论。</p>

<p>“Application kit”在一个事件循环里会自动创建一个”autorelease pool”。像鼠标键的按下与释放，所以你编写的代码通常不需要考虑太多这方面的事情。当然，有以下三种情况你会创建与销毁自己的Pool实例：</p>

<p>1，应用不是基于”Application Kit”，像”Command-line tool”，因为它并没有内置的”autorelease pools”的支持。</p>

<p>2，创建线程，你必需在线程开始时创建一个”Autorelease Pool”实例。反之，会造成内存池露（会在以后的文章详细说明线程与池的技巧）。</p>

<p>3，一个循环内创建了太多的临时对象，你应该为他们创建一个”Autorelease Pool”对象，并在下次循还前销毁它们。</p>

<p>2，自动释放池中的”Non-AppKit”应用</p>

<p>在”Non-AppKit”应用中使用自动释放池的机制其实是相当简单的事情。你仅仅需要在main()起始处创建”Autorelease Pool” 对象，并在结尾处释放掉它。就像在Xcode的Foundation Tool的创建模版里写的一样。这个确保你在应用生命周期内至少有一 个”Autorelease Pool”是可用的。但是，这也使所有在此期间的所有”autorelease”的对象都必需在应用结束后才被释放。这也许 会引起在应用的使用中不断的增长，所以，你仍然考虑在不同的作用域创建新的”Autorelease Pool”。</p>

<p>大多应用中都存在各种级别的循环机制。在这些应用中，你可以在每个循环内的开头创建一个”Autorelease Pool”对象，并在结尾处释放掉它。</p>

<p>例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void main()
</span><span class='line'>{
</span><span class='line'>  NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
</span><span class='line'>  NSArray *args = [[NSProcessInfo processInfo] arguments];
</span><span class='line'>  unsigned count, limit = [args count];
</span><span class='line'>  for (count = 0; count &lt; limit; count++)
</span><span class='line'>  {
</span><span class='line'>  NSAutoreleasePool *loopPool = [[NSAutoreleasePool alloc] init];
</span><span class='line'>  NSString *fileContents;
</span><span class='line'>  NSString *fileName;
</span><span class='line'>  fileName = [args objectAtIndex:count];
</span><span class='line'>  fileContents = [[[NSString alloc] initWithContentsOfFile:fileName] autorelease];
</span><span class='line'>  // this is equivalent to using stringWithContentsOfFile:
</span><span class='line'>  [loopPool release];
</span><span class='line'>  }
</span><span class='line'>  [pool drain];
</span><span class='line'>  exit (EXIT_SUCCESS);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在命令行中处理所有以参数传来的文件。一次循环处理一个文件。在循环的开头创建一个”NSAutoreleasePool”对象，并在循环结束时释放掉。 因此，任何在其中创建并调用“autorelease”的对象都将添加到这个Pool实例中，当本池被释放后，这些对象也将被回收。注意，任何在作用域内 创建的”autoreleased”对象（像”fileName”），虽然并没有显示的调用”autorelease”方法，但都将被当前池所管理并释 放。</p>

<h5>32.C和obj-c 如何混用</h5>

<p>1）obj-c的编译器处理后缀为m的文件时，可以识别obj-c和c的代码，处理mm文件可以识别obj-c,c,c++代码，但cpp文件必须只能用c/c++代码，而且cpp文件include的头文件中，也不能出现obj-c的代码，因为cpp只是cpp</p>

<p>2)在mm文件中混用cpp直接使用即可，所以obj-c混cpp不是问题</p>

<p>3）在cpp中混用obj-c其实就是使用obj-c编写的模块是我们想要的。</p>

<p>如果模块以类实现，那么要按照cpp class的标准写类的定义，头文件中不能出现obj-c的东西，包括#import cocoa的。实现文件中，即类的实现代码中可以使用obj-c的东西，可以import,只是后缀是mm。</p>

<p>如果模块以函数实现，那么头文件要按c的格式声明函数，实现文件中，c++函数内部可以用obj-c，但后缀还是mm或m。</p>

<p>总结：只要cpp文件和cpp include的文件中不包含obj-c的东西就可以用了，cpp混用obj-c的关键是使用接口，而不能直接使用实现代 码，实际上cpp混用的是obj-c编译后的o文件，这个东西其实是无差别的，所以可以用。obj-c的编译器支持cpp</p>

<h5>33.响应者链是什么</h5>

<p>响应者链是Application Kit事件处理架构的中心机制。它由一系列链接在一起的响应者对象组成，事件或者动作消息可以沿着这些对象进行传 递。如图6-20显示的那样，如果一个响应者对象不能处理某个事件或动作－也就是说，它不响应那个消息，或者不认识那个事件，则将该消息重新发送给链中的 下一个响应者。消息沿着响应者链向上、向更高级别的对象传递，直到最终被处理（如果最终还是没有被处理，就会被抛弃）。</p>

<p>当Application Kit在应用程序中构造对象时，会为每个窗口建立响应者链。响应者链中的基本对象是NSWindow对象及其视图层次。在视图层次中级别较低的视图将比级别更高的视图优先获得处理事件或动作消息的机会。NSWindow中保有一个第一响应者的引用，它通常是当前窗口中处于选择状态的视图，窗口通常把响应消息的机会首先给它。对于事件消息，响应者链通常以发生事件的窗口对应的NSWindow对象作为结束，虽然其它对象也可以作为下一个响应者被加入到NSWindow对象的后面。</p>

<h5>34..UIscrollVew用到了什么设计模式？还能再foundation库中找到类似的吗？</h5>

<p>组合模式composition，所有的container view都用了这个模式</p>

<p>观察者模式observer，所有的UIResponder都用了这个模式。</p>

<p>模板(Template)模式，所有datasource和delegate接口都是模板模式的典型应用</p>

<h5>33. .timer的间隔周期准吗？为什么？怎样实现一个精准的timer?</h5>

<p>NSTimer可以精确到50-100毫秒.</p>

<p>NSTimer不是绝对准确的,而且中间耗时或阻塞错过下一个点,那么下一个点就pass过去了</p>

<p>此份面试题包含40个题目，是现在网上能搜索到的一个比较热的一份，但是答案并不是很详细和完整，基本答案来着cocoaChina，和一些自己的补充。</p>

<h5>34.Difference between shallow copy and deep copy?</h5>

<p>浅复制和深复制的区别？</p>

<p>答案：浅层复制：只复制指向对象的指针，而不复制引用对象本身。</p>

<p>深层复制：复制引用对象本身。</p>

<p>意思就是说我有个A对象，复制一份后得到A_copy对象后，对于浅复制来说，A和A_copy指向的是同一个内存资源，复制的只不过是是一个指针，对象本身资源</p>

<p>还是只有一份，那如果我们对A_copy执行了修改操作,那么发现A引用的对象同样被修改，这其实违背了我们复制拷贝的一个思想。深复制就好理解了,内存中存在了</p>

<p>两份独立对象本身。</p>

<p>用网上一哥们通俗的话将就是：</p>

<p>浅复制好比你和你的影子，你完蛋，你的影子也完蛋</p>

<p>深复制好比你和你的克隆人，你完蛋，你的克隆人还活着。</p>

<h5>35.What is advantage of categories? What is difference between implementing a category and inheritance?</h5>

<p>类别的作用？继承和类别在实现中有何区别？</p>

<p>答案：category 可以在不获悉，不改变原来代码的情况下往里面添加新的方法，只能添加，不能删除修改。</p>

<p>并且如果类别和原来类中的方法产生名称冲突，则类别将覆盖原来的方法，因为类别具有更高的优先级。</p>

<p>类别主要有3个作用：</p>

<p>(1)将类的实现分散到多个不同文件或多个不同框架中。</p>

<p>(2)创建对私有方法的前向引用。</p>

<p>(3)向对象添加非正式协议。</p>

<p>继承可以增加，修改或者删除方法，并且可以增加属性。</p>

<h5>36.Difference between categories and extensions?</h5>

<p>类别和类扩展的区别。</p>

<p>答案：category和extensions的不同在于后者可以添加属性。另外后者添加的方法是必须要实现的。</p>

<p>extensions可以认为是一个私有的Category。</p>

<h5>37.Difference between protocol in objective c and interfaces in java?</h5>

<p>oc中的协议和java中的接口概念有何不同？</p>

<p>答案：OC中的代理有2层含义，官方定义为 formal和informal protocol。前者和Java接口一样。</p>

<p>informal protocol中的方法属于设计模式考虑范畴，不是必须实现的，但是如果有实现，就会改变类的属性。</p>

<p>其实关于正式协议，类别和非正式协议我很早前学习的时候大致看过，也写在了学习教程里</p>

<p>“非正式协议概念其实就是类别的另一种表达方式“这里有一些你可能希望实现的方法，你可以使用他们更好的完成工作”。</p>

<p>这个意思是，这些是可选的。比如我门要一个更好的方法，我们就会申明一个这样的类别去实现。然后你在后期可以直接使用这些更好的方法。</p>

<p>这么看，总觉得类别这玩意儿有点像协议的可选协议。”</p>

<p>现在来看，其实protocal已经开始对两者都统一和规范起来操作，因为资料中说“非正式协议使用interface修饰“，</p>

<p>现在我们看到协议中两个修饰词：“必须实现(@requied)”和“可选实现(@optional)”。</p>

<h5>38.What are KVO and KVC?</h5>

<p>答案：kvc:键 - 值编码是一种间接访问对象的属性使用字符串来标识属性，而不是通过调用存取方法，直接或通过实例变量访问的机制。</p>

<p>很多情况下可以简化程序代码。apple文档其实给了一个很好的例子。</p>

<p>kvo:键值观察机制，他提供了观察某一属性变化的方法，极大的简化了代码。</p>

<p>具体用看到嗯哼用到过的一个地方是对于按钮点击变化状态的的监控。</p>

<p>比如我自定义的一个button</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[self addObserver:self forKeyPath:@"highlighted" options:0 context:nil];
</span><span class='line'>- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context
</span><span class='line'>{
</span><span class='line'>  if([keyPath isEqualToString:@"highlighted"] ) {
</span><span class='line'>  [self setNeedsDisplay];
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>对于系统是根据keypath去取的到相应的值发生改变，理论上来说是和kvc机制的道理是一样的。</p>

<p>对于kvc机制如何通过key寻找到value：</p>

<p>“当通过KVC调用对象时，比如：[self valueForKey:@”someKey”]时，程序会自动试图通过几种不同的方式解析这个调用。首先 查找对象是否带有 someKey 这个方法，如果没找到，会继续查找对象是否带有someKey这个实例变量（iVar），如果还没有找到，程序会继续 试图调用 -(id) valueForUndefinedKey:这个方法。如果这个方法还是没有被实现的话，程序会抛出一个 NSUndefinedKeyException异常错误。</p>

<p>(cocoachina.com注：Key-Value Coding查找方法的时候，不仅仅会查找someKey这个方法，还会查找 getsomeKey这个方法，前面加一个get，或者<em>someKey以及</em>getsomeKey这几种形式。同时，查找实例变量的时候也会不仅仅查找 someKey这个变量，也会查找_someKey这个变量是否存在。）</p>

<p>设计valueForUndefinedKey:方法的主要目的是当你使用-(id)valueForKey方法从对象中请求值时，对象能够在错误发生前，有最后的机会响应这个请求。这样做有很多好处，下面的两个例子说明了这样做的好处。“</p>

<p>来至cocoa，这个说法应该挺有道理。</p>

<p>因为我们知道button却是存在一个highlighted实例变量.因此为何上面我们只是add一个相关的keypath就行了，</p>

<p>可以按照kvc查找的逻辑理解，就说的过去了。</p>

<h5>39.What is purpose of delegates?</h5>

<p>代理的作用？</p>

<p>答案：代理的目的是改变或传递控制链。允许一个类在某些特定时刻通知到其他类，而不需要获取到那些类的指针。可以减少框架复杂度。</p>

<p>另外一点，代理可以理解为java中的回调监听机制的一种类似。</p>

<h5>40.What are mutable and immutable types in Objective C?</h5>

<p>oc中可修改和不可以修改类型。</p>

<p>答案：可修改不可修改的集合类。这个我个人简单理解就是可动态添加修改和不可动态添加修改一样。</p>

<p>比如NSArray和NSMutableArray。前者在初始化后的内存控件就是固定不可变的，后者可以添加等，可以动态申请新的内存空间。</p>

<h5>41.When we call objective c is runtime language what does it mean?</h5>

<p>我们说的oc是动态运行时语言是什么意思？</p>

<p>答案：多态。 主要是将数据类型的确定由编译时，推迟到了运行时。</p>

<p>这个问题其实浅涉及到两个概念，运行时和多态。</p>

<p>简单来说，运行时机制使我们直到运行时才去决定一个对象的类别，以及调用该类别对象指定方法。</p>

<p>多态：不同对象以自己的方式响应相同的消息的能力叫做多态。意思就是假设生物类（life）都用有一个相同的方法-eat;</p>

<p>那人类属于生物，猪也属于生物，都继承了life后，实现各自的eat，但是调用是我们只需调用各自的eat方法。</p>

<p>也就是不同的对象以自己的方式响应了相同的消息（响应了eat这个选择器）。</p>

<p>因此也可以说，运行时机制是多态的基础？~~~</p>

<h5>42.what is difference between NSNotification and protocol?</h5>

<p>通知和协议的不同之处？</p>

<p>答案：协议有控制链(has-a)的关系，通知没有。</p>

<p>首先我一开始也不太明白，什么叫控制链（专业术语了~）。但是简单分析下通知和代理的行为模式，我们大致可以有自己的理解</p>

<p>简单来说，通知的话，它可以一对多，一条消息可以发送给多个消息接受者。</p>

<p>代理按我们的理解，到不是直接说不能一对多，比如我们知道的明星经济代理人，很多时候一个经济人负责好几个明星的事务。</p>

<p>只是对于不同明星间，代理的事物对象都是不一样的，一一对应，不可能说明天要处理A明星要一个发布会，代理人发出处理发布会的消息后，别称B的</p>

<p>发布会了。但是通知就不一样，他只关心发出通知，而不关心多少接收到感兴趣要处理。</p>

<p>因此控制链（has-a从英语单词大致可以看出，单一拥有和可控制的对应关系。</p>

<h5>43.What is push notification?</h5>

<p>什么是推送消息？</p>

<p>答案：太简单，不作答~~~~~~~~~~</p>

<p>这是cocoa上的答案。</p>

<p>其实到不是说太简单，只是太泛泛的一个概念的东西。就好比说，什么是人。</p>

<p>推送通知更是一种技术。</p>

<p>简单点就是客户端获取资源的一种手段。</p>

<p>普通情况下，都是客户端主动的pull。</p>

<p>推送则是服务器端主动push。</p>

<h5>44.Polymorphism？</h5>

<p>关于多态性</p>

<p>答案：多态，子类指针可以赋值给父类。</p>

<p>这个题目其实可以出到一切面向对象语言中，</p>

<p>因此关于多态，继承和封装基本最好都有个自我意识的理解，也并非一定要把书上资料上写的能背出来。</p>

<p>最重要的是转化成自我理解。</p>

<h5>45.Singleton?</h5>

<p>对于单例的理解</p>

<p>答案：11，12题目其实出的有点泛泛的感觉了，可能说是编程语言需要或是必备的基础。</p>

<p>基本能用熟悉的语言写出一个单例，以及可以运用到的场景或是你编程中碰到过运用的此种模式的框架类等。</p>

<p>进一步点，考虑下如何在多线程访问单例时的安全性。</p>

<h5>46.What is responder chain?</h5>

<p>说说响应链</p>

<p>答案： 事件响应链。包括点击事件，画面刷新事件等。在视图栈内从上至下，或者从下之上传播。</p>

<p>可以说点事件的分发，传递以及处理。具体可以去看下touch事件这块。因为问的太抽象化了</p>

<p>严重怀疑题目出到越后面就越笼统。</p>

<h5>47.Difference between frame and bounds?</h5>

<p>frame和bounds有什么不同？</p>

<p>答案:frame指的是：该view在父view坐标系统中的位置和大小。（参照点是父亲的坐标系统）</p>

<p>bounds指的是：该view在本身坐标系统中 的位置和大小。（参照点是本身坐标系统）</p>

<h5>48.Difference between method and selector?</h5>

<p>方法和选择器有何不同？</p>

<p>答案：selector是一个方法的名字，method是一个组合体，包含了名字和实现.</p>

<p>详情可以看apple文档。</p>

<h5>49.Is there any garbage collection mechanism in Objective C.?</h5>

<p>OC的垃圾回收机制？</p>

<p>答案： OC2.0有Garbage collection，但是iOS平台不提供。</p>

<p>一般我们了解的objective-c对于内存管理都是手动操作的，但是也有自动释放池。</p>

<p>但是差了大部分资料，貌似不要和arc机制搞混就好了。</p>

<p>求更多~~</p>

<h5>50.NSOperation queue?</h5>

<p>答案：存放NSOperation的集合类。</p>

<p>操作和操作队列，基本可以看成java中的线程和线程池的概念。用于处理ios多线程开发的问题。</p>

<p>网上部分资料提到一点是，虽然是queue，但是却并不是带有队列的概念，放入的操作并非是按照严格的先进现出。</p>

<p>这边又有个疑点是，对于队列来说，先进先出的概念是Afunc添加进队列，Bfunc紧跟着也进入队列，Afunc先执行这个是必然的，</p>

<p>但是Bfunc是等Afunc完全操作完以后，B才开始启动并且执行，因此队列的概念离乱上有点违背了多线程处理这个概念。</p>

<p>但是转念一想其实可以参考银行的取票和叫号系统。</p>

<p>因此对于A比B先排队取票但是B率先执行完操作，我们亦然可以感性认为这还是一个队列。</p>

<p>但是后来看到一票关于这操作队列话题的文章，其中有一句提到</p>

<p>“因为两个操作提交的时间间隔很近，线程池中的线程，谁先启动是不定的。”</p>

<p>瞬间觉得这个queue名字有点忽悠人了，还不如pool~</p>

<p>综合一点，我们知道他可以比较大的用处在于可以帮组多线程编程就好了。</p>

<h5>51.What is lazy loading?</h5>

<p>答案：懒汉模式，只在用到的时候才去初始化。</p>

<p>也可以理解成延时加载。</p>

<p>我觉得最好也最简单的一个列子就是tableView中图片的加载显示了。</p>

<p>一个延时载，避免内存过高，一个异步加载，避免线程堵塞。</p>

<h5>52.Can we use two tableview controllers on one viewcontroller?</h5>

<p>是否在一个视图控制器中嵌入两个tableview控制器？</p>

<p>答案：一个视图控制只提供了一个View视图，理论上一个tableViewController也不能放吧，</p>

<p>只能说可以嵌入一个tableview视图。当然，题目本身也有歧义，如果不是我们定性思维认为的UIViewController，</p>

<p>而是宏观的表示视图控制者，那我们倒是可以把其看成一个视图控制者，它可以控制多个视图控制器，比如TabbarController</p>

<p>那样的感觉。</p>

<h5>53.Can we use one tableview with two different datasources? How you will achieve this?</h5>

<p>一个tableView是否可以关联两个不同的数据源？你会怎么处理？</p>

<p>答案：首先我们从代码来看，数据源如何关联上的，其实是在数据源关联的代理方法里实现的。</p>

<p>因此我们并不关心如何去关联他，他怎么关联上，方法只是让我返回根据自己的需要去设置如相关的数据源。</p>

<p>因此，我觉得可以设置多个数据源啊，但是有个问题是，你这是想干嘛呢？想让列表如何显示，不同的数据源分区块显示？</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[敏捷开发流程总结]]></title>
        <link href="http://swplzj.github.io/blog/2014/09/16/min-jie-kai-fa-liu-cheng-zong-jie/"/>
        <updated>2014-09-16T23:42:04+08:00</updated>
        <id>http://swplzj.github.io/blog/2014/09/16/min-jie-kai-fa-liu-cheng-zong-jie</id>
        <content type="html"><![CDATA[<h4>Agile——敏捷开发</h4>

<p>作为CMM神话崩溃后被引入的一套新的软件开发模式，这几年来被广泛引起关注，并被寄予厚望。敏捷开发在其他业界的应用是否理想不得而知，但以下总结了我所在公司的敏捷开发试验，希望可以达到管中窥豹的目的。</p>

<!--more-->


<h5>敏捷开发宣言——</h5>

<p>个体和交互 胜过 过程和工具
可以工作的软件 胜过 面面俱到的文档
客户合作 胜过 合同谈判
响应变化 胜过 遵循计划
虽然右项也有价值，但是我们认为左项具有更大的价值。</p>

<p>以上的宣言比较抽象，基于该理念，以下是ThoughtsWork咨询公司的推崇的n个敏捷开发实践：</p>

<h5>Iteration</h5>

<p>迭代开发。可以工作的软件胜过面面俱到的文档。因此，敏捷开发提倡将一个完整的软件版本划分为多个迭代，每个迭代实现不同的特性。重大的、优先级高的特性优先实现，风险高的特性优先实现。在项目的早期就将软件的原型开发出来，并基于这个原型在后续的迭代不断晚上。迭代开发的好处是：尽早编码，尽早暴露项目的技术风险。尽早使客户见到可运行的软件，并提出优化意见。可以分阶段提早向不同的客户交付可用的版本。</p>

<h5>IterationPlanningMeeting</h5>

<p>迭代计划会议。每个迭代启动时，召集整个开发团队，召开迭代计划会议，所有的团队成员畅所欲言，明确迭代的开发任务，解答疑惑。</p>

<h5>Story Card/Story Wall/Feature List</h5>

<p>在每个迭代中，架构师负责将所有的特性分解成多个Story Card。每个Story可以视为一个独立的特性。每个Story应该可以在最多1个星期内完成开发，交付提前测试（Pre-Test）。当一个迭代中的所有Story开发完毕以后，测试组再进行完整的测试。在整个测试过程中（pre-test，test），基于Daily build，测试组永远都是每天从配置库上取下最新编译的版本进行测试，开发人员也随时修改测试人员提交的问题单，并合入配置库。
敏捷开发的一个特点是开放式办公，充分沟通，包括测试人员也和开发人员一起办公。基于Story Card的开发方式，团队会在开放式办公区域放置一块白板，上面粘贴着所有的Story Card，按当前的开发状态贴在4个区域中，分别是：未开发，开发中，预测试中，测试中。Story Card的开发人员和测试人员根据开发进度在Story Wall上移动Story Card，更新Story Card的状态。这种方式可以对项目开发进度有一个非常直观的了解。
在开发人员开始开发一个Story时，ta需要找来对应的测试人员讲解Story功能，以便测试人员有一致的理解，同时开始自动化系统测试脚本的开发。</p>

<h5>Standup Meeting</h5>

<p>站立会议。每天早上，所有的团队成员围在Story Wall周围，开一个高效率的会议，通常不超过15分钟，汇报开发进展，提出问题，但不浪费所有人的时间立刻解决问题，而是会后个别沟通解决。</p>

<h5>Pair Programming</h5>

<p>结对编程是指两个开发人员结对编码。结对编程的好处是：经过两个人讨论后编写的代码比一个人独立完成会更加的完善，一些大的方向不至于出现偏差，一些细节也可以被充分考虑到。一个有经验的开发人员和一个新手结对编程，可以促进新手的成长，保证软件开发的质量。</p>

<h5>CI/Daily Build</h5>

<p>持续集成和每日构建能力是否足够强大是迭代开发是否成功的一个重要基础。基于每日构建。开发人员每天将编写/修改的代码及时的更新到配置库中，自动化编译程序每天至少一次自动从配置库上取下代码，执行自动化代码静态检查（如PCLint），单元测试，编译版本，安装，系统测试，动态检查（如Purify）。以上这些自动化任务执行完毕后，会输出报告，自动发送邮件给团队成员。如果其中存在着任何的问题，相关责任人应该及时的修改。
可以看到，整个开发组频繁的更新代码，出现一些问题不可避免。通过测试部又在不停地基于最新的代码进行测试。新增的问题是否能够被及时发现并消灭掉，取决于自动化单元测试和系统测试能力是否足够强大，特别是自动化系统测试能力。如果自动化测试只能验证最简单的操作，则新合入代码的隐患将很难被发现，并遗留到项目后期，形成大的风险。而实际上，提升自动化测试的覆盖率是最困难的。</p>

<h5>Retrospect</h5>

<p>总结和反思。每个迭代结束以后，项目组成员召开总结会议，总结好的实践和教训，并落实到后续的开发中。</p>

<h5>ShowCase</h5>

<p>演示。每个Story开发完成以后，开发人员叫上测试人员，演示软件功能，以便测试人员充分理解软件功能。</p>

<h5>Refactoring</h5>

<p>重构。因为迭代开发模式在项目早期就开发出可运行的软件原型，一开始开发出来的代码和架构不可能是最优的、面面俱到的，因此在后续的Story开发中，需要对代码和架构进行持续的重构。迭代开发对架构师要求很高。因为架构师要将一个完整的版本拆分成多个迭代，每个跌倒由拆分成很多Story，从架构的角度看，这些Story必须在是有很强的继承性，是可以不断叠加的，不至于后续开发的Story完全推翻了早期开发的代码和架构，同时也不可避免的需要对代码进行不断完善，不断重构。</p>

<h5>TDD</h5>

<p>测试驱动开发。正如上面讲的，迭代开发的特点是频繁合入代码，频繁发布版本。测试驱动开发是保证合入代码正常运行且不会在后期被破坏的重要手段。这里的测试主要指单元测试。</p>

<h5>敏捷方法反思：</h5>

<p>自己参与的敏捷开发项目总的来说不是很成功，这可能也是业界遇到的通病：
1、对于全新的软件，在项目早期测试人员就参与并实现自动化测试脚本，但实际上软件的界面等非常不稳定，导致测试人员返工的工作量很大。
2、对于全新的软件，资料人员过早参与，后期返工工作量大，原因同第一点。
3、自动化系统测试工作量大，测试人员投入大量的精力在使测试自动化起来，而没有足够的精力放在真正的测试软件的功能是否正常。即便是这样，自动化系统测试脚本也多流于形式，测不出深层次的问题。
4、代码动态检查工具执行不理想，流于形式。没有人对Purify有深刻的理解和应用经验，报告中查出来很多告警，但不知如何消除。
5、由于快速搭建原型，没有在架构上进行严谨的设计，导致后期一直堆砌代码。
6、异地开发模式下无法实现快速构建、快速交付，团队普遍感觉很疲惫。
7、敏捷开发不提倡加班，但实际上不管是CMM还是Agile哪一种开发模式跟是否加班都没有必然联系。</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[iOS 数据持久化(四)]]></title>
        <link href="http://swplzj.github.io/blog/2014/08/29/ios-shu-ju-chi-jiu-hua-si/"/>
        <updated>2014-08-29T23:11:36+08:00</updated>
        <id>http://swplzj.github.io/blog/2014/08/29/ios-shu-ju-chi-jiu-hua-si</id>
        <content type="html"><![CDATA[<p>iOS中有五种持久化数据的方式：属性列表、对象归档、NSUserDefaults、SQLite3和Core Data</p>

<!--more-->


<h4>SQLite3的数据类型</h4>

<p>数据库在应用中最常用的，方便说数据的存取。
所有存在Sqlite 3.0版本当中的数据都拥有以下之一的数据类型：
空（NULL）：该值为空
整型（INTEGEER）：有符号整数，按大小被存储成1,2,3,4,6或8字节。
实数（REAL）：浮点数，以8字节指数形式存储。
文本（TEXT）：字符串，以数据库编码方式存储（UTF-8, UTF-16BE 或者 UTF-16-LE）。
BLOB：BLOB数据不做任何转换，以输入形式存储。</p>

<p>在关系数据库中，CLOB和BLOB类型被用来存放大对象。BOLB表示二进制大对象，这种数据类型通过用来保存图片，图象，视频等。CLOB表示字符大对象，能够存放大量基于字符的数据。</p>

<h4>iOS中数据库SQLite3的使用</h4>

<p>具体使用方法如下:</p>

<p>1.添加开发包libsqlite3.0.dylib</p>

<p>首先是设置项目文件，在项目中添加iPhone版的sqlite3的数据库的开发包，在项目下的Frameworks点击右键，然后选择libsqlite3.0.dylib文件。</p>

<p><img src="http://img.blog.csdn.net/20131220172258390?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3dwbHpq/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="id1" /></p>

<p>libsqlite3.0.dylib文件地址:</p>

<pre><code>/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS2.2.sdk/usr/lib/libsqlite3.0.dylib
</code></pre>

<p>2.有码有真相：</p>

<p>加入FMDB这个第三方库文件，项目编程开始。</p>

<h4>AppDelegate.h文件</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//  
</span><span class='line'>//  AppDelegate.h  
</span><span class='line'>//  SQLite3Demo  
</span><span class='line'>//  
</span><span class='line'>//  Created by 李振杰 on 13-11-22.  
</span><span class='line'>//  Copyright (c) 2013年 swplzj. All rights reserved.  
</span><span class='line'>//  
</span><span class='line'>  
</span><span class='line'>#import &lt;UIKit/UIKit.h&gt;  
</span><span class='line'>  
</span><span class='line'>@interface AppDelegate : UIResponder &lt;UIApplicationDelegate&gt;  
</span><span class='line'>  
</span><span class='line'>@property (strong, nonatomic) UIWindow *window;  
</span><span class='line'>  
</span><span class='line'>/** 
</span><span class='line'> *  @brief  在状态栏处显示的提示框 
</span><span class='line'> * 
</span><span class='line'> *  @param string   显示的字符串 
</span><span class='line'> *  @param duration 显示的时长 
</span><span class='line'> */  
</span><span class='line'>+ (void)showStatusWithText:(NSString *)string duration:(NSTimeInterval)duration;  
</span><span class='line'>  
</span><span class='line'>@end  </span></code></pre></td></tr></table></div></figure>


<h4>AppDelegate.m文件</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//  
</span><span class='line'>//  AppDelegate.m  
</span><span class='line'>//  SQLite3Demo  
</span><span class='line'>//  
</span><span class='line'>//  Created by 李振杰 on 13-11-22.  
</span><span class='line'>//  Copyright (c) 2013年 swplzj. All rights reserved.  
</span><span class='line'>//  
</span><span class='line'>  
</span><span class='line'>#import "AppDelegate.h"  
</span><span class='line'>#import "RootViewController.h"  
</span><span class='line'>  
</span><span class='line'>@interface AppDelegate ()  
</span><span class='line'>  
</span><span class='line'>@property (strong, nonatomic) UIWindow *statusWindow;  
</span><span class='line'>@property (retain, nonatomic) UILabel *statusLabel;  
</span><span class='line'>  
</span><span class='line'>- (void)dismissStatusLabel;  
</span><span class='line'>  
</span><span class='line'>@end  
</span><span class='line'>  
</span><span class='line'>@implementation AppDelegate  
</span><span class='line'>  
</span><span class='line'>- (void)dealloc  
</span><span class='line'>{  
</span><span class='line'>    [self.statusWindow release];  
</span><span class='line'>    [self.statusLabel release];  
</span><span class='line'>      
</span><span class='line'>    [_window release];  
</span><span class='line'>    [super dealloc];  
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions  
</span><span class='line'>{  
</span><span class='line'>    self.window = [[[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]] autorelease];  
</span><span class='line'>   
</span><span class='line'>    self.statusWindow = [[UIWindow alloc] initWithFrame:CGRectZero];  
</span><span class='line'>    self.statusWindow.backgroundColor = [UIColor clearColor];  
</span><span class='line'>    self.statusWindow.windowLevel = UIWindowLevelStatusBar + 1;  
</span><span class='line'>  
</span><span class='line'>    self.statusLabel = [[UILabel alloc] initWithFrame:CGRectZero];  
</span><span class='line'>    self.statusLabel.backgroundColor = [UIColor clearColor];  
</span><span class='line'>    self.statusLabel.textColor = [UIColor whiteColor];  
</span><span class='line'>    self.statusLabel.font = [UIFont systemFontOfSize:13];  
</span><span class='line'>    [self.statusWindow addSubview:self.statusLabel];  
</span><span class='line'>    [self.statusWindow makeKeyAndVisible];  
</span><span class='line'>      
</span><span class='line'>    RootViewController *rootVC = [[RootViewController alloc] initWithNibName:@"RootViewController" bundle:nil];  
</span><span class='line'>    UINavigationController *rootNav = [[UINavigationController alloc] initWithRootViewController:rootVC];  
</span><span class='line'>    [rootVC release];  
</span><span class='line'>      
</span><span class='line'>    self.window.rootViewController = rootNav;  
</span><span class='line'>    [rootNav release];  
</span><span class='line'>      
</span><span class='line'>    // Override point for customization after application launch.  
</span><span class='line'>    self.window.backgroundColor = [UIColor whiteColor];  
</span><span class='line'>    [self.window makeKeyAndVisible];  
</span><span class='line'>    return YES;  
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>#pragma mark - Custom methods  
</span><span class='line'>  
</span><span class='line'>- (void)dismissStatusLabel  
</span><span class='line'>{  
</span><span class='line'>    CGRect rect = self.statusWindow.frame;  
</span><span class='line'>    rect.origin.y -= rect.size.height;  
</span><span class='line'>    [UIView animateWithDuration:0.8 animations:^{  
</span><span class='line'>        self.statusWindow.frame = rect;  
</span><span class='line'>    }];  
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>/** 
</span><span class='line'> *  @brief  在状态栏处显示的提示框 
</span><span class='line'> * 
</span><span class='line'> *  @param string   显示的字符串 
</span><span class='line'> *  @param duration 显示的时长 
</span><span class='line'> */  
</span><span class='line'>+ (void)showStatusWithText:(NSString *)string duration:(NSTimeInterval)duration  
</span><span class='line'>{  
</span><span class='line'>    AppDelegate *delegate = (AppDelegate *)[UIApplication sharedApplication].delegate;  
</span><span class='line'>      
</span><span class='line'>    delegate.statusLabel.text = string;  
</span><span class='line'>    [delegate.statusLabel sizeToFit];  
</span><span class='line'>    CGRect rect = [UIApplication sharedApplication].statusBarFrame;  
</span><span class='line'>    CGFloat width = delegate.statusLabel.frame.size.width;  
</span><span class='line'>    CGFloat height = rect.size.height;  
</span><span class='line'>    rect.origin.x = rect.size.width = width - 5;  
</span><span class='line'>    rect.size.width = width;  
</span><span class='line'>    delegate.statusWindow.frame = rect;  
</span><span class='line'>    delegate.statusLabel.backgroundColor = [UIColor blackColor];  
</span><span class='line'>    delegate.statusLabel.frame = CGRectMake(100, 0, width, height);  
</span><span class='line'>    duration = (duration &lt; 1.0 ? 1.0 : duration);  
</span><span class='line'>    duration = (duration &gt; 4.0 ? 4.0 : duration);  
</span><span class='line'>    [delegate performSelector:@selector(dismissStatusLabel)];  
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>@end  </span></code></pre></td></tr></table></div></figure>


<h4>使用FMDB第三方库，数据库管理文件</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//  
</span><span class='line'>//  DBManager.h  
</span><span class='line'>//  SQLite3Demo  
</span><span class='line'>//  
</span><span class='line'>//  Created by 李振杰 on 13-11-26.  
</span><span class='line'>//  Copyright (c) 2013年 swplzj. All rights reserved.  
</span><span class='line'>//  
</span><span class='line'>  
</span><span class='line'>#import &lt;Foundation/Foundation.h&gt;  
</span><span class='line'>  
</span><span class='line'>#import "FMDatabaseAdditions.h"  
</span><span class='line'>  
</span><span class='line'>@class FMDatabase;  
</span><span class='line'>  
</span><span class='line'>/** 
</span><span class='line'> *  @brief 对数据连接进行管理，包括连接，关闭连接 
</span><span class='line'> *  可以建立长连接 
</span><span class='line'> * 
</span><span class='line'> */  
</span><span class='line'>@interface DBManager : NSObject{  
</span><span class='line'>    NSString *_dbPath;  
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>@property (readonly, nonatomic) FMDatabase *dataBase;  
</span><span class='line'>  
</span><span class='line'>//单例模式  
</span><span class='line'>+ (DBManager *)defaultDBManager;  
</span><span class='line'>  
</span><span class='line'>//关闭数据库  
</span><span class='line'>- (void)close;  
</span><span class='line'>  
</span><span class='line'>@end  </span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//  
</span><span class='line'>//  DBManager.m  
</span><span class='line'>//  SQLite3Demo  
</span><span class='line'>//  
</span><span class='line'>//  Created by 李振杰 on 13-11-26.  
</span><span class='line'>//  Copyright (c) 2013年 swplzj. All rights reserved.  
</span><span class='line'>//  
</span><span class='line'>  
</span><span class='line'>#import "DBManager.h"  
</span><span class='line'>#import "FMDatabase.h"  
</span><span class='line'>  
</span><span class='line'>//#define kDefaultDBName @"user.sqlite"  
</span><span class='line'>#define kDefaultDBName @"user.db"  
</span><span class='line'>  
</span><span class='line'>@interface DBManager ()  
</span><span class='line'>  
</span><span class='line'>@end  
</span><span class='line'>  
</span><span class='line'>static DBManager *_sharedDBManager;  
</span><span class='line'>  
</span><span class='line'>@implementation DBManager  
</span><span class='line'>  
</span><span class='line'>- (void)dealloc  
</span><span class='line'>{  
</span><span class='line'>    [self close];  
</span><span class='line'>      
</span><span class='line'>    [super dealloc];  
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>- (id)init  
</span><span class='line'>{  
</span><span class='line'>    if (self = [super init]) {  
</span><span class='line'>        int state = [self initializeDBWithName:kDefaultDBName];  
</span><span class='line'>        if (-1 == state) {  
</span><span class='line'>            NSLog(@"数据库初始化失败！");  
</span><span class='line'>        }else {  
</span><span class='line'>            NSLog(@"数据库初始化成功！");  
</span><span class='line'>        }  
</span><span class='line'>    }  
</span><span class='line'>    return self;  
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>- (int)initializeDBWithName:(NSString *)name  
</span><span class='line'>{  
</span><span class='line'>    if (!name) {  
</span><span class='line'>        return -1;  //数据库创建失败  
</span><span class='line'>    }  
</span><span class='line'>      
</span><span class='line'>    //沙盒Doc目录  
</span><span class='line'>    NSString *doc = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0];  
</span><span class='line'>    _dbPath = [doc stringByAppendingString:[NSString stringWithFormat:@"/%@", name]];  
</span><span class='line'>    NSFileManager *fileManager = [NSFileManager defaultManager];  
</span><span class='line'>    BOOL exist = [fileManager fileExistsAtPath:_dbPath];  
</span><span class='line'>    [self connect];  
</span><span class='line'>    return (exist == YES ? 0 : 1);  
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>//连接数据库  
</span><span class='line'>- (void)connect  
</span><span class='line'>{  
</span><span class='line'>    if (!_dataBase) {  
</span><span class='line'>        _dataBase = [[FMDatabase alloc] initWithPath:_dbPath];  
</span><span class='line'>    }  
</span><span class='line'>    if (![_dataBase open]) {  
</span><span class='line'>        NSLog(@"不能打开数据库");  
</span><span class='line'>    }  
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>- (void)close  
</span><span class='line'>{  
</span><span class='line'>    [_dataBase close];  
</span><span class='line'>    [_sharedDBManager release];  
</span><span class='line'>    _sharedDBManager = nil;  
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>+ (DBManager *)defaultDBManager  
</span><span class='line'>{  
</span><span class='line'>    if (!_sharedDBManager) {  
</span><span class='line'>        _sharedDBManager = [[DBManager alloc] init];  
</span><span class='line'>    }  
</span><span class='line'>    return _sharedDBManager;  
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>  
</span><span class='line'>@end  </span></code></pre></td></tr></table></div></figure>


<h4>向创建的数据库文件中添加数据表，对表的增删改查</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//  
</span><span class='line'>//  UserDB.h  
</span><span class='line'>//  SQLite3Demo  
</span><span class='line'>//  
</span><span class='line'>//  Created by 李振杰 on 13-11-26.  
</span><span class='line'>//  Copyright (c) 2013年 swplzj. All rights reserved.  
</span><span class='line'>//  
</span><span class='line'>  
</span><span class='line'>#import &lt;Foundation/Foundation.h&gt;  
</span><span class='line'>#import "DBManager.h"  
</span><span class='line'>#import "User.h"  
</span><span class='line'>  
</span><span class='line'>@interface UserDB : NSObject{  
</span><span class='line'>    FMDatabase *_db;  
</span><span class='line'>}  
</span><span class='line'>//创建数据表  
</span><span class='line'>- (void)createTable;  
</span><span class='line'>//增：添加用户  
</span><span class='line'>- (void)updateTableWithUser:(User *)user;  
</span><span class='line'>//删：删除用户  
</span><span class='line'>- (void)deleteTableWithUserID:(NSString *)uid;  
</span><span class='line'>//改：修改用户信息  
</span><span class='line'>- (void)modifyTableWithUser:(User *)user;  
</span><span class='line'>//查：查找用户  
</span><span class='line'>- (NSArray *)queryTableWithUid:(NSString *)uid count:(int)userCount;  
</span><span class='line'>  
</span><span class='line'>@end  </span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//  
</span><span class='line'>//  UserDB.m  
</span><span class='line'>//  SQLite3Demo  
</span><span class='line'>//  
</span><span class='line'>//  Created by 李振杰 on 13-11-26.  
</span><span class='line'>//  Copyright (c) 2013年 swplzj. All rights reserved.  
</span><span class='line'>//  
</span><span class='line'>  
</span><span class='line'>#import "UserDB.h"  
</span><span class='line'>#import "AppDelegate.h"  
</span><span class='line'>  
</span><span class='line'>#define kUserTableName                             @"User"  
</span><span class='line'>  
</span><span class='line'>@implementation UserDB  
</span><span class='line'>  
</span><span class='line'>- (id)init  
</span><span class='line'>{  
</span><span class='line'>    self = [super init];  
</span><span class='line'>    if (self) {  
</span><span class='line'>        //首先查看有没有数据库文件，没有就创建  
</span><span class='line'>        _db = [DBManager defaultDBManager].dataBase;  
</span><span class='line'>    }  
</span><span class='line'>    return self;  
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>//创建数据表  
</span><span class='line'>- (void)createTable  
</span><span class='line'>{  
</span><span class='line'>    FMResultSet *set = [_db executeQuery:[NSString stringWithFormat:@"select count(*) from sqlite_master where type = 'table' and name = '%@'", kUserTableName]];  
</span><span class='line'>    [set next];  
</span><span class='line'>      
</span><span class='line'>    NSInteger count = [set intForColumnIndex:0];  
</span><span class='line'>    BOOL existTable = !!count;  
</span><span class='line'>    if (existTable) {  
</span><span class='line'>        //更新数据库  
</span><span class='line'>        [AppDelegate showStatusWithText:@"数据库已经存在！" duration:2];  
</span><span class='line'>    } else {  
</span><span class='line'>        //插入到数据库  
</span><span class='line'>        NSString *sqlStr = @"CREATE TABLE User (uid INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, name VARCHAR(50), description VARCHAR(100))";  
</span><span class='line'>        BOOL res = [_db executeUpdate:sqlStr];  
</span><span class='line'>        if (!res) {  
</span><span class='line'>            [AppDelegate showStatusWithText:@"数据库创建失败！" duration:2];  
</span><span class='line'>        } else {  
</span><span class='line'>            [AppDelegate showStatusWithText:@"数据库创建成功！" duration:2];  
</span><span class='line'>        }  
</span><span class='line'>          
</span><span class='line'>    }  
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>//保存数据  
</span><span class='line'>- (void)updateTableWithUser:(User *)user  
</span><span class='line'>{  
</span><span class='line'>    NSMutableString *query = [NSMutableString stringWithFormat:@"INSERT INTO User"];  
</span><span class='line'>    NSMutableString *keys = [NSMutableString stringWithFormat:@" ("];  
</span><span class='line'>    NSMutableString *values = [NSMutableString stringWithFormat:@" ( "];  
</span><span class='line'>    NSMutableArray *arguments = [NSMutableArray arrayWithCapacity:5];  
</span><span class='line'>    if (user.name) {  
</span><span class='line'>        [keys appendString:@"name,"];  
</span><span class='line'>        [values appendString:@"?,"];  
</span><span class='line'>        [arguments addObject:user.name];  
</span><span class='line'>    }  
</span><span class='line'>    if (user.description) {  
</span><span class='line'>        [keys appendString:@"description,"];  
</span><span class='line'>        [values appendString:@"?,"];  
</span><span class='line'>        [arguments addObject:user.description];  
</span><span class='line'>    }  
</span><span class='line'>      
</span><span class='line'>    [keys appendString:@")"];  
</span><span class='line'>    [values appendString:@")"];  
</span><span class='line'>    [query appendFormat:@" %@ VALUES%@", [keys stringByReplacingOccurrencesOfString:@",)" withString:@")"], [values stringByReplacingOccurrencesOfString:@",)" withString:@")"]];  
</span><span class='line'>    NSLog(@"插入一条语句：%@", query);  
</span><span class='line'>    [AppDelegate showStatusWithText:@"插入一条数据!" duration:2];  
</span><span class='line'>    [_db executeUpdate:query withArgumentsInArray:arguments];  
</span><span class='line'>      
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>//删除用户信息  
</span><span class='line'>- (void)deleteTableWithUserID:(NSString *)uid  
</span><span class='line'>{  
</span><span class='line'>    NSString *query = [NSString stringWithFormat:@"DELETE FROM User WHERE uid = '%@'", uid];  
</span><span class='line'>    [AppDelegate showStatusWithText:@"删除一条数据!" duration:2];  
</span><span class='line'>    [_db executeUpdate:query];  
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>//修改用户信息  
</span><span class='line'>- (void)modifyTableWithUser:(User *)user  
</span><span class='line'>{  
</span><span class='line'>    if (!user.uid) {  
</span><span class='line'>        return;  
</span><span class='line'>    }  
</span><span class='line'>    NSString *query = @"UPDATE User SET";  
</span><span class='line'>    NSMutableString *temp = [NSMutableString stringWithCapacity:0];  
</span><span class='line'>    if (user.name) {  
</span><span class='line'>        [temp appendFormat:@"name = '%@',", user.name];  
</span><span class='line'>    }  
</span><span class='line'>    if (user.description) {  
</span><span class='line'>        [temp appendFormat:@"description = '%@',", user.description];  
</span><span class='line'>        [temp appendFormat:@")"];  
</span><span class='line'>        query = [query stringByAppendingFormat:@"%@ WHERE uid = '%@'", [temp stringByReplacingOccurrencesOfString:@",)" withString:@""], user.uid];  
</span><span class='line'>        NSLog(@"修改一条数据：%@", query);  
</span><span class='line'>        [AppDelegate showStatusWithText:@"修改了一条数据!" duration:2];  
</span><span class='line'>        [_db executeUpdate:query];  
</span><span class='line'>    }  
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>//查找用户  
</span><span class='line'>- (NSArray *)queryTableWithUid:(NSString *)uid count:(int)userCount  
</span><span class='line'>{  
</span><span class='line'>    NSString *query = @"SELECT uid, name, description FROM User";  
</span><span class='line'>    if (!uid) {  
</span><span class='line'>        query = [query stringByAppendingFormat:@" ORDER BY uid DESC limit %d", userCount];  
</span><span class='line'>    } else {  
</span><span class='line'>        query = [query stringByAppendingFormat:@" WHERE uid &gt; %@ ORDER BY uid DESC limit %d", uid, userCount];  
</span><span class='line'>    }  
</span><span class='line'>    NSLog(@"query = %@", query);  
</span><span class='line'>    FMResultSet *rs = [_db executeQuery:query];  
</span><span class='line'>    NSMutableArray *array = [NSMutableArray arrayWithCapacity:[rs columnCount]];  
</span><span class='line'>    while ([rs next]) {  
</span><span class='line'>        User *user = [[User alloc] init];  
</span><span class='line'>        user.uid = [rs stringForColumn:@"uid"];  
</span><span class='line'>        user.name = [rs stringForColumn:@"name"];  
</span><span class='line'>        user.description = [rs stringForColumn:@"description"];  
</span><span class='line'>        NSLog(@"user.uid = %@\nuser.name = %@\nuser.des = %@\n", user.uid, user.name, user.description);  
</span><span class='line'>        [array addObject:user];  
</span><span class='line'>        [user release];  
</span><span class='line'>    }  
</span><span class='line'>    [rs close];  
</span><span class='line'>    NSLog(@"array = %@\n", array);  
</span><span class='line'>    return array;  
</span><span class='line'>}  
</span><span class='line'>  
</span><span class='line'>  
</span><span class='line'>@end  </span></code></pre></td></tr></table></div></figure>


<h4>数据模型类</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//  
</span><span class='line'>//  User.h  
</span><span class='line'>//  SQLite3Demo  
</span><span class='line'>//  
</span><span class='line'>//  Created by 李振杰 on 13-11-26.  
</span><span class='line'>//  Copyright (c) 2013年 swplzj. All rights reserved.  
</span><span class='line'>//  
</span><span class='line'>  
</span><span class='line'>#import &lt;Foundation/Foundation.h&gt;  
</span><span class='line'>  
</span><span class='line'>@interface User : NSObject  
</span><span class='line'>  
</span><span class='line'>@property (copy, nonatomic) NSString *uid;  
</span><span class='line'>@property (copy, nonatomic) NSString *name;  
</span><span class='line'>@property (copy, nonatomic) NSString *description;  
</span><span class='line'>  
</span><span class='line'>@end  
</span><span class='line'>
</span><span class='line'>[objc] view plaincopy在CODE上查看代码片派生到我的代码片
</span><span class='line'>//  
</span><span class='line'>//  User.m  
</span><span class='line'>//  SQLite3Demo  
</span><span class='line'>//  
</span><span class='line'>//  Created by 李振杰 on 13-11-26.  
</span><span class='line'>//  Copyright (c) 2013年 swplzj. All rights reserved.  
</span><span class='line'>//  
</span><span class='line'>  
</span><span class='line'>#import "User.h"  
</span><span class='line'>  
</span><span class='line'>@implementation User  
</span><span class='line'>  
</span><span class='line'>@synthesize uid, name, description;  
</span><span class='line'>  
</span><span class='line'>@end  </span></code></pre></td></tr></table></div></figure>


<p>关于数据库的操作在上面代码中基本都包含，你也可以<a href="http://download.csdn.net/detail/swplzj/6746635">点击下载SQLite3Demo源码</a>。</p>
]]></content>
    </entry>
    
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    
    <title><![CDATA[Leo Lee]]></title>
    <link href="http://swplzj.github.io/atom.xml" rel="self"/>
    <link href="http://swplzj.github.io/"/>
    <updated>2015-08-19T19:25:57+08:00</updated>
    <id>http://swplzj.github.io/</id>
    <author>
        <name><![CDATA[Leo Lee]]></name>
        <email><![CDATA[swplzj@126.com]]></email>
    </author>
    <generator uri="http://octopress.org/">Octopress</generator>
    
    
    <entry>
        <title type="html"><![CDATA[iOS - VPN强烈推荐]]></title>
        <link href="http://swplzj.github.io/blog/2015/08/19/ios-vpnqiang-lie-tui-jian/"/>
        <updated>2015-08-19T18:58:02+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/08/19/ios-vpnqiang-lie-tui-jian</id>
        <content type="html"><![CDATA[<p>之前推荐过 Mac 上的 VPN 使用，今天推荐两款 iOS 端比价好用的 VPN 应用，真的用起来很方便。无需注册，轻松翻墙。</p>

<ol>
<li><code>ArkVPN</code>：优点：方便，速度快，免费，不限流量。缺点：不订阅的话需要每天领取时长，不过免费时长够用了。</li>
<li><code>Shadowsocks</code>：优点：方便，免费，开源，不限流量，不限时长。缺点：有些慢，有广告。</li>
</ol>


<!--more-->


<h3>ArkVPN</h3>

<ul>
<li><p>安装</p>

<p> <a href="https://itunes.apple.com/cn/app/arkvpn-wu-xian-liu-liang-mian/id909977824?mt=8">ArkVPN 下载地址</a></p></li>
<li><p>每天领取免费时长</p>

<p>  <img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_vpn_id1.PNG" title="\" ></p></li>
<li><p>只要一次点击，连接整个世界</p>

<p>  <img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_vpn_id2.PNG" title="\" ></p>

<p>  <img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_vpn_id3.PNG" title="\" ></p>

<p>  <img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_vpn_id4.PNG" title="\" ></p></li>
<li><p>国外服务器列表</p>

<p>  <img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_vpn_id5.PNG" title="\" ></p></li>
</ul>


<h3>Shadowsocks</h3>

<ul>
<li><p>简介
Shadowsocks 是一个开源项目，同时提供多个平台使用，你也可<a href="https://github.com/shadowsocks/shadowsocks">下载源码</a>进行研究。iOS客户端类似于一个封闭的浏览器，这这里可以翻墙浏览任何你想浏览的页面了。</p></li>
<li><p>安装</p></li>
</ul>


<p><a href="https://github.com/shadowsocks/shadowsocks-csharp">Windows</a> / <a href="https://github.com/shadowsocks/shadowsocks-iOS/wiki/Shadowsocks-for-OSX-Help">OS X</a></p>

<p><a href="https://github.com/shadowsocks/shadowsocks-android">Android</a> / <a href="https://github.com/shadowsocks/shadowsocks-iOS/wiki/Help">iOS</a></p>

<p><a href="https://github.com/shadowsocks/openwrt-shadowsocks">OpenWRT</a></p>

<ul>
<li><p>使用</p>

<p>  <img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_vpn_id6.PNG" title="\" ><br/>
  <img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_vpn_id7.PNG" title="\" ></p></li>
</ul>


<p>Have a fun！</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[正则表达式学习]]></title>
        <link href="http://swplzj.github.io/blog/2015/08/19/zheng-ze-biao-da-shi-xue-xi/"/>
        <updated>2015-08-19T11:45:54+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/08/19/zheng-ze-biao-da-shi-xue-xi</id>
        <content type="html"><![CDATA[<p>项目中经常使用到一些校验，比如有效手机号，身份证号码，邮箱，银行卡号码&hellip;假如说都是简单的使用位数来做校验，容易造成特殊字符输入乱码，还有可能在数据库中写入脏数据，所以使用正则表达式来进行校验匹配是很有必要的，当然，我们学习它就要知道它有哪些作用，正则表达式的用途基本有以下三种：</p>

<ul>
<li>校验数据</li>
<li>查询数据</li>
<li>替换数据</li>
</ul>


<p>学习正则表达式的最好方法是从例子开始，理解例子之后再自己对例子进行修改。下面开始学习之旅：</p>

<!--more-->


<h3>语法</h3>

<p><code>.</code> 是元字符，匹配除了换行符以外的任意字符。</p>

<p><code>*</code> 是元字符，不过它代表的不是字符，也不是位置，而是数量——它指定 <code>*</code> 前边的内容可以连续重复使用任意次以使整个表达式得到匹配。</p>

<p><code>.*</code> 连在一起就意味着任意数量的不包含换行的字符。</p>

<p><code>+</code> 重复一次或更多次</p>

<p><code>?</code> 重复零次或一次</p>

<p><code>{n}</code> 重复n次</p>

<p><code>{n,}</code>  重复n次或更多次</p>

<p><code>{n,m}</code> 重复n到m次</p>

<p><code>[]</code> 指定一个字符范围，比如，<strong>[aeiou]</strong>就匹配任何一个英文元音字母，<code>[0-9]</code>代表的含意与\d就是完全一致的。
<code>()</code> 小括号来指定子表达式(也叫做分组),比如：<strong>(\d{1,3}.){3}\d{1,3}</strong> 是一个简单的IP地址匹配表达式。</p>

<p><code>\b</code> 是正则表达式规定的一个特殊代码（也叫它元字符，metacharacter），代表着单词的开头或结尾，也就是单词的分界处。虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是<code>\b</code>并不匹配这些单词分隔字符中的任何一个，它只匹配一个位置。比如:在一段文本中查询<code>Leo</code>，就可以这样写：<strong>\bLeo\b</strong> 。</p>

<p><code>\B</code>    匹配不是单词开头或结束的位置</p>

<p><code>\d</code> 匹配一位数字，比如匹配大陆手机号码： <strong>1\d{10}</strong> ，{10} 意思是重复匹配10次。</p>

<p><code>\D</code>    匹配任意非数字的字符</p>

<p><code>\s</code> 匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等。</p>

<p><code>\S</code>    匹配任意不是空白符的字符</p>

<p><code>\w</code> 匹配字母或数字或下划线或汉字等。</p>

<p><code>\W</code>    匹配任意不是字母，数字，下划线，汉字的字符</p>

<p><code>[^x]</code>  匹配除了x以外的任意字符</p>

<p><code>[^aeiou]</code>  匹配除了aeiou这几个字母以外的任意字符</p>

<p><code>^</code> 匹配字符串的开始，或者是行的开始处</p>

<p><code>$</code> 匹配字符串的结束，或者是行的结束处</p>

<p><code>|</code> 分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配。</p>

<p><code>\</code> 为转义字符，比如匹配网址：使用 <code>swplzj\.github\.io</code> 来匹配 <code>swplzj.github.io</code> 。</p>

<h3>后向引用</h3>

<h4>捕获</h4>

<p>(exp):  匹配exp,并捕获文本到自动命名的组里</p>

<p>(?<name>exp):   匹配exp,并捕获文本到名称为name的组里，也可以写成(?&lsquo;name'exp)</p>

<p>(?:exp):    匹配exp,不捕获匹配的文本，也不给此分组分配组号</p>

<h4>零宽断言</h4>

<p>(?=exp):    匹配exp前面的位置</p>

<p>(?&lt;=exp):   匹配exp后面的位置</p>

<p>(?!exp):    匹配后面跟的不是exp的位置</p>

<h4>注释</h4>

<p>(?#comment):    这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读</p>

<h3>实例</h3>

<p>从下面文本中查询出以<code>[]</code>包含的内容，包括<code>[]</code></p>

<pre><code>The Tasmanian tiger, also known as the Thylacine, has been announced extinct many years ago. Now many geneticists assert that they are capable of recreating a [sid=13_1] from DNA extracted from its bone specimen. \n\nTasmanian tigers belong to marsupials that have a [sid=13_2] in common. They looked like big dogs with over 15 dark stripes on the body. When chasing their preys, these animals primarily depended on [sid=13_3] to prevail. Their stomach could inflate so they could eat large amount of food each time to [sid=13_4] a period lack of food.  
</code></pre>

<p>我们发现要查询的内容是以<code>[</code>开头，以 <code>]</code> 结束的，所以首先可以肯定的是  <code>\[\]</code>，注意需要转义字符<code>\</code>，然后<code>[]</code>之前包含的可能是 数字、空格、大小写字母、符号，但是不能包含<code>]</code>,所以我们可以写出 <code>\[[^\]]+\]</code></p>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_regular_express_id1.png" title="/" ></p>

<p>再增加点难度，要检索出<code>[]</code>里面的数据，我们可以先观察规律，因为正则表达式 - Regular Express 本身就是有规律的表达式，所以现发现规律，再写出所对应的正则。</p>

<p><strong>解答</strong></p>

<ul>
<li>以 <code>[</code> 开头，作为规律，可以写出 <code>(?&lt;=\[)([^\]])+</code></li>
</ul>


<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_regular_express_id2.png" title="/" ></p>

<ul>
<li>以<code>]</code> 结束，可以写出<code>[^\[]+(?=\])</code></li>
</ul>


<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_regular_express_id3.png" title="/" ></p>

<h3>iOS中应用</h3>

<p>我们在开发iOS项目过程中，使用到正则表达式的主要场景有两种：</p>

<p><strong>第一</strong> 在应用中用户输入数据时，做正则匹配校验，这类比较常见，这里就不做详述，但是给出一个比较好的建议，就是把需要校验的项，单独创建一个 XML 文件，然后再自定义标签，属性，来进行统一存放项目中所有校验项，如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;?xml version="1.0" encoding="utf-8"?&gt;
</span><span class='line'>&lt;rules&gt;
</span><span class='line'>    &lt;rule type="mobile" pattern="^1\d{10}$" tip="请输入正确的手机号" /&gt;
</span><span class='line'>&lt;/rules&gt;</span></code></pre></td></tr></table></div></figure>


<p>上面是简单校验手机号码位数的正则表达式，这样做的好处：方便维护管理；代码更为规范。</p>

<p><strong>第二</strong> 在使用 <code>UIWebView</code> 来加载文章类的页面时，使用正则表达式可以很好的提升用户体验。那使用正则我们可以做到那些呢？</p>

<ul>
<li><p>使用正则表达式来加载本地 <code>CSS</code> 样式表来自定义 <code>HTML</code> 中的样式；</p>

<ul>
<li>替换 <code>CSS</code> 样式表，这个可以实现 <code>HTML</code> 字体大小的动态调整；</li>
<li>可以实现类似白天、黑夜主题色的更换；</li>
<li>可以对文本进行标注、突出等处理；</li>
</ul>
</li>
<li><p>使用正则表达式获取 <code>HTML</code> 中的图片、视频，以便更友好的操作图片、视频资源；</p>

<ul>
<li>可以更改图片的大小展示；</li>
<li>通过正则匹配获取到图片的属性，比如id，然后进行本地操作，如，对图片添加点击事件，点击之后，进入本地图片浏览器，在图片浏览器中，就可以对图片进行放大、缩小、查看图片备注等操作了。</li>
</ul>
</li>
<li>使用正则表达式来为 <code>HTML</code> 添加元素；

<ul>
<li>可以为添加文章标题、发布时间等操作</li>
</ul>
</li>
</ul>


<p>使用场景已经描述完了，但是怎么样实现呢，下面直接上代码：</p>

<p><strong>加载本地 CSS </strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSRegularExpression *regularexpression = [[NSRegularExpression alloc]
</span><span class='line'>                                              initWithPattern:@"(?i)&lt;\\s*link\\s*href=\"[^\"]+\\.css\""
</span><span class='line'>                                              options:NSRegularExpressionCaseInsensitive
</span><span class='line'>                                              error:nil];
</span><span class='line'>    NSArray *matches = [regularexpression matchesInString:htmlContent options:0 range:NSMakeRange(0, [htmlContent length])];
</span><span class='line'>    NSString *content = htmlContent;
</span><span class='line'>    NSString *replaceStr = [NSString stringWithFormat:@"&lt;link href=\"%@\"",cssFilePath];
</span><span class='line'>    for (NSTextCheckingResult *match in matches){
</span><span class='line'>        NSRange matchRange = [match range];
</span><span class='line'>        content=[regularexpression stringByReplacingMatchesInString:content options:0 range:matchRange withTemplate:replaceStr];
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p><strong>获取图片资源</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> NSMutableArray *imageIds = [NSMutableArray array];
</span><span class='line'>    NSString *str = @"(?i)&lt;div\\s*class\\s*=\\s*\"[^\"]*img\"&gt;\\s*&lt;img\\s*[^&gt;]*id=\\s*\"[^&gt;]*&gt;";
</span><span class='line'> NSRegularExpression *regularexpression = [[NSRegularExpression alloc]
</span><span class='line'>                                              initWithPattern:str
</span><span class='line'>                                              options:NSRegularExpressionCaseInsensitive
</span><span class='line'>                                              error:nil];
</span><span class='line'> NSArray *matches = [regularexpression matchesInString:htmlContent
</span><span class='line'>                                                  options:0
</span><span class='line'>                                                    range:NSMakeRange(0, [htmlContent length])];
</span></code></pre></td></tr></table></div></figure>


<p><strong>对图片进行操作</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> NSString *str = @"(?i)&lt;div\\s*class=\"[^\"]*img\"&gt;\\s*&lt;img\\s*[^&gt;]*id=\\s*\"";
</span><span class='line'>
</span><span class='line'> str = [str stringByAppendingString:imageInfo.image_id];
</span><span class='line'> str = [str stringByAppendingString:@"\"\\s*src=\\s*\"[^\"]*\"[^&gt;]*&gt;"];
</span><span class='line'>
</span><span class='line'> NSString *replacejs = [NSString stringWithFormat:@"&lt;div class=\"img\" id=\"%@\" onclick=\"location.href='picid'+this.id\" style=\"background-color:#999999;width:%fpx;height:%fpx;\" /&gt;",imageInfo.image_id,width,height];
</span><span class='line'>
</span><span class='line'> replacejs = [replacejs stringByAppendingString:[NSString stringWithFormat:@"&lt;img src=\"%@\"  width=\"%fpx\" height=\"%fpx\"/&gt;",imagePath,width,0.0]];
</span><span class='line'> 
</span><span class='line'> replacejs = [replacejs stringByAppendingString:[NSString stringWithFormat:@"&lt;img src=\"%@\" width=\"180px\" height=\"36px\" style=\"margin-left:%fpx;margin-top:%fpx\"/&gt;",logoImagePath,(width / 2 - 90),(height/2 - 34)]];
</span><span class='line'>
</span><span class='line'> NSRegularExpression *regularexpression = [[NSRegularExpression alloc]
</span><span class='line'>                                          initWithPattern:str
</span><span class='line'>                                          options:NSRegularExpressionCaseInsensitive
</span><span class='line'>                                          error:nil];
</span><span class='line'> NSArray *matches = [regularexpression matchesInString:content options:0 range:NSMakeRange(0,  [content length])];
</span><span class='line'>
</span><span class='line'>
</span><span class='line'> for (NSTextCheckingResult *match in matches){
</span><span class='line'>    NSRange matchRange = [match range];
</span><span class='line'>    content=[regularexpression stringByReplacingMatchesInString:content options:0 range:matchRange withTemplate:replacejs];
</span><span class='line'> }
</span><span class='line'>            </span></code></pre></td></tr></table></div></figure>


<p><strong>放大缩小页面中的文本</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> NSString *jsString = [[NSString alloc] initWithFormat:@"document.getElementsByTagName('body')[0].style.webkitTextSizeAdjust= '%@'",textFontScale];
</span><span class='line'>    
</span><span class='line'>[_webView stringByEvaluatingJavaScriptFromString:jsString];</span></code></pre></td></tr></table></div></figure>


<p><strong>扩展 - 在本地HTML中加入JS</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSString *js = @"&lt;script language=\"javascript\" type=\"text/javascript\"&gt;";
</span><span class='line'> //替换css文件
</span><span class='line'>js = [js stringByAppendingString:@"function replacejscssfile(oldfilename, newfilename, filetype){ var targetelement=(filetype==\"js\")? \"script\" : (filetype==\"css\")? \"link\" : \"none\"; var targetattr=(filetype==\"js\")? \"src\" : (filetype==\"css\")? \"href\" : \"none\"; var allsuspects=document.getElementsByTagName(targetelement); for (var i=allsuspects.length; i&gt;=0; i--){ if (allsuspects[i] && allsuspects[i].getAttribute(targetattr)!=null && allsuspects[i].getAttribute(targetattr).indexOf(oldfilename)!=-1){ var newelement=createjscssfile(newfilename, filetype); allsuspects[i].parentNode.replaceChild(newelement, allsuspects[i]);} } return \"sdasds\";}"];
</span><span class='line'>
</span><span class='line'>js = [js stringByAppendingString:@"&lt;/script&gt;&lt;/head&gt;"];
</span><span class='line'>
</span><span class='line'>   NSString *content = [htmlContent stringByReplacingOccurrencesOfString:@"&lt;/head&gt;" withString:js];</span></code></pre></td></tr></table></div></figure>


<h3>常用正则表达式</h3>

<p>网址（URL）：  [a-zA-z]+://[^\s]*</p>

<p>IP地址(IP Address)： ((2[0-4]\d|25[0-5]|[01]?\d\d?).){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)</p>

<p>电子邮件(Email)：  \w+([-+.]\w+)<em>@\w+([-.]\w+)</em>.\w+([-.]\w+)*</p>

<p>QQ号码： [1-9]\d{4,}</p>

<p>HTML标记(包含内容或自闭合)： &lt;(.<em>)(.</em>)>.<em>&lt;\/\1>|&lt;(.</em>) \/></p>

<p>密码(由数字/大写字母/小写字母/标点符号组成，四种都必有，8位以上)：    (?=^.{8,}$)(?=.<em>\d)(?=.</em>\W+)(?=.<em>[A-Z])(?=.</em>[a-z])(?!.<em>\n).</em>$</p>

<p>日期(年-月-日)：  (\d{4}|\d{2})-((1[0-2])|(0?[1-9]))-(([12][0-9])|(3[01])|(0?[1-9]))</p>

<p>日期(月/日/年)：  ((1[0-2])|(0?[1-9]))/(([12][0-9])|(3[01])|(0?[1-9]))/(\d{4}|\d{2})</p>

<p>时间(小时:分钟, 24小时制)：   ((1|0?)[0-9]|2[0-3]):([0-5][0-9])</p>

<p>汉字(字符)：   [\u4e00-\u9fa5]</p>

<p>中文及全角标点符号(字符)：  [\u3000-\u301e\ufe10-\ufe19\ufe30-\ufe44\ufe50-\ufe6b\uff01-\uffee]</p>

<p>中国大陆固定电话号码：   (\d{4}-|\d{3}-)?(\d{8}|\d{7})</p>

<p>中国大陆手机号码： 1\d{10}</p>

<p>中国大陆邮政编码： [1-9]\d{5}</p>

<p>中国大陆身份证号(15位或18位)：  \d{15}(\d\d[0-9xX])?</p>

<p>非负整数(正整数或零)：    \d+</p>

<p>正整数：    [0-9]<em>[1-9][0-9]</em></p>

<p>负整数：    -[0-9]<em>[1-9][0-9]</em></p>

<p>整数：   -?\d+</p>

<p>小数：   (-?\d+)(.\d+)?</p>

<p>不包含abc的单词：    \b((?!abc)\w)+\b</p>

<h3>后记</h3>

<p>整理这篇博文的过程中，当然涉及到的知识不仅仅是正则表达式，还有后面通过 webview 和 JavaScript 进行交互，这是另一方面的知识了，就不在这里介绍了。马上七夕情人节了，大家快乐。就写到这里啦，还没有准备礼物，赶紧准备，不然&hellip;</p>

<p>参考博文：<a href="http://deerchao.net/tutorials/regex/regex.htm">正则表达式30分钟入门教程</a></p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Bash - 趣味Shell]]></title>
        <link href="http://swplzj.github.io/blog/2015/08/14/bash-qu-wei-shell/"/>
        <updated>2015-08-14T11:27:23+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/08/14/bash-qu-wei-shell</id>
        <content type="html"><![CDATA[<p>今天抽闲玩了一下<code>Shell</code>，发现几个比较有意思的，记录一下。</p>

<ul>
<li>终端彩虹字：<code>lolcat</code></li>
<li>图形化文字：<code>figlet</code></li>
<li>幸运人生格言：<code>fortune</code></li>
<li><code>ASCII</code>牛说：<code>Cowsay</code></li>
<li>黑客帝国中瀑布流文字：<code>cmatrix</code></li>
<li>写在最后</li>
</ul>


<p>很有趣的 <code>Shell</code>， 值得一试；</p>

<!--more-->


<h3>lolcat</h3>

<p> <strong>安装</strong></p>

<p>由于 <code>Lolcat</code> 是一个 <code>ruby gem</code> 程序，所以在你的系统中必须安装有最新版本的 <code>ruby</code>。安装<code>ruby</code>过程不再详述；</p>

<p>使用下面命令进行安装<code>lolcat</code></p>

<pre><code>gem install lolcat
</code></pre>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_lolcat.png"></p>

<p><strong>使用</strong></p>

<p><code>lolcat</code>作用是在终端中为文本添加彩虹般的色彩。安装完成之后就可以使用了。</p>

<p>首先看一下<code>lolcat</code>的帮助文档</p>

<pre><code>lolcat --help
</code></pre>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_lolcat_help.png"></p>

<p>接着查看日历</p>

<pre><code>cal | lolcat
</code></pre>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_lolcat_cal.png"></p>

<p><strong>高级技巧</strong></p>

<p>我们还可以给文本赋予彩虹颜色的动画:</p>

<pre><code>echo Hello World | lolcat -a -d 500
</code></pre>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_lolcat_echo.gif"></p>

<p><strong>别名技巧:<code>alias</code></strong></p>

<p>我们发现，假如一个经常使用的打印命令，比如<code>ls</code>，想打印彩虹色彩，我们每次都需要在敲完<code>ls</code>之后再加上<code>lolcat</code>，也就是<code>ls | lolcat</code>，这样很不方便，这时我们就可以想到别名，<code>alias</code>。我们可以设定一些别名：</p>

<pre><code>alias ls="ls | lolcat"
</code></pre>

<p>但是，有一个问题来了，只要把终端这个标签关闭掉或者重启终端，我们设置的别名就失效了，也就是说别名只针对当前标签页有效。所以，接下来我们要设置<code>alias</code>永久有效，我们输入命令<code>cd ~</code>到用户主目录，找到<code>.bash_profile</code>文件，如果没有，我们创建一个</p>

<pre><code>touch .bash_profile
</code></pre>

<p>然后在<code>.bash_profile</code>中加入我们的别名</p>

<pre><code>alias ls="ls | lolcat"  
</code></pre>

<p>保存，关闭，重启<code>Terminal</code>，看一下效果：</p>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_lolcat_ls.png"></p>

<p><strong>BTW</strong></p>

<p>假如你的终端没有设置配色方案，可以选择自带的主题：<code>Silver Aerogel</code>，设置方法:找到<code>.bash_profile</code>文件，添加如下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># for color
</span><span class='line'>export CLICOLOR=1
</span><span class='line'># \h:\W \u\$
</span><span class='line'>export PS1='\[\033[01;33m\]\u@\h\[\033[01;31m\] \W\$\[\033[00m\] '</span></code></pre></td></tr></table></div></figure>


<p>保存，重启终端，就可以看到漂亮的配色方案了。</p>

<h3>figlet</h3>

<p><strong>安装</strong></p>

<p>我们使用 <code>Homebrew</code>来安装此插件，</p>

<pre><code>brew install figlet
</code></pre>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_figlet_install.png"></p>

<p><strong>使用</strong></p>

<ul>
<li>figlet</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lizhenjie@localhost ~$ figlet Leo Lee
</span><span class='line'> _                 _              
</span><span class='line'>| |    ___  ___   | |    ___  ___ 
</span><span class='line'>| |   / _ \/ _ \  | |   / _ \/ _ \
</span><span class='line'>| |__|  __/ (_) | | |__|  __/  __/
</span><span class='line'>|_____\___|\___/  |_____\___|\___|</span></code></pre></td></tr></table></div></figure>


<ul>
<li>figlist：列出所有字体名称</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lizhenjie@localhost ~$ figlist
</span><span class='line'>Default font: standard
</span><span class='line'>Font directory: /usr/local/Cellar/figlet/2.2.5/share/figlet/fonts
</span><span class='line'>Figlet fonts in this directory:
</span><span class='line'>3-d
</span><span class='line'>3x5
</span><span class='line'>5lineoblique
</span><span class='line'>acrobatic
</span><span class='line'>alligator
</span><span class='line'>alligator2
</span><span class='line'>alphabet
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<ul>
<li>showfigfonts：展示每个字体效果！</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lizhenjie@localhost ~$ showfigfonts
</span><span class='line'>3-d :
</span><span class='line'>  ****             **
</span><span class='line'> */// *           /**
</span><span class='line'>/    /*           /**
</span><span class='line'>   ***  *****  ******
</span><span class='line'>  /// */////  **///**
</span><span class='line'> *   /*      /**  /**
</span><span class='line'>/ ****       //******
</span><span class='line'> ////         ////// 
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>3x5 :
</span><span class='line'>            
</span><span class='line'>###     ### 
</span><span class='line'>  # # # #   
</span><span class='line'> ##  #  ### 
</span><span class='line'>  # # #   # 
</span><span class='line'>###     ### 
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<p>只能列两种字体了，太多了。</p>

<p>当然，可以结合上面的 <code>lolcat</code>使用更炫哦。</p>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_figlet_lolcat.png"></p>

<p><strong>Dashboard Figlet</strong></p>

<p>安装过程中，意外发现<code>Figlet</code>也有<code>Dashboard</code>中的插件，可以到<a href="http://www.apple.com/downloads/dashboard/email_messaging/figletwidget.html">苹果官网下载</a>，使用起来也是非常方便的。</p>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_lolcat_dashboard.png"></p>

<h3>fortune</h3>

<p><strong>安装</strong></p>

<pre><code>brew install fortune
</code></pre>

<p><strong>用法</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lizhenjie@localhost ~$ fortune
</span><span class='line'>"To take a significant step forward, you must make a series of finite 
</span><span class='line'>improvements."
</span><span class='line'>-- Donald J. Atwood, General Motors</span></code></pre></td></tr></table></div></figure>


<p>结合<code>lolcat</code>使用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lizhenjie@localhost ~$ fortune | lolcat</span></code></pre></td></tr></table></div></figure>


<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_fortune_lolcat.png"></p>

<h3>Cowsay</h3>

<p><strong>安装</strong></p>

<pre><code>brew install cowsay
</code></pre>

<p><strong>用法</strong></p>

<ul>
<li><code>cowsay</code>可以输出一个在终端用ASCII码组成的小牛，这个小牛会说出你想要它说的话。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lizhenjie@localhost ~$ cowsay God help them who help themselves!
</span><span class='line'> ____________________________________ 
</span><span class='line'>&lt; God help them who help themselves! &gt;
</span><span class='line'> ------------------------------------ 
</span><span class='line'>        \   ^__^
</span><span class='line'>         \  (oo)\_______
</span><span class='line'>            (__)\       )\/\
</span><span class='line'>                ||----w |
</span><span class='line'>                ||     ||
</span><span class='line'>lizhenjie@localhost ~$ 
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>罗列出所有可以画出的动物形状</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lizhenjie@localhost ~$ cowsay -l
</span><span class='line'>Cow files in /usr/local/Cellar/cowsay/3.03/share/cows:
</span><span class='line'>beavis.zen bong bud-frogs bunny cheese cower daemon default dragon
</span><span class='line'>dragon-and-cow elephant elephant-in-snake eyes flaming-sheep ghostbusters
</span><span class='line'>head-in hellokitty kiss kitty koala kosh luke-koala meow milk moofasa moose
</span><span class='line'>mutilated ren satanic sheep skeleton small sodomized stegosaurus stimpy
</span><span class='line'>supermilker surgery telebears three-eyes turkey turtle tux udder vader
</span><span class='line'>vader-koala www</span></code></pre></td></tr></table></div></figure>


<ul>
<li>使用其他动物形状</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lizhenjie@localhost ~$ cowsay -f dragon LEO
</span><span class='line'> _____ 
</span><span class='line'>&lt; LEO &gt;
</span><span class='line'> ----- 
</span><span class='line'>      \                    / \  //\
</span><span class='line'>       \    |\___/|      /   \//  \\
</span><span class='line'>            /0  0  \__  /    //  | \ \    
</span><span class='line'>           /     /  \/_/    //   |  \  \  
</span><span class='line'>           @_^_@'/   \/_   //    |   \   \ 
</span><span class='line'>           //_^_/     \/_ //     |    \    \
</span><span class='line'>        ( //) |        \///      |     \     \
</span><span class='line'>      ( / /) _|_ /   )  //       |      \     _\
</span><span class='line'>    ( // /) '/,_ _ _/  ( ; -.    |    _ _\.-~        .-~~~^-.
</span><span class='line'>  (( / / )) ,-{        _      `-.|.-~-.           .~         `.
</span><span class='line'> (( // / ))  '/\      /                 ~-. _ .-~      .-~^-.  \
</span><span class='line'> (( /// ))      `.   {            }                   /      \  \
</span><span class='line'>  (( / ))     .----~-.\        \-'                 .~         \  `. \^-.
</span><span class='line'>             ///.----..&gt;        \             _ -~             `.  ^-`  ^-_
</span><span class='line'>               ///-._ _ _ _ _ _ _}^ - - - - ~                     ~-- ,.-~
</span><span class='line'>                                                                  /.-~
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>结合<code>fortune</code>使用</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lizhenjie@localhost ~$ fortune | cowsay
</span><span class='line'> _________________________________________ 
</span><span class='line'>/ We are all worms. But I do believe I am \
</span><span class='line'>| a glowworm.                             |
</span><span class='line'>|                                         |
</span><span class='line'>\ -- Winston Churchill                    /
</span><span class='line'> ----------------------------------------- 
</span><span class='line'>        \   ^__^
</span><span class='line'>         \  (oo)\_______
</span><span class='line'>            (__)\       )\/\
</span><span class='line'>                ||----w |
</span><span class='line'>                ||     ||</span></code></pre></td></tr></table></div></figure>


<ul>
<li>结合<code>lolcat</code>使用：</li>
</ul>


<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_cowsay_lolcat.png"></p>

<ul>
<li>结合<code>lolcat + fortune + cowsay</code></li>
</ul>


<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_cowsay_lolcat_forturn.png"></p>

<p>是不是很神奇！！！</p>

<h3>cmatrix</h3>

<p><strong>安装</strong></p>

<p>黑客帝国‘Hacker’风格的桌面的生动画面</p>

<pre><code>brew install cmatrix
</code></pre>

<p><strong>用法</strong></p>

<pre><code>cmatrix 
</code></pre>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_14_cmatrix.png"></p>

<p>其他用法可以使用 <code>man</code>查看。</p>

<h3>写在最后</h3>

<p>上面的命令可能在实际中对自己没有多大用途，但是，在配置的过程中，学到了不少东西，还增加了对 <code>Shell</code>的了解和兴趣，我们对自己的定位不能只局限与写代码，而是让自己多去了解自己不了解的，时常去走出自己的舒适区，找一些有趣有挑战性的东西去做，总之，保证自己一直在进步，加油！</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Mac - Navicat Premium 11.0.16 破解记录]]></title>
        <link href="http://swplzj.github.io/blog/2015/08/06/mac-navicat-premium-11-dot-0-16-po-jie-ji-lu/"/>
        <updated>2015-08-06T16:13:08+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/08/06/mac-navicat-premium-11-dot-0-16-po-jie-ji-lu</id>
        <content type="html"><![CDATA[<p>今天在测试聚信立相关接口时候，需要改变用户在数据库中聚信立认证状态，需要后台人员频繁帮忙修改改数据库中的值，有些麻烦。同事之前给推荐的数据库管理软件又过了试用期，只能重新安装，自己动手，丰衣足食。这是我安装 <code>Navicat Premium</code> 并破解的记录，供大家参考。</p>

<!--more-->


<p>1、安装 <code>Navicat Premium</code></p>

<p>2、打开注册机(若注册机无法打开，右击-显示简介-选中以32位模式打开)</p>

<p>3、（默认选择）点击 <code>Generate</code> 获取激活码</p>

<p>4、点击 <code>Activata</code>，弹出选择程序的窗口，选择 <code>Navicat Premium</code>，操作系统支持10.10（本人系统是Yosimite 10.10.3）</p>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_06_my_os_version.png"></p>

<p>5、点击 <code>patched</code> 又弹出选择程序的窗口，选择 <code>Navicat Premium</code></p>

<p>6、恭喜注册成功</p>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_06_crack_success.png"></p>

<p><code>注意</code>　　
　　</p>

<p>如果还不能激活请在终端运行以下命令（非常重要）：
　　</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>rm -Rf ~/Library/Application\ Support/PremiumSoft\ CyberTech/Navicat*
</span><span class='line'>
</span><span class='line'>rm -Rf ~/Library/Caches/com.prect.NavicatPremium 
</span><span class='line'>
</span><span class='line'>rm -Rf ~/Library/Preferences/com.prect.NavicatPremium.plist
</span><span class='line'>
</span><span class='line'>sudo rm -Rf /Applications/Navicat\ Premium.app/
</span></code></pre></td></tr></table></div></figure>


<p>执行完成后重启（一定要重启）再安装 <code>Navicat Premium</code>，并再次执行破解过程！</p>

<p>附破解注册机及 <code>navicat Premimum11.0.16</code> <a href="http://pan.baidu.com/s/1eQmwQky">安装包下载地址</a></p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Objective-C 规范整理]]></title>
        <link href="http://swplzj.github.io/blog/2015/08/06/objective-c-gui-fan-zheng-li/"/>
        <updated>2015-08-06T09:54:19+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/08/06/objective-c-gui-fan-zheng-li</id>
        <content type="html"><![CDATA[<p>这份规范参考了一些主流公司的代码规范，也结合自己实战中的操作整理而成，也是我们 iOS 团队的代码约定，为了减少项目维护成本，大家可以参照。</p>

<h2>目录</h2>

<ul>
<li><a href="#%E5%85%B3%E4%BA%8EView%E7%9A%84%E5%B8%83%E5%B1%80">关于View的布局</a></li>
<li><a href="#%E7%82%B9%E8%AF%AD%E6%B3%95">点语法</a></li>
<li><a href="#%E9%97%B4%E8%B7%9D">间距</a></li>
<li><a href="#%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD">条件判断</a>

<ul>
<li><a href="#%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6">三目运算符</a></li>
</ul>
</li>
<li><a href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">错误处理</a></li>
<li><a href="#%E6%96%B9%E6%B3%95">方法</a></li>
<li><a href="#%E5%8F%98%E9%87%8F">变量</a></li>
<li><a href="#%E5%91%BD%E5%90%8D">命名</a></li>
<li><a href="#%E6%B3%A8%E9%87%8A">注释</a></li>
<li><a href="#init-%E5%92%8C-dealloc">Init 和 Dealloc</a></li>
<li><a href="#%E5%AD%97%E9%9D%A2%E9%87%8F">字面量</a></li>
<li><a href="#CGRect-%E5%87%BD%E6%95%B0">CGRect 函数</a></li>
<li><a href="#%E5%B8%B8%E9%87%8F">常量</a></li>
<li><a href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B">枚举类型</a></li>
<li><a href="#%E4%BD%8D%E6%8E%A9%E7%A0%81">位掩码</a></li>
<li><a href="#%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7">私有属性</a></li>
<li><a href="#%E5%9B%BE%E7%89%87%E5%91%BD%E5%90%8D">图片命名</a></li>
<li><a href="#%E5%B8%83%E5%B0%94">布尔</a></li>
<li><a href="#%E5%8D%95%E4%BE%8B">单例</a></li>
<li><a href="#%E5%AF%BC%E5%85%A5">导入</a></li>
<li><a href="#Xcode-%E5%B7%A5%E7%A8%8B">Xcode 工程</a></li>
</ul>


<!--more-->


<h2>关于View的布局</h2>

<p>应该 <strong>始终</strong> 使用纯代码自动布局来实现视图展示</p>

<h2>点语法</h2>

<p>应该 <strong>始终</strong> 使用点语法来访问或者修改属性，访问其他实例时首选括号。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>view.backgroundColor = [UIColor orangeColor];
</span><span class='line'>[UIApplication sharedApplication].delegate;</span></code></pre></td></tr></table></div></figure>


<p><strong>反对：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[view setBackgroundColor:[UIColor orangeColor]];
</span><span class='line'>UIApplication.sharedApplication.delegate;</span></code></pre></td></tr></table></div></figure>


<h2>间距</h2>

<ul>
<li>一个缩进使用 4 个空格，永远不要使用制表符（tab）缩进。请确保在 Xcode 中设置了此偏好。</li>
<li>使用 Xcode 中 re-indent 功能定期对代码格式进行整理。</li>
<li>方法的大括号和其他的大括号（<code>if</code>/<code>else</code>/<code>switch</code>/<code>while</code> 等等）始终和声明在同一行开始，在新的一行结束。</li>
</ul>


<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (user.isHappy) {
</span><span class='line'>// Do something
</span><span class='line'>}
</span><span class='line'>else {
</span><span class='line'>// Do something else
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>方法之间应该正好空一行，这有助于视觉清晰度和代码组织性。在方法中的功能块之间应该使用空白分开，但往往可能应该创建一个新的方法。</li>
<li><code>@synthesize</code> 和 <code>@dynamic</code> 在实现中每个都应该占一个新行。</li>
</ul>


<h2>条件判断</h2>

<p>条件判断主体部分应该始终使用大括号括住来防止出错，即使它可以不用大括号（例如它只需要一行）。这些错误包括添加第二行（代码）并希望它是 if 语句的一部分时。还有另外一种更危险的，当 if 语句里面的一行被注释掉，下一行就会在不经意间成为了这个 if 语句的一部分。此外，这种风格也更符合所有其他的条件判断，因此也更容易检查。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (!error) {
</span><span class='line'>    return success;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><strong>反对：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (!error)
</span><span class='line'>    return success;</span></code></pre></td></tr></table></div></figure>


<p>或</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (!error) return success;</span></code></pre></td></tr></table></div></figure>


<h3>三目运算符</h3>

<p>三目运算符，? ，只有当它可以增加代码清晰度或整洁时才使用。单一的条件都应该优先考虑使用。多条件时通常使用 if 语句会更易懂，或者重构为实例变量。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>result = a &gt; b ? x : y;</span></code></pre></td></tr></table></div></figure>


<p><strong>反对：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>result = a &gt; b ? x = c &gt; d ? c : d : y;</span></code></pre></td></tr></table></div></figure>


<h2>错误处理</h2>

<p>当引用一个返回错误参数（error parameter）的方法时，应该针对返回值，而非错误变量。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSError *error;
</span><span class='line'>if (![self trySomethingWithError:&error]) {
</span><span class='line'>    // 处理错误
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><strong>反对：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSError *error;
</span><span class='line'>[self trySomethingWithError:&error];
</span><span class='line'>if (error) {
</span><span class='line'>    // 处理错误
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>一些苹果的 API 在成功的情况下会写一些垃圾值给错误参数（如果非空），所以针对错误变量可能会造成虚假结果（以及接下来的崩溃）。</p>

<h2>方法</h2>

<p>在方法签名中，在 -/+ 符号后应该有一个空格。方法片段之间也应该有一个空格。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)setExampleText:(NSString *)text image:(UIImage *)image;</span></code></pre></td></tr></table></div></figure>


<p><strong>对方法进行分组</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#pragma mark - View Life Cycle //视图生命周期
</span><span class='line'>#pragma mark - AutoLayout Methods//适配
</span><span class='line'>#pragma mark - Private Methods//私有方法
</span><span class='line'>#pragma mark - UITableView Delegate
</span><span class='line'>#pragma mark - UITableView Datasource
</span><span class='line'>#pragma mark - Event Response//事件处理
</span><span class='line'>#pragma mark - Getter And Setter//放到下面
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<h2>变量</h2>

<p>变量名应该尽可能命名为描述性的。除了 <code>for()</code> 循环外，其他情况都应该避免使用单字母的变量名。
星号表示指针属于变量，例如：<code>NSString *text</code> 不要写成 <code>NSString* text</code> 或者 <code>NSString * text</code> ，常量除外。
尽量定义属性来代替直接使用实例变量。除了初始化方法（<code>init</code>， <code>initWithCoder:</code>，等）， <code>dealloc</code> 方法和自定义的 setters 和 getters 内部，应避免直接访问实例变量。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface UCSection: NSObject
</span><span class='line'>
</span><span class='line'>@property (nonatomic) NSString *headline;
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p><strong>反对：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface UCSection : NSObject {
</span><span class='line'>    NSString *headline;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>变量限定符</h4>

<p>当涉及到在 ARC 中被引入变量限定符时，
限定符 (<code>__strong</code>, <code>__weak</code>, <code>__unsafe_unretained</code>, <code>__autoreleasing</code>) 应该位于星号和变量名之间，如：<code>NSString * __weak text</code>。</p>

<h2>命名</h2>

<p>尽可能遵守苹果的命名约定，尤其那些涉及到内存管理规则的。</p>

<p>长的和描述性的方法名和变量名都不错。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIButton *settingsButton;</span></code></pre></td></tr></table></div></figure>


<p><strong>反对：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIButton *setBut;</span></code></pre></td></tr></table></div></figure>


<p>类名和常量应该始终使用项目前缀（例如 UCredit <code>UC</code>），但 Core Data 实体名称可以省略。为了代码清晰，常量应该使用相关类的名字作为前缀并使用驼峰命名法。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static const NSTimeInterval UCHomeViewControllerNavigationFadeAnimationDuration = 0.3;</span></code></pre></td></tr></table></div></figure>


<p><strong>反对：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static const NSTimeInterval fadetime = 1.7;</span></code></pre></td></tr></table></div></figure>


<p>属性和局部变量应该使用驼峰命名法并且首字母小写。</p>

<p>为了保持一致，实例变量应该使用驼峰命名法命名，并且首字母小写，以下划线为前缀。这与 LLVM 自动合成的实例变量相一致。</p>

<p>项目相关的类：使用项目中自定义的前缀，使用UC作前缀</p>

<p><strong>推荐</strong></p>

<pre><code>UCHomeViewController
</code></pre>

<p><strong>后缀要求</strong></p>

<ul>
<li>ViewController：使用ViewController作后缀</li>
<li>View：使用View作后缀</li>
<li>UITableCell：使用Cell作后缀</li>
<li>Protocol：使用Delegate或DataSource作后缀</li>
</ul>


<p><strong>宏命名</strong></p>

<p>全大写，单词间用 _ 分隔</p>

<pre><code>eg：#define THIS_IS_AN_MACRO @"THIS_IS_AN_MACRO"   
</code></pre>

<h2>注释</h2>

<p>当需要的时候，注释应该被用来解释 <strong>为什么</strong> 特定代码做了某些事情。所使用的任何注释必须保持最新否则就删除掉。</p>

<p>通常应该避免一大块注释，代码就应该尽量作为自身的文档，只需要隔几行写几句说明。这并不适用于那些用来生成文档的注释。注释需要与代码同步更新。</p>

<h2>init 和 dealloc</h2>

<p><code>dealloc</code> 方法应该放在实现文件的最上面，并且刚好在 <code>@synthesize</code> 和 <code>@dynamic</code> 语句的后面。在任何类中，<code>init</code> 都应该直接放在 <code>dealloc</code> 方法的下面。</p>

<p><code>init</code> 方法的结构应该像这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (instancetype)init {
</span><span class='line'>    self = [super init]; // 或者调用指定的初始化方法
</span><span class='line'>    if (self) {
</span><span class='line'>        // Custom initialization
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    return self;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>字面量</h2>

<p>每当创建 <code>NSString</code>， <code>NSDictionary</code>， <code>NSArray</code>，和 <code>NSNumber</code> 类的不可变实例时，都应该使用字面量。要注意 <code>nil</code> 值不能传给 <code>NSArray</code> 和 <code>NSDictionary</code> 字面量，这样做会导致崩溃。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSArray *names = @[@"Brian", @"Matt", @"Chris", @"Alex", @"Steve", @"Paul"];
</span><span class='line'>NSDictionary *productManagers = @{@"iPhone" : @"Kate", @"iPad" : @"Kamal", @"Mobile Web" : @"Bill"};
</span><span class='line'>NSNumber *shouldUseLiterals = @YES;
</span><span class='line'>NSNumber *buildingZIPCode = @10018;</span></code></pre></td></tr></table></div></figure>


<p><strong>反对：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSArray *names = [NSArray arrayWithObjects:@"Brian", @"Matt", @"Chris", @"Alex", @"Steve", @"Paul", nil];
</span><span class='line'>NSDictionary *productManagers = [NSDictionary dictionaryWithObjectsAndKeys: @"Kate", @"iPhone", @"Kamal", @"iPad", @"Bill", @"Mobile Web", nil];
</span><span class='line'>NSNumber *shouldUseLiterals = [NSNumber numberWithBool:YES];
</span><span class='line'>NSNumber *buildingZIPCode = [NSNumber numberWithInteger:10018];</span></code></pre></td></tr></table></div></figure>


<h2>CGRect 函数</h2>

<p>当访问一个 <code>CGRect</code> 的 <code>x</code>， <code>y</code>， <code>width</code>， <code>height</code> 时，应该使用<code>CGGeometry</code> 函数代替直接访问结构体成员。苹果的 <code>CGGeometry</code> 参考中说到：</p>

<blockquote><p>All functions described in this reference that take CGRect data structures as inputs implicitly standardize those rectangles before calculating their results. For this reason, your applications should avoid directly reading and writing the data stored in the CGRect data structure. Instead, use the functions described here to manipulate rectangles and to retrieve their characteristics.</p></blockquote>

<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CGRect frame = self.view.frame;
</span><span class='line'>
</span><span class='line'>CGFloat x = CGRectGetMinX(frame);
</span><span class='line'>CGFloat y = CGRectGetMinY(frame);
</span><span class='line'>CGFloat width = CGRectGetWidth(frame);
</span><span class='line'>CGFloat height = CGRectGetHeight(frame);</span></code></pre></td></tr></table></div></figure>


<p><strong>反对：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CGRect frame = self.view.frame;
</span><span class='line'>
</span><span class='line'>CGFloat x = frame.origin.x;
</span><span class='line'>CGFloat y = frame.origin.y;
</span><span class='line'>CGFloat width = frame.size.width;
</span><span class='line'>CGFloat height = frame.size.height;</span></code></pre></td></tr></table></div></figure>


<h2>常量</h2>

<p>常量首选内联字符串字面量或数字，因为常量可以轻易重用并且可以快速改变而不需要查找和替换。常量应该声明为 <code>static</code> 常量而不是 <code>#define</code> ，除非非常明确地要当做宏来使用。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static NSString * const UCAboutViewControllerCompanyName = @"The UCredit Company";
</span></code></pre></td></tr></table></div></figure>


<p><strong>反对：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define CompanyName @"The UCredit Company"</span></code></pre></td></tr></table></div></figure>


<h2>枚举类型</h2>

<p>当使用 <code>enum</code> 时，建议使用新的基础类型规范，因为它具有更强的类型检查和代码补全功能。现在 SDK 包含了一个宏来鼓励使用使用新的基础类型 - <code>NS_ENUM()</code></p>

<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef NS_ENUM(NSInteger,UCAdRequestState) {
</span><span class='line'>      UCAdRequestStateInactive,
</span><span class='line'>    UCAdRequestStateLoading
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<h2>位掩码</h2>

<p>当用到位掩码时，使用 <code>NS_OPTIONS</code> 宏。</p>

<p><strong>举例：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef NS_OPTIONS(NSUInteger, UCAdCategory) {
</span><span class='line'>UCAdCategoryAutos      = 1 &lt;&lt; 0,
</span><span class='line'>UCAdCategoryJobs       = 1 &lt;&lt; 1,
</span><span class='line'>UCAdCategoryRealState  = 1 &lt;&lt; 2,
</span><span class='line'>UCAdCategoryTechnology = 1 &lt;&lt; 3
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<h2>私有属性</h2>

<p>私有属性应该声明在类实现文件的延展（匿名的类目）中。有名字的类目（例如 <code>UCPrivate</code> 或 <code>private</code>）永远都不应该使用，除非要扩展其他类。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface UCAdvertisement ()
</span><span class='line'>
</span><span class='line'>@property (nonatomic, strong) GADBannerView *googleAdView;
</span><span class='line'>@property (nonatomic, strong) ADBannerView *iAdView;
</span><span class='line'>@property (nonatomic, strong) UIWebView *adXWebView;
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<h2>图片命名</h2>

<p>为了便于图片资源的管理和维护，图片统一使用Image.xcassets，图片名称应该被统一命名以保持组织的完整。它们应该被命名为一个说明它们用途的带下划线字符串，其次是自定义类或属性的无前缀名字（如果有的话），然后进一步说明颜色 和/或 展示位置，最后是它们的状态。</p>

<p><strong>推荐：</strong></p>

<ul>
<li><code>smile_tab_default_selected@2x</code> / <code>smile_tab_default_selected@3x</code></li>
<li><code>sidebar_bg_mask_white@2x</code> / <code>sidebar_bg_mask_white@3x</code></li>
</ul>


<p>图片目录中被用于类似目的的图片应归入各自的组中。</p>

<h2>布尔</h2>

<p>因为 <code>nil</code> 解析为 <code>NO</code>，所以没有必要在条件中与它进行比较。永远不要直接和 <code>YES</code> 进行比较，因为 <code>YES</code> 被定义为 1，而 <code>BOOL</code> 可以多达 8 位。</p>

<p>这使得整个文件有更多的一致性和更大的视觉清晰度。</p>

<p><strong>推荐：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (!someObject) {
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><strong>反对：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (someObject == nil) {
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<hr />

<p><strong>对于 <code>BOOL</code> 来说, 这有两种用法:</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (isAwesome)
</span><span class='line'>if (![someObject boolValue])</span></code></pre></td></tr></table></div></figure>


<p><strong>反对：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if ([someObject boolValue] == NO)
</span><span class='line'>if (isAwesome == YES) // 永远别这么做</span></code></pre></td></tr></table></div></figure>


<hr />

<p>如果一个 <code>BOOL</code> 属性名称是一个形容词，属性可以省略 “is” 前缀，但为 get 访问器指定一个惯用的名字，例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@property (assign, getter=isEditable) BOOL editable;</span></code></pre></td></tr></table></div></figure>


<p>内容和例子来自 Cocoa 命名指南。</p>

<h2>单例</h2>

<p>单例对象应该使用线程安全的模式创建共享的实例。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (instancetype)sharedInstance {
</span><span class='line'>   static id sharedInstance = nil;
</span><span class='line'>
</span><span class='line'>   static dispatch_once_t onceToken;
</span><span class='line'>   dispatch_once(&onceToken, ^{
</span><span class='line'>      sharedInstance = [[self alloc] init];
</span><span class='line'>   });
</span><span class='line'>
</span><span class='line'>   return sharedInstance;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这将会预防有时可能产生的许多崩溃。</p>

<h2>导入</h2>

<p>如果有一个以上的 import 语句，就对这些语句进行分组。每个分组的注释是可选的。 <br/>
注：对于模块使用 @import 语法。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Frameworks
</span><span class='line'>@import QuartzCore;
</span><span class='line'>
</span><span class='line'>// Models
</span><span class='line'>#import "UCUser.h"
</span><span class='line'>
</span><span class='line'>// Views
</span><span class='line'>#import "UCButton.h"
</span><span class='line'>#import "UCUserView.h"</span></code></pre></td></tr></table></div></figure>


<p></p>

<h2>Xcode 工程</h2>

<p>为了避免文件杂乱，物理文件应该保持和 Xcode 项目文件同步。Xcode 创建的任何组（group）都必须在文件系统有相应的映射。为了更清晰，代码不仅应该按照类型进行分组，也可以根据功能进行分组。</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[iOS - '#'引发的思考]]></title>
        <link href="http://swplzj.github.io/blog/2015/08/04/ios-number-yin-fa-de-si-kao/"/>
        <updated>2015-08-04T18:37:45+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/08/04/ios-number-yin-fa-de-si-kao</id>
        <content type="html"><![CDATA[<p>在代码中使用 <code>Autolayout</code> 时，大家都会使用 <code>NSDictionaryOfVariableBindings</code> 这个宏，这个宏可以生成一个变量名到变量值映射的 <code>Dictionary</code>。比如 <code>NSDictionaryOfVariableBindings(button1, button2)</code> 将会生成一个<code>{ @"button1" = button1, @"button2 = button2 }</code> 的 <code>Dictionary</code>。它是怎么做到的呢？我们来看看这个宏的定义：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define NSDictionaryOfVariableBindings(...) _NSDictionaryOfVariableBindings(@"" # __VA_ARGS__, __VA_ARGS__, nil)</span></code></pre></td></tr></table></div></figure>


<p>这个宏定义中有3个参数，后两个参数不难理解，但第一个参数中间有个 <code>#</code> 符号，语法上看起来比较怪异，这个是什么呢？以前在做越狱的 <code>mobilesubstrate</code> 开发时，其中定义的一堆宏频繁使用了这个符号，下面就来揭开 <code>#</code> 这个符号在宏定义中的迷雾。</p>

<!--more-->


<h3>预编译的一些知识</h3>

<p>我们的代码在 <code>build</code> 时并不是直接进行编译的，在编译之前还进行了预编译处理。预编译会把 <code>include</code> 或 <code>import</code> 的文件导入到文件中，同时会将代码中用到的宏进行替换。注意宏是直接在代码中替换成宏的定义的，如果有嵌套也会逐层替换。</p>

<h3>“#”指示一些预编译命令</h3>

<p>预编译命令一般都是以 <code>#</code> 开头的，比如 <code>#include</code>、<code>#import</code>、<code>#if</code> 等，在这里就不一一说明了，本文主要说明一下 <code>#</code> 在宏定义里面的一些作用。</p>

<h3>宏参数字符串化</h3>

<p>在一个参数前加一个<code>#</code>，预处理时将会变成这个参数名的字符串常量，即字符串化（<code>stringify</code>）。比如:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define GET_NAME(X) #X
</span><span class='line'>int a = 0;
</span><span class='line'>NSLog(@"%s",GET_NAME(a));      //output: "a"
</span><span class='line'>NSLog(@"%s",GET_NAME(a+3));    //output: "a+3"</span></code></pre></td></tr></table></div></figure>


<p>将会得到以下输出：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a
</span><span class='line'>a+3</span></code></pre></td></tr></table></div></figure>


<p>可以看出<code>#</code>，将参数原样转换成字符串常量，如果参数是一个表达式，那么输出这个表达式的原样字符串常量。</p>

<p>回头再看看<code>NSDictionaryOfVariableBindings</code>的定义：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define NSDictionaryOfVariableBindings(...) _NSDictionaryOfVariableBindings(@"" # __VA_ARGS__, __VA_ARGS__, nil)</span></code></pre></td></tr></table></div></figure>


<p>如果这样生成两个<code>button</code>的映射：</p>

<pre><code>NSDictionaryOfVariableBindings(button1, button2);
</code></pre>

<p>那么预编译时就会转换成：</p>

<pre><code>_NSDictionaryOfVariableBindings(@"""button1, button2", button1, button2, nil);
</code></pre>

<p>由于两个常量字符串放在一起就是字符串常量串联，将变成两个字符串常量组合在一起的字符串常量，也就是上面是一个空字符串<code>""</code>和<code>"button1, button2"</code>串联，所以上面的代码等价于：</p>

<pre><code>_NSDictionaryOfVariableBindings(@"button1, button2", button1, button2, nil);
</code></pre>

<p>那么<code>_NSDictionaryOfVariableBindings</code>函数就可以将它的第一个参数按逗号,分割开作为<code>key</code>，后面就是各个<code>key</code>对应的值了。因此这段代码就创建了一个内容为<code>{ @"button1" = button1, @"button2 = button2 }</code>的<code>Dictionary</code>。</p>

<h3>命名的串联</h3>

<p><code>#</code>在宏定义中的另一个作用就是用于命名的串联，用<code>##</code>就可以串联它左右两边的命名，比如以下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define CONCAT(X, Y) X ## Y
</span><span class='line'>NSString *helloworld = @"Hello, world!";
</span><span class='line'>NSLog(@"%@",CONCAT(hello, world)); //output: "Hello, world"</span></code></pre></td></tr></table></div></figure>


<p><code>CONCAT(hello, world)</code>实际被转换成<code>helloworld</code>。注意一下，因为宏是预编译阶段进行展开的，就是说在编译之前，因此代码中的<code>hello</code>和<code>world</code>即使没有定义其实也是没问题的，预编译处理后，这两个命名是不存在的。</p>

<h3>可选可变参数</h3>

<p><code>##</code>在宏定义中可以放在<code>__VA_ARGS__</code>之前表示可变参数可以为空，否则的话可变参数至少为一个了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define MYLOG(format, ...) NSLog(format, ##__VA_ARGS__)
</span><span class='line'>MYLOG(@"Don't make an error!");</span></code></pre></td></tr></table></div></figure>


<p>上面代码中<code>MLOG</code>中只有一个参数，如果不加<code>##</code>，则<code>MLOG</code>至少需要两个参数，在<code>Xcode</code>里将会出现编译错误。</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Mac - 截屏功能高级篇]]></title>
        <link href="http://swplzj.github.io/blog/2015/08/04/mac-jie-ping-gong-neng-gao-ji-pian/"/>
        <updated>2015-08-04T16:29:59+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/08/04/mac-jie-ping-gong-neng-gao-ji-pian</id>
        <content type="html"><![CDATA[<p>截屏在平常应该是最常用的功能了，虽然说有一些工具可以提供截屏，比如 QQ 带的截屏功能，但是默认的快捷键可能与系统自定义冲突，或者使用鼠标不方便。其实，系统本身所提供的截屏功能，足够我们使用，你真的认为你掌握了截屏功能？那进来看看吧。</p>

<!--more-->


<h3>最常用的截屏：</h3>

<ol>
<li>command + shift + 3  &ndash; 截取全屏</li>
<li>command + shift + 4  &ndash; 自定义大小截屏</li>
<li>command + shift + 4 + space &ndash; 截取特定区域</li>
</ol>


<h3>高级功能 - 在 command + shift + 4 之后</h3>

<ol>
<li>长按空格 &ndash; 移动截屏区域；</li>
<li>长按 shift &ndash; 固定高度（宽度），调整截取区域宽度（高度）；</li>
<li>长按 option &ndash; 以中心点为中心宽度（高度）同时增加；</li>
<li>同时长按 shift + option 固定高度（宽度），以中心点为中心调整截取区域宽度（高度）；</li>
<li>command + shift + control &ndash; 把截图 copy 到剪贴板</li>
</ol>

]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[博客升级了]]></title>
        <link href="http://swplzj.github.io/blog/2015/07/31/bo-ke-sheng-ji-liao/"/>
        <updated>2015-07-31T19:17:56+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/07/31/bo-ke-sheng-ji-liao</id>
        <content type="html"><![CDATA[<p>博客其实早就搭建了，中间发布过一些文章，可是博客一直没有升级，现在针对以下几个功能进行了添加及优化。</p>

<ul>
<li>更换主题</li>
<li>添加站长统计</li>
<li>添加多说评论</li>
<li>添加七牛云图片存储服务</li>
<li>自动为图片添加url前缀</li>
<li>写在最后</li>
</ul>


<!--more-->


<h3>更换主题</h3>

<p>搭建完博客之后，接着就要更换为自己喜欢的主题了，选择的主题是 <a href="http://sofreshandsogreen.herokuapp.com">So Fresh and So Green</a>，喜欢这种带有活力的色调。具体设置步骤如下：</p>

<p><code>Step 1</code></p>

<p>使用命令安装主题；</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git clone https://github.com/johnkeith/sofreshandsogreen.git .themes/sofreshandsogreen
</span><span class='line'>  
</span><span class='line'>$ bundle exec rake install['sofreshandsogreen']</span></code></pre></td></tr></table></div></figure>


<p><code>Step 2</code></p>

<p>更改博客配置文件  <code>_config.yml</code>，需要移除默认主题的侧边栏，</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>default_asides: []
</span><span class='line'>sidebar: collapse</span></code></pre></td></tr></table></div></figure>


<p><code>Step 3</code></p>

<p>在首页显示显示圆形头像，首先到 <code>source/images</code>目录下面，使用你选择的头像替换掉 <code>portrait.jpg</code>, 然后再配置文件 <code>_config.yml</code> 中，添加下面一句代码：</p>

<pre><code>portrait: true
</code></pre>

<p>（BTW：我选择的头像使我们几个朋友一起亲手绘画的梵高的向日葵，色调与博客主题色调完美搭配，赞一个~~）</p>

<p>至此，博客主题安装完成。</p>

<h3>添加站长统计</h3>

<p>博客搭建完成之后，需要看自己博客被访问次数，访问页面，访问速度，页面停留时间&hellip;等等，都需要借助第三方的统计工具来完成的，类似于移动端 App 使用的友盟统计一样，这个还要简单只需要注册相应的账号，然后，在自己博客中添加官方提供的 JS 代码。我选择的是国内使用很广的 <a href="http://www.cnzz.com">CNZZ</a>，注册后，添加并验证你的网站就可以添加统计代码了，选好自己喜欢的样式，获得代码，可添加到 <code>source/_includes/custom/footer.html</code> 中。即可查看每天你的博客的流量，进行相应的优化了。</p>

<pre><code>&lt;script type="text/javascript"&gt;var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1255930196'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1255930196%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));&lt;/script&gt;
</code></pre>

<h3>添加多说评论</h3>

<p>Octopress默认自带了 <code>DISQUS</code> ，但是对于国内不是很好用，于是选择了多说作为评论插件，这个还是很接地气的。多说官网账号无需注册，我是使用的百度账号来进行设置，添加站点，获取站点 <code>short_name</code>。这个</p>

<p>在配置文件 <code>_config.yml</code> 中，添加以下代码：</p>

<pre><code>duoshuo_comments: true
duoshuo_short_name: yoursite (多说二级域名 yoursite.duoshuo.com)(yoursite是你在多说中添加的站点名称)
</code></pre>

<p>在 <code>source/_layouts/post.html</code> 中 <code>disqus</code> 代码下方添加<a href="https://github.com/swplzj/swplzj.github.io/blob/source/source/_layouts/post.html">多说代码本想粘贴出代码，但是一直显示不全只能留源文件地址了。</a></p>

<p>然后，在路径 <code>source/_includes/post</code>下创建一个 <code>duoshuo.html</code>, <a href="https://github.com/swplzj/swplzj.github.io/blob/source/source/_includes/post/duoshuo.html">直接上文件地址</a></p>

<p>到此为止，添加多说评论完成。</p>

<h3>添加七牛云存储作为图床</h3>

<p>博客其实已经可以正常发布博文，展示，数据统计，评论，归档等功能了，但是一直有个特殊情景，在困扰着我，假如我想发布一篇博文，博文中包含很多图片，大家都知道在 Markdown 语言中添加一张图片，是很简单的，直接使用语法，发一个图片地址就可以了。但是这个图片放到本地，然后随博客同步到 GitHub 上的话，就会造成两个主要问题，第一，在国内由于网络问题，加载图片特别缓慢；第二，GitHub 免费存储是固定的，用来当做图床，不是明智之举，鉴于此，就寻找国内比较稳定优秀的图床。最终选择了七牛云存储，优点：访问速度极快，支持日志、防盗链和水印。然后有了图床，就解决了图片存储的问题，流程就是，先把博文中所要使用的图片，先上传到七牛上，然后拿到获取此资源的链接，写到博文中，就可以了。</p>

<h3>自动为图片添加url前缀</h3>

<p>我把图片资源都放在了七牛云存储上，写博客时候就是用七牛的外链。但是这样有几个问题：
每次写博客插入图片外链地址时候都很麻烦，需要给每张图片都添加七牛外链地址url前缀；
如果以后更换了存储，那就麻烦了，需要依次编辑替换每个图片的url前缀
现在我们就使用一种灵活的方式来配置并自动生成图片的url前缀：</p>

<p>1.修改 <code>/plugins/image_tag.rb</code> 文件，在</p>

<pre><code>@img['class'].gsub!(/"/, '') if @img['class']
</code></pre>

<p>后添加下面一行代码：</p>

<pre><code>@img['src'] = Jekyll.configuration({})['static_file_prefix'] + @img['src'] if @img['src'][0] == '/'
</code></pre>

<p>2.再修改根目录下的 <code>_config.yml</code> 文件，添加如下配置：</p>

<pre><code>static_file_prefix: http://7u2i08.com1.z0.glb.clouddn.com
</code></pre>

<p>这样在生成文章的时候，以 <code>/</code> 开头的图片会自动加上 <code>http://7u2i08.com1.z0.glb.clouddn.com</code> 前缀。</p>

<p>3.我们在插入图片的时候要记住不能再使用 Markdown 语法来写了，要使用 Ocotpress 自定义的 <code>Image Tag</code> 来插入图片。</p>

<p>4.使用 <a href="http://developer.qiniu.com/docs/v6/tools/qrsync.html"><code>qrsync</code></a> 同步图片资源。<code>qrsync</code> 是一个根据七牛云存储API实现的简易命令行辅助上传同步工具，支持断点续上传，增量同步，它可将用户本地的某目录的文件同步到七牛云存储中，同步或上传几百GB甚至上TB的文件毫无鸭梨。
下载对应的命令行辅助同步工具，我使用的Mac，下载完成后，解压出命令执行文件，放到 <code>/usr/local/bin</code> 目录下。</p>

<p>5.创建一个配置文件（<a href="http://json.org/json-zh.html">JSON格式</a>）,可以命名为 <code>qrsync.json</code>,输入以下配置</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "debug_level" : 1,
</span><span class='line'>  "deletable" : 0,
</span><span class='line'>  "dest" : "qiniu:access_key=yourAccessKey&secret_key=yourSecretKey&bucket=yourSpaceName",
</span><span class='line'>  "src" : "/Users/yourname/octopress/source/images"
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>其中，<code>AccessKey</code> 和 <code>SecretKey</code> 就是之前咱们在七牛云存储平台上申请的。如图所示：</p>

<p><img class="center" src="http://7xkrxl.com1.z0.glb.clouddn.com/2015_08_03_qi_niu_key.png"></p>

<table>
<thead>
<tr>
<th>参数              </th>
<th> 备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>debug_level     </td>
<td>  日志输出等级（通常设置1，只输出必要的日志）</td>
</tr>
<tr>
<td>deletable       </td>
<td> 是否同步删除七牛云上的文件（通常设置0，当本地文件删除时并不删除存储在七牛的对应文件）</td>
</tr>
<tr>
<td>src             </td>
<td> 本地源目录路径（本地需要同步上传目录的完整的绝对路径）</td>
</tr>
<tr>
<td>bucket          </td>
<td> 目标空间名称</td>
</tr>
</tbody>
</table>


<p>这样就可以使用七牛的资源同步辅助命令了。
本地预览先 <code>rake generate</code> 后 <code>rake preview</code> ，这样插入图片就灵活方便多了。</p>

<p><code>注意1</code></p>

<p>在 <code>rake generate</code> 时，我这里遇到一个错误，报错如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Configuration file: /Users/lizhenjie/octopress/_config.yml
</span><span class='line'>  Liquid Exception: undefined method `+' for nil:NilClass in _posts/2015-07-30-test.markdown/#excerpt
</span><span class='line'>jekyll 2.5.3 | Error:  undefined method `+' for nil:NilClass</span></code></pre></td></tr></table></div></figure>


<p>经过搜索，发现如果要把两个字符串连接在一起。如</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a = “abc”
</span><span class='line'>b = a + “de”</span></code></pre></td></tr></table></div></figure>


<p>此时b的值为 <code>abcde</code>
但如果 <code>a = nil</code> 时，就会抛出未定义“+”的异常，因为此时a为nil。仔细检查发现修改完 <code>/plugins/image_tag.rb</code> 文件后，没有做保存，没有关闭文件，造成的问题，还好我没有放弃，O(∩_∩)O哈哈~</p>

<p><code>注意2</code></p>

<p>我们在插入图片的时候要记住不能再使用 Markdown 语法来写了，要使用 Ocotpress 自定义的 <a href="http://octopress.org/docs/plugins/image-tag/">Image Tag</a> 来插入图片。
然后在发布博文之前，先同步自己的图片，</p>

<pre><code>qrsync qrsync.json 
</code></pre>

<p>然后，生成博文，发布博文</p>

<pre><code>rake generate
rake deploy
</code></pre>

<h3>写在最后</h3>

<p>终于大功告成，通过设置博客，也看到了很多优秀的博客，也看到自己与优秀极客的差距，这也更加坚定了我写博客，记录自己学习的点点滴滴的决心。希望能帮助到你们。有什么问题可以反馈。 Have fun！</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[iOS - UIWebView 动态载入/删除/更新外部 JavaScript/CSS 文件]]></title>
        <link href="http://swplzj.github.io/blog/2015/03/12/ios-uiwebview-dong-tai-zai-ru-slash-shan-chu-slash-geng-xin-wai-bu-javascript-slash-css-wen-jian/"/>
        <updated>2015-03-12T19:59:54+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/03/12/ios-uiwebview-dong-tai-zai-ru-slash-shan-chu-slash-geng-xin-wai-bu-javascript-slash-css-wen-jian</id>
        <content type="html"><![CDATA[<h5>动态载入 JavaScript/CSS 文件</h5>

<p>传统加载外部 <code>JavaScript(*.js)</code> 或者 <code>CSS(*.css)</code> 文件的方法是直接在 <code>&lt;head&gt;</code> 标签里面进行添加:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;head&gt; 
</span><span class='line'>&lt;script type="text/javascript" src="myscript.js"&gt;&lt;/script&gt; 
</span><span class='line'>&lt;link rel="stylesheet" type="text/css" href="main.css" /&gt; 
</span><span class='line'>&lt;/head&gt; </span></code></pre></td></tr></table></div></figure>




<!--more-->


<p>这些文件用这种方式会同步加载到当前这个页面。</p>

<h5>用动态的方式载入 JavaScript/CSS 文件：</h5>

<p>用 DOM createElement 方法创建一个 “script” 或者 ”link” 元素
设置相应的属性
使用 appendChild 方法, 把创建的元素插入到 head 标签的末尾</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function loadjscssfile(filename, filetype){ 
</span><span class='line'>//如果文件类型为 .js ,则创建 script 标签，并设置相应属性 
</span><span class='line'>if (filetype=="js"){ 
</span><span class='line'>var fileref=document.createElement('script'); 
</span><span class='line'>fileref.setAttribute("type","text/javascript"); 
</span><span class='line'>fileref.setAttribute("src", filename); 
</span><span class='line'>} 
</span><span class='line'>//如果文件类型为 .css ,则创建 script 标签，并设置相应属性 
</span><span class='line'>else if (filetype=="css"){ 
</span><span class='line'>var fileref=document.createElement("link"); 
</span><span class='line'>fileref.setAttribute("rel", "stylesheet"); 
</span><span class='line'>fileref.setAttribute("type", "text/css"); 
</span><span class='line'>fileref.setAttribute("href", filename); 
</span><span class='line'>} 
</span><span class='line'>if (typeof fileref!="undefined") 
</span><span class='line'>document.getElementsByTagName("head")[0].appendChild(fileref); 
</span><span class='line'>} 
</span><span class='line'>//动态添加一个.js 文件 
</span><span class='line'>loadjscssfile("myscript.js", "js"); 
</span><span class='line'>//像添加.js文件一样，动态添加一个.php文件 
</span><span class='line'>loadjscssfile("javascript.php", "js"); 
</span><span class='line'>//动态一个.css文件 
</span><span class='line'>loadjscssfile("mystyle.css", "css"); </span></code></pre></td></tr></table></div></figure>


<h5>为了防止多次载入同一个js/css文件， 添加以下判断（这只是粗略检测）</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//临时载入的文件名 
</span><span class='line'>var filesadded=""; 
</span><span class='line'>function checkloadjscssfile(filename, filetype){ 
</span><span class='line'>if (filesadded.indexOf("["+filename+"]")==-1){ 
</span><span class='line'>loadjscssfile(filename, filetype); 
</span><span class='line'>//把 [filename] 存入 filesadded 
</span><span class='line'>filesadded+="["+filename+"]"; 
</span><span class='line'>} 
</span><span class='line'>else{ 
</span><span class='line'>alert("file already added!"); 
</span><span class='line'>} 
</span><span class='line'>//第一次载入 
</span><span class='line'>checkloadjscssfile("myscript.js", "js"); 
</span><span class='line'>//重复载入同一个文件， 失败 
</span><span class='line'>checkloadjscssfile("myscript.js", "js"); </span></code></pre></td></tr></table></div></figure>


<h5>动态删除 JavaScript/Csss 文件</h5>

<p>注意：ie6/7 下动态删除样式时有bug. 2种解决方案：1.样式表里不要有import的样式表 2.把link的type属性设置为空值， 然后再修改 href 的地， 或者直接设置href为空， 最后再把type值设置成”text/css” 强制让ie解释新的样式表。</p>

<p>取得相应的 DOM 元素
根据 文件名&amp;文件类型 定位元素
用 DOM removeChild 删除一个 “script” 或者 ”link” 元素</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function removejscssfile(filename, filetype){ 
</span><span class='line'>//判断文件类型 
</span><span class='line'>var targetelement=(filetype=="js")? "script" : (filetype=="css")? "link" : "none"; 
</span><span class='line'>//判断文件名 
</span><span class='line'>var targetattr=(filetype=="js")? "src" : (filetype=="css")? "href" : "none"; 
</span><span class='line'>var allsuspects=document.getElementsByTagName(targetelement); 
</span><span class='line'>//遍历元素， 并删除匹配的元素 
</span><span class='line'>for (var i=allsuspects.length; i&gt;=0; i--){ 
</span><span class='line'>if (allsuspects[i] && allsuspects[i].getAttribute(targetattr)!=null && allsuspects[i].getAttribute(targetattr).indexOf(filename)!=-1) 
</span><span class='line'>allsuspects[i].parentNode.removeChild(allsuspects[i]); 
</span><span class='line'>} 
</span><span class='line'>} 
</span><span class='line'>removejscssfile("somescript.js", "js"); 
</span><span class='line'>removejscssfile("somestyle.css", "css"); </span></code></pre></td></tr></table></div></figure>


<h5>动态更新 JavaScript/Csss 文件</h5>

<p>使用 createElement 创建 要更新的 JavaScript/Css 元素
查找要被替换的元素
用 replaceChild 替换元素</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function createjscssfile(filename, filetype){ 
</span><span class='line'>if (filetype=="js"){ //if filename is a external JavaScript file 
</span><span class='line'>var fileref=document.createElement('script') 
</span><span class='line'>fileref.setAttribute("type","text/javascript") 
</span><span class='line'>fileref.setAttribute("src", filename) 
</span><span class='line'>} 
</span><span class='line'>else if (filetype=="css"){ //if filename is an external CSS file 
</span><span class='line'>var fileref=document.createElement("link") 
</span><span class='line'>fileref.setAttribute("rel", "stylesheet") 
</span><span class='line'>fileref.setAttribute("type", "text/css") 
</span><span class='line'>fileref.setAttribute("href", filename) 
</span><span class='line'>} 
</span><span class='line'>return fileref 
</span><span class='line'>} 
</span><span class='line'>
</span><span class='line'>function replacejscssfile(oldfilename, newfilename, filetype){ 
</span><span class='line'>var targetelement=(filetype=="js")? "script" : (filetype=="css")? "link" : "none"; 
</span><span class='line'>var targetattr=(filetype=="js")? "src" : (filetype=="css")? "href" : "none"; 
</span><span class='line'>var allsuspects=document.getElementsByTagName(targetelement); 
</span><span class='line'>for (var i=allsuspects.length; i&gt;=0; i--){ 
</span><span class='line'>if (allsuspects[i] && allsuspects[i].getAttribute(targetattr)!=null && allsuspects[i].getAttribute(targetattr).indexOf(oldfilename)!=-1){ 
</span><span class='line'>var newelement=createjscssfile(newfilename, filetype); 
</span><span class='line'>allsuspects[i].parentNode.replaceChild(newelement, allsuspects[i]); 
</span><span class='line'>} 
</span><span class='line'>} 
</span><span class='line'>} 
</span><span class='line'>//用 "newscript.js" 替换 "oldscript.js" 
</span><span class='line'>replacejscssfile("oldscript.js", "newscript.js", "js")； 
</span><span class='line'>//用 "newscript.css" 替换 "oldscript.css" 
</span><span class='line'>replacejscssfile("oldstyle.css", "newscript.css","css"); </span></code></pre></td></tr></table></div></figure>

]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Mac翻墙技巧]]></title>
        <link href="http://swplzj.github.io/blog/2015/03/08/macfan-qiang-ji-qiao/"/>
        <updated>2015-03-08T10:57:41+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/03/08/macfan-qiang-ji-qiao</id>
        <content type="html"><![CDATA[<h4>困扰</h4>

<p>自己一直在寻找Mac上的免费翻墙工具，尝试过很多，但最终都没办法实现，对自己也造成了一些影响，比如需要在国外网站查询一些资料，下载一些应用，观看Youtube视频，刷Facebook，最要命的就是最近自己的Gmail也收不到邮件了，不想购买VPN，那只能尝试找免费翻墙工具了。</p>

<p>终于找到免费翻墙的工具了</p>

<p>不敢独享，故贴出来和大家分享一下。</p>

<!--more-->


<h4>终于等到你，还好我没放弃</h4>

<h5>这种翻墙方法的优点：</h5>

<ul>
<li>免费</li>
<li>无需下载任何软件</li>
<li>配置门槛低，简单</li>
</ul>


<h5>工具使用方法</h5>

<p><code>工具网址</code></p>

<p>首先打开网站：<a href="http://vcup.in/nyve">VPNCUP</a></p>

<p><code>使用方法</code></p>

<h6>注册账号</h6>

<p>在这个网站上注册一个账号。</p>

<h6>设置VPN登录密码</h6>

<p>因为在配置网络的时候，都会使用到VPN的登录密码来进行验证，这个密码不是你的账号登录密码，你需要在我的账户里面来开启，并进行设置。</p>

<p>1、进入<code>我的账户</code>中的<code>VPN账户</code>;</p>

<p>2、将<code>VPN账户状态</code>设置为<code>开放</code>;</p>

<p>3、设置<code>VPN登录密码</code>;</p>

<h6>配置电脑网络设置</h6>

<p>关于如何配置电脑的网络设置，在官网有详细的说明，下面给出相应的链接，大家跟着说明一步步做就好了</p>

<ul>
<li><a href="https://www.vcup136.com/config/windows-xp">Windows XP设置登录VPN服务器图文介绍</a></li>
<li><a href="https://www.vcup136.com/config/iphone-l2tp">Apple Iphone和Apple iTouch设置登录VPN服务器图文介绍(L2TP模式)</a></li>
<li><a href="https://www.vcup136.com/config/iphone">Apple Iphone和Apple iTouch设置登录VPN服务器图文介绍(PPTP模式)</a></li>
<li><a href="https://www.vcup136.com/config/macosx">mac系统下的配置指南</a></li>
<li><a href="https://www.vcup136.com/config/ubuntu">Ubuntu设置VPN</a></li>
<li><a href="https://www.vcup136.com/config/windows">windows系统下的配置指南</a></li>
<li><a href="https://www.vcup136.com/config/android">Android系统设置VPN</a></li>
</ul>


<h4>总结</h4>

<p>设置完成了，大家可以享受墙外的世界了，希望能帮助到你。</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[面向 iOS 开发的优秀 XCode 插件]]></title>
        <link href="http://swplzj.github.io/blog/2015/02/13/mian-xiang-ios-kai-fa-de-you-xiu-xcode-cha-jian/"/>
        <updated>2015-02-13T21:05:50+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/02/13/mian-xiang-ios-kai-fa-de-you-xiu-xcode-cha-jian</id>
        <content type="html"><![CDATA[<p>一套理想的插件架构几乎能够决定整个集成开发环境的差异与特性。Sublime Text与TextMate就是很好的实例。但大家可能不了解的是，Xcode也支持插件。哈哈，如果各位真的前所未闻，我也不会感到惊讶，毕竟苹果并没有把太多精力用在Xcode的宣传之上。事实上，我们几乎找不到多少用于指导Xcode创建的说明文档。</p>

<p>幸运的是，这并没有妨碍开发人员在Xcode这片土地上耕耘并构建自己的插件果实。目前市面上存在大量插件，能够让我们的Xcode使用之旅更加平坦也更富乐趣，甚至足以弥合苹果在其中留下的所有沟壑。在今天的文章中，我将向大家展示自己在日常工作中频繁用到的几款优秀插件。</p>

<!--more-->


<h5>Alcatraz</h5>

<p>过去，安装Xcode插件往往令人抓狂不已，但Alcatraz的出现彻底改写了这一历史。今年早些时候，Alcatraz迎来了发展道路上的里程碑——1.0版本，现在如今已经可以与Xcode 5相兼容。如果大家还没有安装Alcatraz，我建议大家首先完成这项工作。</p>

<p>官方网站：<a href="http://alcatraz.io/">http://alcatraz.io/</a></p>

<h5>XToDo</h5>

<p>这款插件不仅能够着力强调TODO、FIXME、？？？以及！！！注释，同时可以按住 control + T 可以快速查看专用列表，并且可以自定义一些标签。</p>

<p><img src="http://s9.51cto.com/wyfs02/M00/46/84/wKioL1Pyvc2iUbyMAABLbcwVzmM494.jpg" alt="id1" /></p>

<p>官方网站：<a href="https://github.com/trawor/XToDo">https://github.com/trawor/XToDo</a></p>

<h5>Dash for Xcode</h5>

<p>Dash是一款用于浏览文档的优秀软件，我每天都会反复加以运用。更让人喜出望外的是，它现在已经与Xcode相集成，这要归功于其Xcode插件。大家可能知道，我们可以在Xcode编辑器中按住Option键同时点击以直接前往对应文档。不过我对于Xcode自带来的文档浏览器评价不高，在这种情况下Dash插件就成了最理想的解决方案。</p>

<p><img src="http://s2.51cto.com/wyfs02/M00/46/83/wKiom1PyvYOBTuZFAACLZqMVukQ768.jpg" alt="id2" /></p>

<p>该插件能够在我们按住Option并点击对应文档后利用Dash而非Xcode自带文档浏览器将其打开。Dash不仅运行速度极快，同时还能与CocoaDocs相集成。举例来说，如果大家用这种方式点击AFNetworking库中的一个方法，那么Dash将显示出该方法的说明文档。我超爱这项功能。</p>

<p>官方网站：<a href="http://kapeli.com/dash">http://kapeli.com/dash</a></p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[即时通讯类移动APP开发要点]]></title>
        <link href="http://swplzj.github.io/blog/2015/02/06/ji-shi-tong-xun-lei-yi-dong-appkai-fa-yao-dian/"/>
        <updated>2015-02-06T16:05:06+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/02/06/ji-shi-tong-xun-lei-yi-dong-appkai-fa-yao-dian</id>
        <content type="html"><![CDATA[<p>即时通讯（IM）软件作为满足人们沟通需求的工具，十几年来一直长盛不衰，并随着移动时代的到来迎来了新的增长。如在国内广泛使用的微信，在北美广泛使用的Whatsapp、Kik，在亚洲广泛使用的Line、KakaoTalk。另外还有其他一些以独特视角切入移动IM市场的APP，主打阅后即焚、私密消息等。</p>

<p>试着从技术的角度来总结这一类应用的开发要点，或者说是相比桌面版的IM软件，移动IM应用开发需要注意的地方，欢迎指正和补充。</p>

<!--more-->


<h5>网络</h5>

<h6>移动APP经常随着移动设备在不同的网络之间切换，所以处理好网络切换、断网、重连就至关重要。</h6>

<p>解决这个问题的办法，就是要求移动APP能以尽量少的通讯量、尽快的速度重新注册服务器。</p>

<p>比如不再从服务器获取配置信息、联系人信息和联系人状态等。</p>

<p>但是如果这段时间服务器端有变化发生，就需要服务器有推送变化信息的能力。</p>

<p>同时，服务器对客户端重连间隔要保持宽容态度，不要因为客户端在给定的较短时间内没有重连上就移除这个会话。要知道，在移动环境下，客户端断掉连接只是不得已，一有机会，它就会努力重连上来的。</p>

<p>另外，由于网络的不稳定性，消息的发送方和接受方一定要有确认机制，不管这种确认机制是端对端的的还是通过服务器中转，以避免客户端突然掉线，而服务器还未及时知晓的情况。</p>

<h5>电池</h5>

<h6>移动APP必须尽量减少电池的消耗。</h6>

<p>以iOS为例，它以三个规则来强制APP最小化电池消耗：</p>

<ol>
<li><p>APP在后台是不能主动运行的，特定功能的APP可以设置timer唤醒，但最频繁也只能每10分钟运行若干秒。</p></li>
<li><p>APP在后台被唤醒的次数有严格限制，不能在300秒内被唤醒超过15次，否则被系统终止。</p></li>
<li><p>APP即使申请后台任务，最多也只有60秒的运行时间。</p></li>
</ol>


<p>满足这些要求的最好办法，就是不要试图让移动IM应用在后台运行。而把网络监听这样的任务，在APP进入后台的时候转交给iOS系统来完成。</p>

<p>而服务器则要有灵活的过滤机制，不管是主动还是被动的，过滤掉绝大多数试图发给客户端的网络通讯，以保持客户端睡眠的状态。而仅仅把必要的信息，如即时消息，推送给客户端。</p>

<h5>内存</h5>

<h6>移动APP要尽量减少内存消耗。</h6>

<p>以iOS为例，系统会保持尽可能多的APP在内存中，但是内存不足时它就会终止已被挂起的APP来回收内存。这种情况下，首先被回收的就是占内存多的后台APP。</p>

<p>解决这个问题的一个办法，就是在内存消耗较多的模块，通常是模型层的组件，提供持久化机制。当APP切换到后台的时候保存大多数暂时不会用到的数据到文件系统，等回到前台的时候再重建这些数据结构。</p>

<p>比如所有联系人的详细信息就适合这么做。</p>

<h5>系统资源</h5>

<h6>移动APP要尽量减少对系统资源的占有。</h6>

<p>应该以最少使用时间为原则来使用系统资源，以iOS为例，在APP切换到后台之前就要放弃对地址簿的访问。</p>

<h5>后台运行</h5>

<p>以上几点都跟APP在后台运行有关，其实这也是移动IM应用的一大特点。所谓养兵千日、用兵一时，移动IM应用绝大多数时间都躺在后台，所以处理好后台运行就处理好了移动IM应用的大部分。</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[valueForKeyPath的使用总结]]></title>
        <link href="http://swplzj.github.io/blog/2015/01/16/valueforkeypathde-shi-yong-zong-jie/"/>
        <updated>2015-01-16T21:10:46+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/01/16/valueforkeypathde-shi-yong-zong-jie</id>
        <content type="html"><![CDATA[<p>可能大家对- (id)valueForKeyPath:(NSString *)keyPath方法不是很了解。
其实这个方法非常的强大，具体有以下几个功能:</p>

<h5>对数组中的每个元素执行成员实例方法</h5>

<!--more-->




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSArray *array = @[@"name", @"w", @"aa", @"jimsa"];
</span><span class='line'>NSLog(@"%@", [array valueForKeyPath:@"uppercaseString"]);</span></code></pre></td></tr></table></div></figure>


<p>输出</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(
</span><span class='line'>    NAME,
</span><span class='line'>    W,
</span><span class='line'>    AA,
</span><span class='line'>    JIMSA
</span><span class='line'>)</span></code></pre></td></tr></table></div></figure>


<p>相当于数组中的每个成员执行了uppercaseString方法，然后把返回的对象组成一个新数组返回。既然可以用uppercaseString方法，那么NSString的其他方法也可以，比如</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[array valueForKeyPath:@"length"]</span></code></pre></td></tr></table></div></figure>


<p>返回每个字符串长度的组成的数组。只要你能想到的成员实例方法都可以这么用。</p>

<h5>对NSNumber数组快速计算数组求和、平均数、最大值、最小值</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSArray *array = @[@1, @2, @3, @4, @10];
</span><span class='line'>NSNumber *sum = [array valueForKeyPath:@"@sum.self"];
</span><span class='line'>NSNumber *avg = [array valueForKeyPath:@"@avg.self"];
</span><span class='line'>NSNumber *max = [array valueForKeyPath:@"@max.self"];
</span><span class='line'>NSNumber *min = [array valueForKeyPath:@"@min.self"];</span></code></pre></td></tr></table></div></figure>


<p></p>

<h5>或者指定输出类型</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSNumber *sum = [array valueForKeyPath:@"@sum.floatValue"];
</span><span class='line'>NSNumber *avg = [array valueForKeyPath:@"@avg.floatValue"];
</span><span class='line'>NSNumber *max = [array valueForKeyPath:@"@max.floatValue"];
</span><span class='line'>NSNumber *min = [array valueForKeyPath:@"@min.floatValue"];</span></code></pre></td></tr></table></div></figure>


<h5>剔除重复数据</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSArray *array = @[@"name", @"w", @"aa", @"jimsa", @"aa"];
</span><span class='line'>NSLog(@"%@", [array valueForKeyPath:@"@distinctUnionOfObjects.self"]);</span></code></pre></td></tr></table></div></figure>


<p>打印</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(
</span><span class='line'>name,
</span><span class='line'>w,
</span><span class='line'>jimsa,
</span><span class='line'>aa
</span><span class='line'>)</span></code></pre></td></tr></table></div></figure>


<h5>对NSDictionary数组快速找出相应key对的值</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSArray *array = @[@{@"name" : @"cookeee",@"code" : @1},
</span><span class='line'>                           @{@"name": @"jim",@"code" : @2},
</span><span class='line'>                           @{@"name": @"jim",@"code" : @1},
</span><span class='line'>                           @{@"name": @"jbos",@"code" : @1}];
</span><span class='line'>NSLog(@"%@", [array valueForKeyPath:@"name"]);</span></code></pre></td></tr></table></div></figure>


<p>直接得到字典中namekey对应的值组成的数组，显然比循环取值再加入到新数组中方便快捷</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(
</span><span class='line'>    cookeee,
</span><span class='line'>    jim,
</span><span class='line'>    jim,
</span><span class='line'>    jbos
</span><span class='line'>)</span></code></pre></td></tr></table></div></figure>


<p>同样可以嵌套使用，先剔除name对应值的重复数据再取值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> NSArray *array = @[@{@"name" : @"cookeee",@"code" : @1},
</span><span class='line'>                           @{@"name": @"jim",@"code" : @2},
</span><span class='line'>                           @{@"name": @"jim",@"code" : @1},
</span><span class='line'>                           @{@"name": @"jbos",@"code" : @1}];
</span><span class='line'>
</span><span class='line'>NSLog(@"%@", [array valueForKeyPath:@"@distinctUnionOfObjects.name"]);</span></code></pre></td></tr></table></div></figure>


<p>打印</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(
</span><span class='line'>cookeee,
</span><span class='line'>jim,
</span><span class='line'>jbos
</span><span class='line'>)</span></code></pre></td></tr></table></div></figure>


<h5>改变UITextfiedl的placeholder的颜色</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[searchField setValue:[UIColor whiteColor] forKeyPath:@"_placeholderLabel.textColor"];</span></code></pre></td></tr></table></div></figure>


<p>比起重写</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)drawPlaceholderInRect:(CGRect)rect;</span></code></pre></td></tr></table></div></figure>


<p>要方便很多</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[Objective-C中的Selector和SEL]]></title>
        <link href="http://swplzj.github.io/blog/2015/01/07/objective-czhong-de-selectorhe-sel/"/>
        <updated>2015-01-07T10:32:05+08:00</updated>
        <id>http://swplzj.github.io/blog/2015/01/07/objective-czhong-de-selectorhe-sel</id>
        <content type="html"><![CDATA[<h4>Objective-C中Selector基本概念和操作</h4>

<p>简而言之，你可以理解 @selector()就是取类方法的编号,他的行为基本可以等同C语言的中函数指针,只不过C语言中，可以把函数名直接赋给一个函数指针，而Objective-C的类不能直接应用函数指针，这样只能做一个@selector语法来取.</p>

<!--more-->


<p></p>

<p>它的结果是一个SEL类型。这个类型本质是类方法的编号(函数地址)?因此我们有如下代码。</p>

<h5>一、取得selector值.</h5>

<p>C函数指针</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int add(int val)  
</span><span class='line'>{  
</span><span class='line'>  return val+1;  
</span><span class='line'>}  
</span><span class='line'>int (* c_func)(int val); //定义一个函数指针变量  
</span><span class='line'>_func = add ;  //把函数addr地址直接赋给c_func </span></code></pre></td></tr></table></div></figure>


<p>Objective-C的选择器,</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface foo  
</span><span class='line'>-(int)add:int val;  
</span><span class='line'>@end  
</span><span class='line'> 
</span><span class='line'>SEL class_func ; //定义一个类方法指针  
</span><span class='line'>class_func = @selector(add:int); </span></code></pre></td></tr></table></div></figure>


<p><code>注意:</code></p>

<ol>
<li>@selector是查找当前类的方法，而[object @selector(方法名:方法参数..) ] ;是取object对应类的相庆方法;</li>
<li>查找类方法时，除了方法名,方法参数也查询条件之一.</li>
<li>可以用字符串来找方法 SEL　变量名　=　NSSelectorFromString(方法名字的字符串);</li>
<li>可以运行中用SEL变量反向查出方法名字字符串</li>
</ol>


<p>NSString　*变量名　=　NSStringFromSelector(SEL参数);</p>

<h5>二、执行selector值.</h5>

<p>取得相庆值后，怎么处理SEL值呢，这一点仍然与函数指针一样，就是执行它</p>

<p>函数指针执行，（以下有几种等效形式）</p>

<ul>
<li>*c_func(10);</li>
<li>c_func(10);</li>
<li>SEL变量的执行.用performSelecor方法来执行.</li>
<li>[对象　performSelector:SEL变量　withObject:参数1　withObject:参数2];</li>
</ul>


<h5>三.selector的应用场合</h5>

<p>selector本质是跟C的回调函数一样。主要用于两个对象之间进行松耦合的通讯.这种方法很多开发环境用到。比如GTK，Delphi.基本上整个Cocoa库之间对象，控制之间通讯都是在这个基础构建的。</p>

<h4>SEL</h4>

<p>在Objective-C中，SEL是选择器（selector）的一个类型。选择器就是指向方法的一个指针，读者可以简单理解为程序运行到这里就会执行指定的方法，可以这样定义一个选择器：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SEL action = [button action]; </span></code></pre></td></tr></table></div></figure>


<p>我们这样使用一个选择器，下面的选择器都叫做action：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[Foo action]  
</span><span class='line'>[Bar action] </span></code></pre></td></tr></table></div></figure>


<p>在Target-Action 模式（Cocoa 程序中的一种常用模式）中：Target 指定了一个类，Action指定一个方法。在一个对象上设置Action就是通过选择器完成的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-（void）setTarget:（id）target;  
</span><span class='line'>-（void）setAction:（SEL）action; </span></code></pre></td></tr></table></div></figure>


<p>下述语句设置了一个button对象上的Action为“@selector（start:）”，即它调用start方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[button setAction:@selector（start:）]; </span></code></pre></td></tr></table></div></figure>


<p>如果你的方法上有两个参数，比如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-（void）setName:（NSString *）name age:（int）age; </span></code></pre></td></tr></table></div></figure>


<p>那么，你的选择器应该这样书写：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SEL sel = @selector（setName:age:）; </span></code></pre></td></tr></table></div></figure>


<p>如果方法不存在的话，调用该方法的应用可能会异常中止。所以，需要使用respondsToSelector 方法来判断该对象是否存在对应的方法，使用performSelector:withObject:方法来调用选择器：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SEL sel = @selector (start:) ; // 指定action  
</span><span class='line'>if ([obj respondsToSelector:sel]) { //判断该对象是否有相应的方法  
</span><span class='line'>[obj performSelector:sel withObject:self]; //调用选择器方法  
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>下面来看一个应用选择器的实例。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import &lt;Foundation/Foundation.h&gt; 
</span><span class='line'>@interface ClassA : NSObject {  
</span><span class='line'>}  
</span><span class='line'>- (void) print;  
</span><span class='line'>@end  
</span><span class='line'>@implementation ClassA  
</span><span class='line'>- (void) print{  
</span><span class='line'>NSLog (@"I'm ClassA.") ;  
</span><span class='line'>}  
</span><span class='line'>@end  
</span><span class='line'>int main (int argc, const char * argv[]) {  
</span><span class='line'>NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];  
</span><span class='line'>SEL sel = @selector (print) ;  
</span><span class='line'>ClassA *classA = [[ClassA alloc]init];  
</span><span class='line'>[classA performSelector:sel withObject:nil]; //调用选择器指定的方法  
</span><span class='line'>[pool drain];  
</span><span class='line'>return 0;  
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>【程序结果】</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>I'm ClassA. </span></code></pre></td></tr></table></div></figure>


<p>下面解释一下这段代码，读者有可能看不明白，因为到目前为止并没有讲述类相关的知识。读者只需要了解上述例子中选择器的用法即可，关于类的知识，会在后面的章节详细阐述。</p>

<p>代码首先创建了一个名字叫ClassA 的类，它只包含一个方法print。在随后的实现文件中，我们实现了这个方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void) print{  
</span><span class='line'>NSLog (@"I'm ClassA.") ;  
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>读者不难看出，这个方法仅仅是打印到控制台上一句话。在接下来的main方法中，定义了一个选择器sel，它指向的是一个名叫print 的方法。我们并不知道这个方法是哪个类的，因为具体的信息是在运行期间系统自动帮我们判断的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SEL sel = @selector (print) ; </span></code></pre></td></tr></table></div></figure>


<p>随后构建了一个对象（读者不用拘泥于语法，我们会在后面的章节详细阐述），并调用这个对象performSelector:withObject:的方法。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ClassA *classA = [[ClassA alloc]init];  
</span><span class='line'>[classA performSelector:sel withObject:nil]; </span></code></pre></td></tr></table></div></figure>


<p>这时候，系统就会自动调用classA对象的print方法，最终得到程序运行结果。</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[使用神奇的PONYDEBUGGER调试iOS应用]]></title>
        <link href="http://swplzj.github.io/blog/2014/12/14/shi-yong-shen-qi-de-ponydebugger-tiao-shi-ios-ying-yong/"/>
        <updated>2014-12-14T17:30:40+08:00</updated>
        <id>http://swplzj.github.io/blog/2014/12/14/shi-yong-shen-qi-de-ponydebugger-tiao-shi-ios-ying-yong</id>
        <content type="html"><![CDATA[<h3>前言</h3>

<p>Debug算是开发者的基本技能之一吧，对于iOS开发者而言，可能会遇到如下一些debug需求：</p>

<p>调试网络请求问题
调试一个层次结构复杂的用户界面
查看应用内Core Data数据变化
虽然你可以通过NSLog日志，打断点，抑或LLDB的调试命令等一些常见手段来解决以上问题，但这些方式始终不够直观，效率也不高，特别是对于调试UI这个需求。要提高效率，我们可以使用一些第三方的调试工具，比如本文要介绍的PonyDebugger。</p>

<!--more-->


<h3>关于PonyDebugger</h3>

<p>PonyDebugger是Square开源的一个远程调试工具包，它可以通过Chrome开发者工具来调试iOS应用的网络流量，数据存储以及用户界面。</p>

<h3>安装和使用</h3>

<h4>服务端安装</h4>

<p>curl -sk <a href="https://cloud.github.com/downloads/square/PonyDebugger/bootstrap-ponyd.py">https://cloud.github.com/downloads/square/PonyDebugger/bootstrap-ponyd.py</a> | \ python - &ndash;ponyd-symlink=/usr/local/bin/ponyd ~/Library/PonyDebugger</p>

<p>安装时遇到的一些坑记录如下：</p>

<p>移动宽带下偶尔出现连接不上pypi的情况，使用电信宽带则正常，移动宽带用户可以改用国内的镜像地址，比如V2EX的pypi镜像<a href="http://pypi.v2ex.com/simple">http://pypi.v2ex.com/simple</a>
服务端依赖pybonjour，但是在zsh终端下使用pip安装会提示找不到这个包，需要手动安装，添加allow-external和allow-unverified
手动安装方法如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>source ~/Library/PonyDebugger/bin/activate
</span><span class='line'>
</span><span class='line'>pip install -U -e git+https://github.com/square/PonyDebugger.git#egg=ponydebugger --allow-external pybonjour --allow-unverified pybonjour
</span><span class='line'>
</span><span class='line'>ponyd update-devtools</span></code></pre></td></tr></table></div></figure>


<h4>客户端安装</h4>

<p>使用CocoaPods，在PodFile中添加以下依赖：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod 'PonyDebugger', '~&gt; 0.3.1'</span></code></pre></td></tr></table></div></figure>


<p>也可以直接指向Github开源地址，这样可以随时使用最新版本的代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod 'PonyDebugger', :git =&gt; 'https://github.com/square/PonyDebugger.git'</span></code></pre></td></tr></table></div></figure>


<h4>使用</h4>

<p>终端输入以下命令启动服务端，然后Chrome打开<a href="http://localhost:9000">http://localhost:9000</a> ，使用开发者工具即可进行调试</p>

<p>ponyd serve &ndash;listen-interface=127.0.0.1</p>

<p>为了便于随时开启和关闭PonyDebugger，客户端在Preprocessor Macros中定义了一个宏ENABLE_PONYDEBUGGER</p>

<p>在AppDeleagate的didFinishLaunchingWithOptions方法中使用如下代码进行一些初始化工作：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#if ENABLE_PONYDEBUGGER
</span><span class='line'>
</span><span class='line'>    PDDebugger *debugger = [PDDebugger defaultInstance];
</span><span class='line'>    
</span><span class='line'>    // Enable Network debugging, and automatically track network traffic that comes through any classes that NSURLConnectionDelegate methods.
</span><span class='line'>    [debugger enableNetworkTrafficDebugging];
</span><span class='line'>    [debugger forwardAllNetworkTraffic];
</span><span class='line'>    
</span><span class='line'>    // Enable Core Data debugging, and broadcast the main managed object context.
</span><span class='line'>    [debugger enableCoreDataDebugging];
</span><span class='line'>    [debugger addManagedObjectContext:self.managedObjectContext withName:@"Twitter Test MOC"];
</span><span class='line'>    
</span><span class='line'>    // Enable View Hierarchy debugging. This will swizzle UIView methods to monitor changes in the hierarchy
</span><span class='line'>    // Choose a few UIView key paths to display as attributes of the dom nodes
</span><span class='line'>    [debugger enableViewHierarchyDebugging];
</span><span class='line'>    [debugger setDisplayedViewAttributeKeyPaths:@[@"frame", @"hidden", @"alpha", @"opaque", @"accessibilityLabel", @"text"]];
</span><span class='line'>    
</span><span class='line'>    // Connect to a specific host
</span><span class='line'>    [debugger connectToURL:[NSURL URLWithString:@"ws://localhost:9000/device"]];
</span><span class='line'>    // Or auto connect via bonjour discovery
</span><span class='line'>    //[debugger autoConnect];
</span><span class='line'>    // Or to a specific ponyd bonjour service
</span><span class='line'>    //[debugger autoConnectToBonjourServiceNamed:@"MY PONY"];
</span><span class='line'>
</span><span class='line'>    // Enable remote logging to the DevTools Console via PDLog()/PDLogObjects().
</span><span class='line'>    [debugger enableRemoteLogging];
</span><span class='line'>    
</span><span class='line'>#endif</span></code></pre></td></tr></table></div></figure>


<p>Chrome看到网页显示如下说明连接成功：</p>

<p><img src="http://ww4.sinaimg.cn/large/674a21d2gw1eemkgp4t9rj216c0ea40f.jpg" alt="id1" /></p>

<p>点击网页中间的应用名即可跳转到debug工具</p>

<h4>实现原理</h4>

<p>简单看了一下PonyDebugger的源码，服务端使用Tornado框架提供WebSocket服务，客户端则是基于Square自家开源的SocketRocket，关于WebSocket相关的知识，可以参考我之前的这篇博文。</p>

<p>网络请求抓包功能是通过注入到NSURLConnectionDelegate中实现的，代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (void)injectIntoAllNSURLConnectionDelegateClasses;
</span><span class='line'>{
</span><span class='line'>    // Only allow swizzling once.
</span><span class='line'>    static BOOL swizzled = NO;
</span><span class='line'>    if (swizzled) {
</span><span class='line'>        return;
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    swizzled = YES;
</span><span class='line'>
</span><span class='line'>    // Swizzle any classes that implement one of these selectors.
</span><span class='line'>    const SEL selectors[] = {
</span><span class='line'>        @selector(connectionDidFinishLoading:),
</span><span class='line'>        @selector(connection:didReceiveResponse:)
</span><span class='line'>    };
</span><span class='line'>    
</span><span class='line'>    const int numSelectors = sizeof(selectors) / sizeof(SEL);
</span><span class='line'>
</span><span class='line'>    Class *classes = NULL;
</span><span class='line'>    NSInteger numClasses = objc_getClassList(NULL, 0);
</span><span class='line'>    
</span><span class='line'>    if (numClasses &gt; 0) {
</span><span class='line'>        classes = (__unsafe_unretained Class *)malloc(sizeof(Class) * numClasses);
</span><span class='line'>        numClasses = objc_getClassList(classes, numClasses);
</span><span class='line'>        for (NSInteger classIndex = 0; classIndex &lt; numClasses; ++classIndex) {
</span><span class='line'>            Class class = classes[classIndex];
</span><span class='line'>            
</span><span class='line'>            if (class_getClassMethod(class, @selector(isSubclassOfClass:)) == NULL) {
</span><span class='line'>                continue;
</span><span class='line'>            }
</span><span class='line'>            
</span><span class='line'>            if (![class isSubclassOfClass:[NSObject class]]) {
</span><span class='line'>                continue;
</span><span class='line'>            }
</span><span class='line'>            
</span><span class='line'>            if ([class isSubclassOfClass:[PDNetworkDomainController class]]) {
</span><span class='line'>                continue;
</span><span class='line'>            }
</span><span class='line'>            
</span><span class='line'>            for (int selectorIndex = 0; selectorIndex &lt; numSelectors; ++selectorIndex) {
</span><span class='line'>                if ([class instancesRespondToSelector:selectors[selectorIndex]]) {
</span><span class='line'>                    [self injectIntoDelegateClass:class];
</span><span class='line'>                    break;
</span><span class='line'>                }
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>        
</span><span class='line'>        free(classes);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>从这个实现也可以发现，像ASIHttpRequest这样的直接基于底层CFNetwork封装的库，以及iOS 7中新引入的NSURLSession都是无法抓到请求包的，这种情况下如果需要抓包就只能使用Charles这类工具了。</p>

<p>调试视图功能调用了一些runtime的私有API，部分代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (void)startMonitoringUIViewChanges;
</span><span class='line'>{
</span><span class='line'>    // Swizzle UIView add/remove methods to monitor changes in the view hierarchy
</span><span class='line'>    // Only do it once to avoid swapping back if this method is called again
</span><span class='line'>    static dispatch_once_t onceToken;
</span><span class='line'>    dispatch_once(&onceToken, ^{
</span><span class='line'>        Method original, swizzle;
</span><span class='line'>        Class viewClass = [UIView class];
</span><span class='line'>
</span><span class='line'>        // Using sel_registerName() because compiler complains about the swizzled selectors not being found.
</span><span class='line'>        original = class_getInstanceMethod(viewClass, @selector(addSubview:));
</span><span class='line'>        swizzle = class_getInstanceMethod(viewClass, sel_registerName("pd_swizzled_addSubview:"));
</span><span class='line'>        method_exchangeImplementations(original, swizzle);
</span><span class='line'>        
</span><span class='line'>        ···
</span><span class='line'>                  
</span><span class='line'>        original = class_getInstanceMethod(viewClass, @selector(exchangeSubviewAtIndex:withSubviewAtIndex:));
</span><span class='line'>        swizzle = class_getInstanceMethod(viewClass, sel_registerName("pd_swizzled_exchangeSubviewAtIndex:withSubviewAtIndex:"));
</span><span class='line'>        method_exchangeImplementations(original, swizzle);
</span><span class='line'>    });
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这部分可以看到是通过Method Swizzling来动态交换了UIView的方法实现，以addSubview为例，替换成了pd_swizzled_addSubview，至于pd_swizzled_addSubview的实现请看下面</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)pd_swizzled_addSubview:(UIView *)subview;
</span><span class='line'>{
</span><span class='line'>    [[PDDOMDomainController defaultInstance] removeView:subview];
</span><span class='line'>    [self pd_swizzled_addSubview:subview];
</span><span class='line'>    [[PDDOMDomainController defaultInstance] addView:subview];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>替换后的removeView和addView方法都是重新实现的，里面会将UIView的变动以DOM形式写到PDDOMDomain对象中输出。</p>

<p>除了以上两个主要功能，还有Core Data远程调试，日志远程输出等功能，其实现方式大同小异，就不一一赘述了。</p>

<p>总的来说，PonyDebugger的功能还是十分强大的，也能够有效地提高开发者的调试效率，有类似需求的很值得一试。</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[使用VIPER构建iOS应用]]></title>
        <link href="http://swplzj.github.io/blog/2014/12/07/shi-yong-viper-chuang-jian-kuang-jia/"/>
        <updated>2014-12-07T22:03:17+08:00</updated>
        <id>http://swplzj.github.io/blog/2014/12/07/shi-yong-viper-chuang-jian-kuang-jia</id>
        <content type="html"><![CDATA[<p>建筑领域流行这样一句话，“我们虽然在营造建筑，但建筑也会重新塑造我们”。正如所有开发者最终领悟到的，这句话同样适用于构建软件。</p>

<p>编写代码中至关重要的是，需要使每一部分容易被识别，赋有一个特定而明显的目的，并与其他部分在逻辑关系中完美契合。这就是我们所说的软件架构。好的架构不仅让一个产品成功投入使用，还可以让产品具有可维护性，并让人不断头脑清醒的对它进行维护！</p>

<!--more-->


<p>在这篇文章中，我们介绍了一种称之为 <a href="http://mutualmobile.github.io/blog/2013/12/04/viper-introduction/">VIPER</a> 的 iOS 应用架构的方式。VIPER 已经在很多大型的项目上成功实践，但是出于本文的目的我们将通过一个待办事项清单 (to-do app) 来介绍 VIPER 。你可以在 <a href="https://github.com/objcio/issue-13-viper">GitHub</a> 上关注这个项目。</p>

<h5>什么是 VIPER？</h5>

<p>测试永远不是构建 iOS 应用的主要部分。当我们 <a href="https://github.com/mutualmobile/">Mutual Mobile</a> 着手改善我们的测试实践时，我们发现给 iOS 应用写测试代码非常困难。因此如果想要设法改变测试的现状，我们首先需要一个更好的方式来架构应用，我们称之为 VIPER。</p>

<p>VIPER 是一个创建 iOS 应用<a href="http://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html">简明构架</a>的程序。VIPER 可以是视图 (View)，交互器 (Interactor)，展示器 (Presenter)，实体 (Entity) 以及路由 (Routing) 的首字母缩写。简明架构将一个应用程序的逻辑结构划分为不同的责任层。这使得它更容易隔离依赖项 (如数据库)，也更容易测试各层间的边界处的交互：
<img src="http://www.cocoachina.com/cms/uploads/allimg/140703/8370_140703100012_1.jpg" alt="id1" /></p>

<p>大部分 iOS 应用利用 MVC 构建，使用 MVC 应用程序架构可以引导你将每一个类看做模型，视图或控制器中的一个。但由于大部分应用程序的逻辑不会存在于模型或视图中，所以通常最终总是在控制器里实现。这就导致一个称为<a href="https://twitter.com/Colin_Campbell/status/293167951132098560">重量级视图控制器</a>的问题，在这里，视图控制器做了太多工作。为这些重量级视图控制器<a href="http://www.objc.io/issue-1/lighter-view-controllers.html">瘦身</a>并不是 iOS 开发者寻求提高代码的质量所要面临的唯一挑战，但至少这是一个很好的开端。</p>

<p>VIPER 的不同层提供了明确的程序逻辑以及导航控制代码来应对这个挑战，利用 VIPER ，你会注意到在我们的待办事项示例清单中的视图控制器可以简洁高效，意义明确地控制视图。你也会发现视图控制器中代码和所有的其他类很容易理解，容易测试，理所当然也更易维护。</p>

<h5>基于用例的应用设计</h5>

<p>应用通常是一些用户用例的集合。用例也被称为验收标准，或行为集，它们用来描述应用的用途。清单可以根据时间，类型以及名字排序，这就是一个用例。用例是应用程序中用来负责业务逻辑的一层，应独立于用户界面的实现，同时要足够小，并且有良好的定义。决定如何将一个复杂的应用分解成较小的用例非常具有挑战性，并且需要长期实践，但这对于缩小你解决的问题时所要面临的范围及完成的每个类的所要涉及的内容来说，是很有帮助的。</p>

<p>利用 VIPER 建立一个应用需要实施一组套件来满足所有的用例，应用逻辑是实现用例的主要组成部分，但却不是唯一。用例也会影响用户界面。另一个重要的方面，是要考虑用例如何与其他应用程序的核心组件相互配合，例如网络和数据持久化。组件就好比用例的插件，VIPER 则用来描述这些组件的作用是什么，如何进行交互。</p>

<p>我们其中一个用例，或者说待办事项清单中其中的一个需求是可以基于用户的选择来将待办事项分组。通过分离的逻辑将数据组织成一个用例，我们能够在测试时使用户界面代码保持干净，用例更易组装，从而确保它如我们预期的方式工作。</p>

<h5>VIPER 的主要部分</h5>

<p>VIPER 的主要部分是：</p>

<p>视图：根据展示器的要求显示界面，并将用户输入反馈给展示器。
交互器：包含由用例指定的业务逻辑。
展示器：包含为显示（从交互器接受的内容）做的准备工作的相关视图逻辑，并对用户输入进行反馈（从交互器获取新数据）。
实体：包含交互器要使用的基本模型对象。
路由：包含用来描述屏幕显示和显示顺序的导航逻辑。</p>

<p>这种分隔形式同样遵循<a href="http://www.objectmentor.com/resources/articles/srp.pdf">单一责任原则</a>。交互器负责业务分析的部分，展示器代表交互设计师，而视图相当于视觉设计师。</p>

<p>以下则是不同组件的相关图解，并展示了他们之间是如何关联的：</p>

<p><img src="http://www.cocoachina.com/cms/uploads/allimg/140703/8370_140703100110_1.png" alt="id2" /></p>

<p>虽然在应用中 VIPER 的组件可以以任意顺序实现，我们在这里选择按照我们推荐的顺序来进行介绍。你会注意到这个顺序与构建整个应用的进程大致符合 &ndash; 首先要讨论的是产品需要做什么，以及用户会如何与之交互。</p>

<h5>交互器</h5>

<p>交互器在应用中代表着一个独立的用例。它具有业务逻辑以操纵模型对象（实体）执行特定的任务。交互器中的工作应当独立与任何用户界面，同样的交互器可以同时运用于 iOS 应用或者 OS X 应用中。</p>

<p>由于交互器是一个 PONSO (Plain Old NSObject，普通的 NSObject)，它主要包含了逻辑，因此很容易使用 TDD 进行开发。</p>

<p>示例应用的主要用例是向用户展示所有的待办事项（比如任何截止于下周末的任务）。此类用例的业务逻辑主要是找出今天至下周末之间将要到期的待办事项，然后为它们分配一个相对的截止日期，比如今天，明天，本周以内，或者下周。</p>

<p>以下是来自 VTDListInteractor 的对应方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)findUpcomingItems 
</span><span class='line'>{ 
</span><span class='line'>    __weak typeof(self) welf = self; 
</span><span class='line'>    NSDate* today = [self.clock today]; 
</span><span class='line'>    NSDate* endOfNextWeek = [[NSCalendar currentCalendar] dateForEndOfFollowingWeekWithDate:today]; 
</span><span class='line'>    [self.dataManager todoItemsBetweenStartDate:today endDate:endOfNextWeek completionBlock:^(NSArray* todoItems) { 
</span><span class='line'>        [welf.output foundUpcomingItems:[welf upcomingItemsFromToDoItems:todoItems]]; 
</span><span class='line'>    }]; 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<h5>实体</h5>

<p>实体是被交互器操作的模型对象，并且它们只被交互器所操作。交互器永远不会传输实体至表现层 (比如说展示器)。</p>

<p>实体也应该是 PONSOs。如果你使用 Core Data，最好是将托管对象保持在你的数据层之后，交互器不应与 NSManageObjects 协同工作。</p>

<p>这里是我们的待办事项服务的实体：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface VTDTodoItem : NSObject 
</span><span class='line'> 
</span><span class='line'>@property (nonatomic, strong)   NSDate*     dueDate; 
</span><span class='line'>@property (nonatomic, copy)     NSString*   name; 
</span><span class='line'> 
</span><span class='line'>+ (instancetype)todoItemWithDueDate:(NSDate*)dueDate name:(NSString*)name; 
</span><span class='line'> 
</span><span class='line'>@end 
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>不要诧异于你的实体仅仅是数据结构，任何依赖于应用的逻辑都应该放到交互器中。</p>

<h5>展示器</h5>

<p>展示器是一个主要包含了驱动用户界面的逻辑的 PONSO，它总是知道何时呈现用户界面。基于其收集来自用户交互的输入功能，它可以在合适的时候更新用户界面并向交互器发送请求。</p>

<p>当用户点击 “+” 键新建待办事项时，addNewEntry 被调用。对于此项操作，展示器会要求 wireframe 显示用户界面以增加新项目：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)addNewEntry 
</span><span class='line'>{ 
</span><span class='line'>    [self.listWireframe presentAddInterface]; 
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>展示器还会从交互器接收结果并将结果转换成能够在视图中有效显示的形式。</p>

<p>下面是如何从交互器接受待办事项的过程，其中包含了处理数据的过程并决定展现给用户哪些内容：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)foundUpcomingItems:(NSArray*)upcomingItems 
</span><span class='line'>{ 
</span><span class='line'>    if ([upcomingItems count] == 0) 
</span><span class='line'>    { 
</span><span class='line'>        [self.userInterface showNoContentMessage]; 
</span><span class='line'>    } 
</span><span class='line'>    else 
</span><span class='line'>    { 
</span><span class='line'>        [self updateUserInterfaceWithUpcomingItems:upcomingItems]; 
</span><span class='line'>    } 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>实体永远不会由交互器传输给展示器，取而代之，那些无行为的简单数据结构会从交互器传输到展示器那里。这就防止了那些“真正的工作”在展示器那里进行，展示器只能负责准备那些在视图里显示的数据。</p>

<h5>视图</h5>

<p>视图一般是被动的，它通常等待展示器下发需要显示的内容，而不会向其索取数据。视图（例如登录界面的登录视图控件）所定义的方法应该允许展示器在高度抽象的层次与之交流。展示器通过内容进行表达，而不关心那些内容所显示的样子。展示器不知道 UILabel，UIButton 等的存在，它只知道其中包含的内容以及何时需要显示。内容如何被显示是由视图来进行控制的。</p>

<p>视图是一个抽象的接口 (Interface)，在 Objective-C 中使用协议被定义。一个 UIViewController 或者它的一个子类会实现视图协议。比如我们的示例中 “添加” 界面会有以下接口：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@protocol VTDAddViewInterface  
</span><span class='line'> 
</span><span class='line'>- (void)setEntryName:(NSString *)name; 
</span><span class='line'>- (void)setEntryDueDate:(NSDate *)date; 
</span><span class='line'> 
</span><span class='line'>@end </span></code></pre></td></tr></table></div></figure>


<p>视图和视图控制器同样会操纵用户界面和相关输入。因为通常来说视图控制器是最容易处理这些输入和执行某些操作的地方，所以也就不难理解为什么视图控制器总是这么大了。为了使视图控制器保持苗条，我们需要使它们在用户进行相关操作的时候可以有途径来通知相关部分。视图控制器不应当根据这些行为进行相关决定，但是它应当将发生的事件传递到能够做决定的部分。</p>

<p>在我们的例子中，Add View Controller 有一个事件处理的属性，它实现了如下接口：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@protocol VTDAddModuleInterface  
</span><span class='line'> 
</span><span class='line'>- (void)cancelAddAction; 
</span><span class='line'>- (void)saveAddActionWithName:(NSString *)name dueDate:(NSDate *)dueDate 
</span><span class='line'> 
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>当用户点击取消键的时候，视图控制器告知这个事件处理程序用户需要其取消这次添加的动作。这样一来，事件处理程序便可以处理关闭 add view controller 并告知列表视图进行更新。</p>

<p>视图和展示器之间边界处是一个使用 <a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a> 的好地方。在这个示例中，视图控制器可以返回一个代表按钮操作的信号。这将允许展示器在不打破职责分离的前提下轻松地对那些信号进行响应。</p>

<h5>路由</h5>

<p>屏幕间的路径会在交互设计师创建的线框 (wireframes) 里进行定义。在 VIPER 中，路由是由两个部分来负责的：展示器和线框。一个线框对象包括 UIWindow，UINavigationController，UIViewController 等部分，它负责创建视图/视图控制器并将其装配到窗口中。</p>

<p>由于展示器包含了响应用户输入的逻辑，因此它就拥有知晓何时导航至另一个屏幕以及具体是哪一个屏幕的能力。而同时，线框知道如何进行导航。在两者结合起来的情况下，展示器可以使用线框来进行实现导航功能，它们两者一起描述了从一个屏幕至另一个屏幕的路由过程。</p>

<p>线框同时也明显是一个处理导航转场动画的地方。来看看这个 add wireframe 中的例子吧：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@implementation VTDAddWireframe 
</span><span class='line'> 
</span><span class='line'>- (void)presentAddInterfaceFromViewController:(UIViewController *)viewController  
</span><span class='line'>{ 
</span><span class='line'>    VTDAddViewController *addViewController = [self addViewController]; 
</span><span class='line'>    addViewController.eventHandler = self.addPresenter; 
</span><span class='line'>    addViewController.modalPresentationStyle = UIModalPresentationCustom; 
</span><span class='line'>    addViewController.transitioningDelegate = self; 
</span><span class='line'> 
</span><span class='line'>    [viewController presentViewController:addViewController animated:YES completion:nil]; 
</span><span class='line'> 
</span><span class='line'>    self.presentedViewController = viewController; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>#pragma mark - UIViewControllerTransitioningDelegate Methods 
</span><span class='line'> 
</span><span class='line'>- (id)animationControllerForDismissedController:(UIViewController *)dismissed  
</span><span class='line'>{ 
</span><span class='line'>    return [[VTDAddDismissalTransition alloc] init]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (id)animationControllerForPresentedController:(UIViewController *)presented 
</span><span class='line'>                                                                  presentingController:(UIViewController *)presenting 
</span><span class='line'>                                                                      sourceController:(UIViewController *)source  
</span><span class='line'>{ 
</span><span class='line'>    return [[VTDAddPresentationTransition alloc] init]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>@end 
</span></code></pre></td></tr></table></div></figure>


<p>应用使用了自定义的视图控制器转场来呈现 add view controller。因为线框部件负责实施这个转场，所以它成为了 add view controller 转场的委托，并且返回适当的转场动画。</p>

<h5>利用 VIPER 组织应用组件</h5>

<p>iOS 应用的构架需要考虑到 UIKit 和 Cocoa Touch 是建立应用的主要工具。架构需要和应用的所有组件都能够和平相处，但又需要为如何使用框架的某些部分以及它们应该在什么位置提供一些指导和建议。</p>

<p>iOS 应用程序的主力是 UIViewController，我们不难想象找一个竞争者来取代 MVC 就可以避免大量使用视图控制器。但是视图控制器现在是这个平台的核心：它们处理设备方向的变化，回应用户的输入，和类似导航控制器之类的系统系统组件集成得很好，而现在在 iOS 7 中又能实现自定义屏幕之间的转换，功能实在是太强大了。</p>

<p>有了 VIPER，视图控制器便就能真正的做它本来应该做的事情了，那就是控制视图。 我们的待办事项应拥有两个视图控制器，一个是列表视图，另一个是新建待办。因为 add view controller 要做的所有事情就是控制视图，所以实现起来非常的简单基础：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@implementation VTDAddViewController 
</span><span class='line'> 
</span><span class='line'>- (void)viewDidAppear:(BOOL)animated  
</span><span class='line'>{ 
</span><span class='line'>    [super viewDidAppear:animated]; 
</span><span class='line'> 
</span><span class='line'>    UITapGestureRecognizer *gestureRecognizer = [[UITapGestureRecognizer alloc] initWithTarget:self 
</span><span class='line'>                                                                                        action:@selector(dismiss)]; 
</span><span class='line'>    [self.transitioningBackgroundView addGestureRecognizer:gestureRecognizer]; 
</span><span class='line'>    self.transitioningBackgroundView.userInteractionEnabled = YES; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (void)dismiss  
</span><span class='line'>{ 
</span><span class='line'>    [self.eventHandler cancelAddAction]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (void)setEntryName:(NSString *)name  
</span><span class='line'>{ 
</span><span class='line'>    self.nameTextField.text = name; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (void)setEntryDueDate:(NSDate *)date  
</span><span class='line'>{ 
</span><span class='line'>    [self.datePicker setDate:date]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (IBAction)save:(id)sender  
</span><span class='line'>{ 
</span><span class='line'>    [self.eventHandler saveAddActionWithName:self.nameTextField.text 
</span><span class='line'>                                     dueDate:self.datePicker.date]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (IBAction)cancel:(id)sender  
</span><span class='line'>{ 
</span><span class='line'>    [self.eventHandler cancelAddAction]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'> 
</span><span class='line'>#pragma mark - UITextFieldDelegate Methods 
</span><span class='line'> 
</span><span class='line'>- (BOOL)textFieldShouldReturn:(UITextField *)textField  
</span><span class='line'>{ 
</span><span class='line'>    [textField resignFirstResponder]; 
</span><span class='line'> 
</span><span class='line'>    return YES; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>@end </span></code></pre></td></tr></table></div></figure>


<p>应用在接入网络以后会变得更有用处，但是究竟该在什么时候联网呢？又由谁来负责启动网络连接呢？典型的情况下，由交互器来启动网络连接操作的项目，但是它不会直接处理网络代码。它会寻找一个像是 network manager 或者 API client 这样的依赖项。交互器可能聚合来自多个源的数据来提供所需的信息，从而完成一个用例。最终，就由展示器来采集交互器反馈的数据，然后组织并进行展示。</p>

<p>数据存储模块负责提供实体给交互器。因为交互器要完成业务逻辑，因此它需要从数据存储中获取实体并操纵它们，然后将更新后的实体再放回数据存储中。数据存储管理实体的持久化，而实体应该对数据库全然不知，正因如此，实体并不知道如何对自己进行持久化。</p>

<p>交互器同样不需要知道如何将实体持久化，有时交互器更希望使用一个 data manager 来使其与数据存储的交互变得容易。Data manager 可以处理更多的针对存储的操作，比如创建获取请求，构建查询等等。这就使交互器能够将更多的注意力放在应用逻辑上，而不必再了解实体是如何被聚集或持久化的。下面我们举一个例子来说明使用 data manager 有意义的，这个例子假设你在使用 Core Data。这是示例应用程序的 data manager 的接口：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface VTDListDataManager : NSObject 
</span><span class='line'> 
</span><span class='line'>@property (nonatomic, strong) VTDCoreDataStore *dataStore; 
</span><span class='line'> 
</span><span class='line'>- (void)todoItemsBetweenStartDate:(NSDate *)startDate endDate:(NSDate *)endDate completionBlock:(void (^)(NSArray *todoItems))completionBlock; 
</span><span class='line'> 
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>当使用 TDD 来开发一个交互器时，是可以用一个测试用的模拟存储来代替生产环境的数据存储的。避免与远程服务器通讯（网络服务）以及避免读取磁盘（数据库）可以加快你测试的速度并加强其可重复性。</p>

<p>将数据存储保持为一个界限清晰的特定层的原因之一是，这可以让你延迟选择一个特定的持久化技术。如果你的数据存储是一个独立的类，那你就可以使用一个基础的持久化策略来开始你的应用，然后等到有意义的时候升级至 SQLite 或者 Core Data。而因为数据存储层的存在，你的应用代码库中就不需要改变任何东西。</p>

<p>在 iOS 的项目中使用 Core Data 经常比构架本身还容易引起更多争议。然而，利用 VIPER 来使用 Core Data 将给你带来使用 Core Data 的前所未有的良好体验。在持久化数据的工具层面上，Core Data 可以保持快速存取和低内存占用方面，简直是个神器。但是有个很恼人的地方，它会像触须一样把 NSManagedObjectContext 延伸至你所有的应用实现文件中，特别是那些它们不该待的地方。VIPER 可以使 Core Data 待在正确的地方：数据存储层。</p>

<p>在待办事项示例中，应用仅有的两部分知道使用了 Core Data，其一是数据存储本身，它负责建立 Core Data 堆栈；另一个是 data manager。Data manager 执行了获取请求，将数据存储返回的 NSManagedObject 对象转换为标准的 PONSO 模型对象，并传输回业务逻辑层。这样一来，应用程序核心将不再依赖于 Core Data，附加得到的好处是，你也再也不用担心过期数据 (stale) 和没有良好组织的多线程 NSManagedObjects 来糟蹋你的工作成果了。</p>

<p>在通过请求访问 Core Data 存储时，data manager 中看起来是这样的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@implementation VTDListDataManager 
</span><span class='line'> 
</span><span class='line'>- (void)todoItemsBetweenStartDate:(NSDate *)startDate endDate:(NSDate*)endDate completionBlock:(void (^)(NSArray *todoItems))completionBlock 
</span><span class='line'>{ 
</span><span class='line'>    NSCalendar *calendar = [NSCalendar autoupdatingCurrentCalendar]; 
</span><span class='line'> 
</span><span class='line'>    NSPredicate *predicate = [NSPredicate predicateWithFormat:@"(date &gt;= %@) AND (date &lt;= %@)", [calendar dateForBeginningOfDay:startDate], [calendar dateForEndOfDay:endDate]]; 
</span><span class='line'>    NSArray *sortDescriptors = @[]; 
</span><span class='line'> 
</span><span class='line'>    __weak typeof(self) welf = self; 
</span><span class='line'>    [self.dataStore 
</span><span class='line'>     fetchEntriesWithPredicate:predicate 
</span><span class='line'>     sortDescriptors:sortDescriptors 
</span><span class='line'>     completionBlock:^(NSArray* entries) { 
</span><span class='line'>         if (completionBlock) 
</span><span class='line'>         { 
</span><span class='line'>             completionBlock([welf todoItemsFromDataStoreEntries:entries]); 
</span><span class='line'>         } 
</span><span class='line'>     }]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (NSArray*)todoItemsFromDataStoreEntries:(NSArray *)entries 
</span><span class='line'>{ 
</span><span class='line'>    return [entries arrayFromObjectsCollectedWithBlock:^id(VTDManagedTodoItem *todo) { 
</span><span class='line'>        return [VTDTodoItem todoItemWithDueDate:todo.date name:todo.name]; 
</span><span class='line'>    }]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>@end </span></code></pre></td></tr></table></div></figure>


<p>与 Core Data 一样极富争议的恐怕就是 UI 故事板了。故事板具有很多有用的功能，如果完全忽视它将会是一个错误。然而，调用故事版所能提供的所有功能来完成 VIPER 的所有目标仍然是很困难的。</p>

<p>我们所能做出的妥协就是选择不使用 segues 。有时候使用 segues 是有效的，但是使用 segues 的危险性在于它们很难原封不动地保持屏幕之间的分离，以及 UI 和应用逻辑之间的分离。一般来说，如果实现 prepareForSegue 方法是必须的话，我们就尽量不去使用 segues。</p>

<p>除此之外，故事板是一个实现用户界面布局有效方法，特别是在使用自动布局的时候。我们选择在实现待办事项两个界面的实例中使用故事板，并且使用这样的代码来执行自己的导航操作。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static NSString *ListViewControllerIdentifier = @"VTDListViewController"; 
</span><span class='line'> 
</span><span class='line'>@implementation VTDListWireframe 
</span><span class='line'> 
</span><span class='line'>- (void)presentListInterfaceFromWindow:(UIWindow *)window  
</span><span class='line'>{ 
</span><span class='line'>    VTDListViewController *listViewController = [self listViewControllerFromStoryboard]; 
</span><span class='line'>    listViewController.eventHandler = self.listPresenter; 
</span><span class='line'>    self.listPresenter.userInterface = listViewController; 
</span><span class='line'>    self.listViewController = listViewController; 
</span><span class='line'> 
</span><span class='line'>    [self.rootWireframe showRootViewController:listViewController 
</span><span class='line'>                                      inWindow:window]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (VTDListViewController *)listViewControllerFromStoryboard  
</span><span class='line'>{ 
</span><span class='line'>    UIStoryboard *storyboard = [self mainStoryboard]; 
</span><span class='line'>    VTDListViewController *viewController = [storyboard instantiateViewControllerWithIdentifier:ListViewControllerIdentifier]; 
</span><span class='line'>    return viewController; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (UIStoryboard *)mainStoryboard  
</span><span class='line'>{ 
</span><span class='line'>    UIStoryboard *storyboard = [UIStoryboard storyboardWithName:@"Main" 
</span><span class='line'>                                                         bundle:[NSBundle mainBundle]]; 
</span><span class='line'>    return storyboard; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>@end </span></code></pre></td></tr></table></div></figure>


<h5>使用 VIPER 构建模块</h5>

<p>一般在使用 VIPER 的时候，你会发现一个屏幕或一组屏幕倾向于聚在一起作为一个模块。模块可以以多种形式体现，但一般最好把它想成是一种特性。在播客应用中，一个模块可能是音频播放器或订阅浏览器。然而在我们的待办事项应用中，列表和添加事项的屏幕都将作为单独的模块被建立。</p>

<p>将你的应用作为一组模块来设计有很多好处，其中之一就是模块可以有非常明确和定义良好的接口，并且独立于其他的模块。这就使增加或者移除特性变得更加简单，也使在界面中向用户展示各种可变模块变得更加简单。</p>

<p>我们希望能将待办事项中各模块之间分隔更加明确，我们为添加模块定义了两个协议。一个是模块接口，它定义了模块可以做什么；另一个则是模块的代理，用来描述该模块做了什么。例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@protocol VTDAddModuleInterface  
</span><span class='line'> 
</span><span class='line'>- (void)cancelAddAction; 
</span><span class='line'>- (void)saveAddActionWithName:(NSString *)name dueDate:(NSDate *)dueDate; 
</span><span class='line'> 
</span><span class='line'>@end 
</span><span class='line'> 
</span><span class='line'> 
</span><span class='line'>@protocol VTDAddModuleDelegate  
</span><span class='line'> 
</span><span class='line'>- (void)addModuleDidCancelAddAction; 
</span><span class='line'>- (void)addModuleDidSaveAddAction; 
</span><span class='line'> 
</span><span class='line'>@end </span></code></pre></td></tr></table></div></figure>


<p>因为模块必须要被展示，才能对用户产生价值，所以模块的展示器通常需要实现模型的接口。当另一个模型想要展现当前模块时，它的展示器就需要实现模型的委托协议，这样它就能在展示时知道当前模块做了些什么。</p>

<p>一个模块可能包括实体，交互器和管理器的通用应用逻辑层，这些通常可用于多个屏幕。当然，这取决于这些屏幕之间的交互及它们的相似度。一个模块可以像在待办事项列表里面一样，简单的只代表一个屏幕。这样一来，应用逻辑层对于它的特定模块的行为来说就非常特有了。</p>

<p>模块同样是组织代码的简便途径。将模块所有的编码都放在它自己的文件夹中并在 Xcode 中建一个 group，这会在你需要寻找和改变更加容易。当你在要寻找一个类时，它恰到好处地就在你所期待的地方，这种感觉真是无法形容的棒。</p>

<p>利用 VIPER 建立模块的另一个好处是它使得扩展到多平台时变得更加简单。独立在交互器层中的所有用例的应用逻辑允许你可以专注于为平板，电话或者 Mac 构建新的用户界面，同时可以重用你的应用层。</p>

<p>进一步来说，iPad 应用的用户界面能够将部分 iPhone 应用的视图，视图控制器及展示器进行再利用。在这种情况下，iPad 屏幕将由 ‘super’ 展示器和线框来代表，这样可以利用 iPhone 使用过的展示器和线框来组成屏幕。建立进而维护一个跨多平台的应用是一个巨大的挑战，但是好的构架可以对整个模型和应用层的再利用有大幅度的提升，并使其实现起来更加容易。</p>

<h5>利用 VIPER 进行测试</h5>

<p>VIPER 的出现激发了一个关注点的分离，这使得采用 TDD 变得更加简便。交互器包含独立与任何 UI 的纯粹逻辑，这使测试驱动开发更加简单。同时展示器包含用来为显示准备数据的逻辑，并且它也独立于任何一个 UIKit 部件。对于这个逻辑的开发也很容易用测试来驱动。</p>

<p>我们更倾向于先从交互器下手。用户界面里所有部分都服务于用例，而通过采用 TDD 来测试驱动交互器的 API 可以让你对用户界面和用例之间的关系有一个更好的了解。</p>

<p>作为实例，我们来看一下负责待办事项列表的交互器。寻找待办事项的策略是要找出所有的将在下周末前截止的项目，并将这些项目分别归类至截止于今天，明天，本周或者下周。</p>

<p>我们编写的第一个测试是为了保证交互器能够找到所有的截止于下周末的待办事项：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)testFindingUpcomingItemsRequestsAllToDoItemsFromTodayThroughEndOfNextWeek 
</span><span class='line'>{ 
</span><span class='line'>    [[self.dataManager expect] todoItemsBetweenStartDate:self.today endDate:self.endOfNextWeek completionBlock:OCMOCK_ANY]; 
</span><span class='line'>    [self.interactor findUpcomingItems]; 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>一旦知道了交互器找到了正确的待办事项后，我们就需要编写几个小测试用来确认它确实将待办事项分配到了正确的相对日期组内（比如说今天，明天，等等）。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)testFindingUpcomingItemsWithOneItemDueTodayReturnsOneUpcomingItemsForToday 
</span><span class='line'>{ 
</span><span class='line'>    NSArray *todoItems = @[[VTDTodoItem todoItemWithDueDate:self.today name:@"Item 1"]]; 
</span><span class='line'>    [self dataStoreWillReturnToDoItems:todoItems]; 
</span><span class='line'> 
</span><span class='line'>    NSArray *upcomingItems = @[[VTDUpcomingItem upcomingItemWithDateRelation:VTDNearTermDateRelationToday dueDate:self.today title:@"Item 1"]]; 
</span><span class='line'>    [self expectUpcomingItems:upcomingItems]; 
</span><span class='line'> 
</span><span class='line'>    [self.interactor findUpcomingItems]; 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>既然我们已经知道了交互器的 API 长什么样，接下来就是开发展示器。一旦展示器接收到了交互器传来的待办事项，我们就需要测试看看我们是否适当的将数据进行格式化并且在用户界面中正确的显示它。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)testFoundZeroUpcomingItemsDisplaysNoContentMessage 
</span><span class='line'>{ 
</span><span class='line'>    [[self.ui expect] showNoContentMessage]; 
</span><span class='line'> 
</span><span class='line'>    [self.presenter foundUpcomingItems:@[]]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (void)testFoundUpcomingItemForTodayDisplaysUpcomingDataWithNoDay 
</span><span class='line'>{ 
</span><span class='line'>    VTDUpcomingDisplayData *displayData = [self displayDataWithSectionName:@"Today" 
</span><span class='line'>                                                          sectionImageName:@"check" 
</span><span class='line'>                                                                 itemTitle:@"Get a haircut" 
</span><span class='line'>                                                                itemDueDay:@""]; 
</span><span class='line'>    [[self.ui expect] showUpcomingDisplayData:displayData]; 
</span><span class='line'> 
</span><span class='line'>    NSCalendar *calendar = [NSCalendar gregorianCalendar]; 
</span><span class='line'>    NSDate *dueDate = [calendar dateWithYear:2014 month:5 day:29]; 
</span><span class='line'>    VTDUpcomingItem *haircut = [VTDUpcomingItem upcomingItemWithDateRelation:VTDNearTermDateRelationToday dueDate:dueDate title:@"Get a haircut"]; 
</span><span class='line'> 
</span><span class='line'>    [self.presenter foundUpcomingItems:@[haircut]]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (void)testFoundUpcomingItemForTomorrowDisplaysUpcomingDataWithDay 
</span><span class='line'>{ 
</span><span class='line'>    VTDUpcomingDisplayData *displayData = [self displayDataWithSectionName:@"Tomorrow" 
</span><span class='line'>                                                          sectionImageName:@"alarm" 
</span><span class='line'>                                                                 itemTitle:@"Buy groceries" 
</span><span class='line'>                                                                itemDueDay:@"Thursday"]; 
</span><span class='line'>    [[self.ui expect] showUpcomingDisplayData:displayData]; 
</span><span class='line'> 
</span><span class='line'>    NSCalendar *calendar = [NSCalendar gregorianCalendar]; 
</span><span class='line'>    NSDate *dueDate = [calendar dateWithYear:2014 month:5 day:29]; 
</span><span class='line'>    VTDUpcomingItem *groceries = [VTDUpcomingItem upcomingItemWithDateRelation:VTDNearTermDateRelationTomorrow dueDate:dueDate title:@"Buy groceries"]; 
</span><span class='line'> 
</span><span class='line'>    [self.presenter foundUpcomingItems:@[groceries]]; 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>同样需要测试的是应用是否在用户想要新建待办事项时正确启动了相应操作：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)testAddNewToDoItemActionPresentsAddToDoUI 
</span><span class='line'>{ 
</span><span class='line'>    [[self.wireframe expect] presentAddInterface]; 
</span><span class='line'> 
</span><span class='line'>    [self.presenter addNewEntry]; 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>这时我们可以开发视图功能了，并且在没有待办事项的时候我们想要展示一个特殊的信息。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)testShowingNoContentMessageShowsNoContentView 
</span><span class='line'>{ 
</span><span class='line'>    [self.view showNoContentMessage]; 
</span><span class='line'> 
</span><span class='line'>    XCTAssertEqualObjects(self.view.view, self.view.noContentView, @"the no content view should be the view"); 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>有待办事项出现时，我们要确保列表是显示出来的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)testShowingUpcomingItemsShowsTableView 
</span><span class='line'>{ 
</span><span class='line'>    [self.view showUpcomingDisplayData:nil]; 
</span><span class='line'> 
</span><span class='line'>    XCTAssertEqualObjects(self.view.view, self.view.tableView, @"the table view should be the view"); 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>首先建立交互器是一种符合 TDD 的自然规律。如果你首先开发交互器，紧接着是展示器，你就可以首先建立一个位于这些层的套件测试，并且为实现这是实例奠定基础。由于你不需要为了测试它们而去与用户界面进行交互，所以这些类可以进行快速迭代。在你需要开发视图的时候，你会有一个可以工作并测试过的逻辑和表现层来与其进行连接。在快要完成对视图的开发时，你会发现第一次运行程序时所有部件都运行良好，因为你所有已通过的测试已经告诉你它可以工作。</p>

<h5>结论</h5>

<p>我们希望你喜欢这篇对 VIPER 的介绍。或许你们都很好奇接下来应该做什么，如果你希望通过 VIPER 来对你下一个应用进行设计，该从哪里开始呢？</p>

<p>我们竭尽全力使这篇文章和我们利用 VIPER 实现的应用实例足够明确并且进行了很好的定义。我们的待办事项里列表程序相当直接简单，但是它准确地解释了如何利用 VIPER 来建立一个应用。在实际的项目中，你可以根据你自己的挑战和约束条件来决定要如何实践这个例子。根据以往的经验，我们的每个项目在使用 VIPER 时都或多或少地改变了一些策略，但它们无一例外的都从中得益，找到了正确的方向。</p>

<p>很多情况下由于某些原因，你可能会想要偏离 VIPER 所指引的道路。可能你遇到了很多 &lsquo;bunny&rsquo; 对象，或者你的应用使用了故事板的 segues。没关系的，在这些情况下，你只需要在做决定时稍微考虑下 VIPER 所代表的精神就好。VIPER 的核心在于它是建立在单一责任原则上的架构。如果你碰到了些许麻烦，想想这些原则再考虑如何前进。</p>

<p>你一定想知道在现有的应用中能否只用 VIPER 。在这种情况下，你可以考虑使用 VIPER 构建新的特性。我们许多现有项目都使用了这个方法。你可以利用 VIPER 建立一个模块，这能帮助你发现许多建立在单一责任原则基础上造成难以运用架构的现有问题。</p>

<p>软件开发最伟大的事情之一就是每个应用程序都是不同的，而设计每个应用的架构的方式也是不同的。这就意味着每个应用对于我们来说都是一个学习和尝试的机遇，如果你决定开始使用 VIPER，你会受益匪浅。感谢你的阅读。</p>

<h5>Swift 补充</h5>

<p>苹果上周在 WWDC 介绍了一门称之为 Swift 的编程语言来作为 Cocoa 和 Cocoa Touch 开发的未来。现在发表关于 Swift 的完整意见还为时尚早，但众所周知编程语言对我们如何设计和构建应用有着重大影响。我们决定使用 Swift 重写我们的待办事项清单，帮助我们学习它对 VIPER 意味着什么。至今为止，收获颇丰。Swift 中的一些特性对于构建应用的体验有着显著的提升。</p>

<h5>结构体</h5>

<p>在 VIPER 中我们使用小型，轻量级的 model 类来在比如从展示器到视图这样不同的层间传递数据。这些 PONSOs 通常是只是简单地带有少量数据，并且通常这些类不会被继承。Swift 的结构体非常适合这个情况。下面的结构体的例子来自 VIPER Swift。这个结构体需要被判断是否相等，所以我们重载了 == 操作符来比较这个类型的两个实例。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct UpcomingDisplayItem : Equatable, Printable { 
</span><span class='line'>    let title : String = "" 
</span><span class='line'>    let dueDate : String = "" 
</span><span class='line'> 
</span><span class='line'>    var description : String { get { 
</span><span class='line'>        return "\(title) -- \(dueDate)" 
</span><span class='line'>    }} 
</span><span class='line'> 
</span><span class='line'>    init(title: String, dueDate: String) { 
</span><span class='line'>        self.title = title 
</span><span class='line'>        self.dueDate = dueDate 
</span><span class='line'>    } 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>func == (leftSide: UpcomingDisplayItem, rightSide: UpcomingDisplayItem) -&gt; Bool { 
</span><span class='line'>    var hasEqualSections = false 
</span><span class='line'>    hasEqualSections = rightSide.title == leftSide.title 
</span><span class='line'> 
</span><span class='line'>    if hasEqualSections == false { 
</span><span class='line'>        return false 
</span><span class='line'>    } 
</span><span class='line'> 
</span><span class='line'>    hasEqualSections = rightSide.dueDate == rightSide.dueDate 
</span><span class='line'> 
</span><span class='line'>    return hasEqualSections 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p></p>

<h5>类型安全</h5>

<p>也许 Objective-C 和 Swift 的最大区别是它们在对于类型处理上的不同。 Objective-C 是动态类型，而 Swift 故意在编译时做了严格的类型检查。对于一个类似 VIPER 的架构， 应用由不同层构成，类型安全是提升程序员效率和设计架构有非常大的好处。编译器帮助你确保正确类型的容器和对象在层的边界传递。如上所示，这是一个使用结构体的好地方。如果一个结构体的被设计为存在于两层之间，那么由于类型安全，你可以保证它将永远无法脱离这些层之间。</p>

<h5>扩展阅读</h5>

<p><a href="https://github.com/objcio/issue-13-viper">VIPER TODO, 文章示例</a></p>

<p><a href="https://github.com/objcio/issue-13-viper-swift">VIPER SWIFT, 基于 Swift 的文章示例</a></p>

<p><a href="https://github.com/mutualmobile/Counter">另一个计数器应用</a></p>

<p><a href="http://mutualmobile.github.io/blog/2013/12/04/viper-introduction/">Mutual Mobile 关于 VIPER 的介绍</a></p>

<p><a href="http://blog.8thlight.com/uncle-bob/2011/11/22/Clean-Architecture.html">简明架构</a></p>

<p><a href="http://objccn.io/issue-1-1/">更轻量的 View Controllers</a></p>

<p><a href="http://objccn.io/issue-1-3/">测试 View Controllers</a></p>

<p><a href="http://inessential.com/2014/03/16/smaller_please">Bunnies</a></p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[优秀开源项目：FACEBOOK PAPER动画引擎 – POP]]></title>
        <link href="http://swplzj.github.io/blog/2014/11/14/you-xiu-kai-yuan-xiang-mu-facebook-paper-dong-hua-yin-qing-pop/"/>
        <updated>2014-11-14T19:02:27+08:00</updated>
        <id>http://swplzj.github.io/blog/2014/11/14/you-xiu-kai-yuan-xiang-mu-facebook-paper-dong-hua-yin-qing-pop</id>
        <content type="html"><![CDATA[<p><img src="http://cc.cocimg.com/cms/uploads/allimg/140429/4196_140429142234_1.gif" alt="id1" /></p>

<p>Pop是一个适用于iOS和OS X平台的可扩展动画引擎，是一个成熟的经过多重测试的，可实现Facebook Paper中的所有动画和过渡效果。除了基本的静态动画，Pop还支持spring和decay动画，有助于打造一个逼真的，基于物理的交互。你可以通过Pop的API把Pop快速集成到现有的Objective-C代码库中，并在任何对象上实现动画的任何属性。</p>

<!--more-->


<p></p>

<h5>开始，停止以及更新</h5>

<p>开始动画–把它添加到你想要动画的对象上：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>POPSpringAnimation *anim = [POPSpringAnimation animation]; 
</span><span class='line'>… 
</span><span class='line'>[layer pop_addAnimation:anim forKey:@"myKey"]; </span></code></pre></td></tr></table></div></figure>


<p>停止动画–把它从key在刚开始时指定的对象引用中移除。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[layer pop_removeAnimationForKey:@"myKey"]; 
</span><span class='line'>key可以用来查询现有的动画。更新运行中动画的toValue，为改变进程提供了很好的方式：
</span><span class='line'>anim = [layer pop_animationForKey:@"myKey"]; 
</span><span class='line'>if (anim) { 
</span><span class='line'>  /* update to value to new destination */ 
</span><span class='line'>  anim.toValue = @(42.0); 
</span><span class='line'>} else { 
</span><span class='line'>  /* create and start a new animation */ 
</span><span class='line'>  …. 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>虽然上述代码中使用了layer，但是Pop接口作为一个NSObject上附加类别执行。任何NSObject或者子类可以被动画。</p>

<h5>类型</h5>

<p>Pop有四个具体的动画类型：spring, decay, basic和custom
Spring动画可以用来给对象一个令人愉悦的弹跳效果。在这个例子中，我们用spring动画来动画一个层次的弹跳效果，从现有的值设定为(0, 0, 400, 400)。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>POPSpringAnimation *anim = [POPSpringAnimation animationWithPropertyNamed:kPOPLayerBounds]; 
</span><span class='line'>anim.toValue = [NSValue valueWithCGRec 
</span><span class='line'>t:CGRectMake(0, 0, 400, 400)]; 
</span><span class='line'>[layer pop_addAnimation:anim forKey:@"size"]; </span></code></pre></td></tr></table></div></figure>


<p>Decay动画能用于逐渐减慢一个对象直至停止。在这个例子中，我们将layer的速率减小为每秒钟1000pts。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>POPDecayAnimation *anim = [POPDecayAnimation animationWithPropertyNamed:kPOPLayerPositionX]; 
</span><span class='line'>anim.velocity = @(1000.); 
</span><span class='line'>[layer pop_addAnimation:anim forKey:@"slide"]; </span></code></pre></td></tr></table></div></figure>


<p>基本动画能用于在指定的时间段插入值。使用一个淡入淡出动画在默认时间段将视图的透明度从0.0设置为1.0。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>POPBasicAnimation *anim = [POPBasicAnimation animationWithPropertyNamed:kPOPViewAlpha]; 
</span><span class='line'>anim.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]; 
</span><span class='line'>anim.fromValue = @(0.0); 
</span><span class='line'>anim.toValue = @(1.0); 
</span><span class='line'>[view pop_addAnimation:anim forKey:@"slide"]; </span></code></pre></td></tr></table></div></figure>


<p>通过处理CADisplayLink和相关的time-step管理，POPCustomAnimation使创建自定义动画和过渡变得更加容易。更多详情请查看header。</p>

<h5>属性</h5>

<p>属性由POPAnimatableProperty类指定动画。在这个例子中，我们创建一个spring动画，明确地设置与-[CALayer bounds]一致的动画属性：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>POPSpringAnimation *anim = [POPSpringAnimation animation]; 
</span><span class='line'>anim.property = [POPAnimatableProperty propertyWithName:kPOPLayerBounds]; </span></code></pre></td></tr></table></div></figure>


<p>这个框架提供了很多常见的层以及额外的视图动画属性。你可以通过创建类的新实例来动画一个自定义属性。在这个例子中，我声明了一个自定义音量属性：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>prop = [POPAnimatableProperty propertyWithName:@"com.foo.radio.vo 
</span><span class='line'>lume" initializer:^(POPMutableAnimatableProperty *prop) { 
</span><span class='line'>  // read value 
</span><span class='line'>  prop.readBlock = ^(id obj, CGFloat values[]) { 
</span><span class='line'>    values[0] = [obj volume]; 
</span><span class='line'>  }; 
</span><span class='line'>  // write value 
</span><span class='line'>  prop.writeBlock = ^(id obj, const CGFloat values[]) { 
</span><span class='line'>    [obj setVolume:values[0]]; 
</span><span class='line'>  }; 
</span><span class='line'>  // dynamics threshold 
</span><span class='line'>  prop.threshold = 0.01; 
</span><span class='line'>}]; 
</span><span class='line'>anim.property = prop; </span></code></pre></td></tr></table></div></figure>


<p>关于动画属性的完整列表以及声明自定义属性的更多信息，请看POPAnimatableProperty.h。</p>

<h5>调试</h5>

<p>这里有一些关于调试的技巧。Pop遵循模拟器的Toggle Slow Animations设置。试着用它放慢动画，将能更容易查看交互。
考虑给你的动画命名。当你通过日志查看动画或者调试动画时，这将使你更容易识别它们。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>anim.name = @“springOpen”; </span></code></pre></td></tr></table></div></figure>


<p>每个动画都有一个关联的tracer，它以一种快速高效的方式允许你记录所有的动画相关事件，还允许你在动画完成后对其进行查询和分析。下边的例子展示启动和配置tracer，以记录所有动画事件。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>POPAnimationTracer *tracer = anim.tracer; 
</span><span class='line'>tracer.shouldLogAndResetOnCompletion = YES; 
</span><span class='line'>[tracer start]; </span></code></pre></td></tr></table></div></figure>


<p>更多详情，请查看POPAnimationTracer.h。
假设已经安装了CocoaPods，这将在单元测试目标中包含必要的OCMock依赖。</p>

<h5>相关资源</h5>

<p><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html">Core Animation Programming Guide</a>
<a href="http://tapity.com/tutorial-getting-started-with-pop/">Tapity Tutorial – Getting Started with Pop</a>
<a href="https://github.com/facebook/tweaks">Tweaks – Easily adjust parameters for iOS apps in development</a>
<a href="http://facebook.github.io/rebound/">Rebound – Springs Animations for Android</a></p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[理解 OBJECTIVE-C RUNTIME]]></title>
        <link href="http://swplzj.github.io/blog/2014/11/11/li-jie-objective-c-runtime/"/>
        <updated>2014-11-11T21:34:12+08:00</updated>
        <id>http://swplzj.github.io/blog/2014/11/11/li-jie-objective-c-runtime</id>
        <content type="html"><![CDATA[<p>当人们初学 Cocoa/Objective-C 时，Objective-C Runtime 是被忽略的特性之一。原因是 Objective-C（这门语言）很容易在几小时内就熟悉，新学 Cocoa 的人花费他们大部分的时间学习 Cocoa 框架和适应它是如何工作的。然而每个人至少应该知道一些 runtime 的工作细节，需要比知道编译器会把 [target doMethodWith:var1]; 转换为 objc_msgSend(target,@selector(doMethodWith:),var1); 更深入一些。知道 Objective-C 正在做的会让你更深入的理解 Objective-C 和你正在运行的 app。我认为 Mac/iPhone 的开发者不管你现在是什么水平，都会有收获的。</p>

<!--more-->


<h4>Objective-C Runtime 是开源的</h4>

<p>Objective-C 是开源的，任何时候你都能从 <a href="http://opensource.apple.com.">http://opensource.apple.com.</a> 获取。事实上查看 Objective-C 源码是我理解它是如何工作的第一种方式，在这个问题上要比读苹果的文档要好。你可以下载适合 Mac OS X 10.6.2 的 objc4-437.1.tar.gz。（译注：最新objc4-551.1.tar.gz）</p>

<h4>动态 vs 静态语言</h4>

<p>Objective-C 是面相运行时的语言（runtime oriented language），就是说它会尽可能的把编译和链接时要执行的逻辑延迟到运行时。这就给了你很大的灵活性，你可以按需要把消息重定向给合适的对象，你甚至可以交换方法的实现，等等（译注：在 Objective-C 中调用一个对象的方法可以看成向一个对象发送消息, Method Swizzling 具体实现可以参看 jrswizzle ）。这就需要使用 runtime，runtime 可以做对象自省查看他们正在做的和不能做的（don’t respond to）并且合适的分发消息（译注：感兴趣的同学可以查看 NSObject 类的 – forwardingTargetForSelector: 和 – forwardInvocation: 方法。P.S. 不是 NSObject 协议！ ）。如果我们和 C 这样的语言对比。在 C 里，你从 main() 方法开始写然后就是从上到下的写逻辑了并按你写代码的顺序执行程序。一个 C 的结构体不能转发函数执行请求到其他的目标上（other targets）。很可能你的程序是这样的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt; stdio.h &gt;
</span><span class='line'>int main(int argc, const char **argv[])
</span><span class='line'>{        
</span><span class='line'>    printf("Hello World!");
</span><span class='line'>    return 0;
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>编译器解析，优化然后把优化后的代码转成汇编：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.text
</span><span class='line'> .align 4,0x90
</span><span class='line'> .globl _main
</span><span class='line'>_main:
</span><span class='line'>Leh_func_begin1:
</span><span class='line'> pushq %rbp
</span><span class='line'>Llabel1:
</span><span class='line'> movq %rsp, %rbp
</span><span class='line'>Llabel2:
</span><span class='line'> subq $16, %rsp
</span><span class='line'>Llabel3:
</span><span class='line'> movq %rsi, %rax
</span><span class='line'> movl %edi, %ecx 
</span><span class='line'> movl %ecx, -8(%rbp)
</span><span class='line'> movq %rax, -16(%rbp) 
</span><span class='line'> xorb %al, %al 
</span><span class='line'> leaq LC(%rip), %rcx 
</span><span class='line'> movq %rcx, %rdi 
</span><span class='line'> call _printf 
</span><span class='line'> movl $0, -4(%rbp) 
</span><span class='line'> movl -4(%rbp), %eax 
</span><span class='line'> addq $16, %rsp 
</span><span class='line'> popq %rbp 
</span><span class='line'> ret
</span><span class='line'>Leh_func_end1: 
</span><span class='line'> .cstring
</span><span class='line'>LC: 
</span><span class='line'> .asciz "Hello World!"</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>然后链接库并生成可执行程序（译注：如果你对 C 的编译链接过程还不熟悉可以参看 Deep C and C++）。要和 Objective-C 对比的话，处理过程很相似，生成的代码依赖于是否有 Objective-C Runtime 库。当刚学 Objective-C 时，我们最先了解的(最简单的那种)是 Objective-C 中用括号包起来的代码像这样…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[self doSomethingWithVar:var1];</span></code></pre></td></tr></table></div></figure>


<p>被转换为…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>objc_msgSend(self,@selector(doSomethingWithVar:),var1);</span></code></pre></td></tr></table></div></figure>


<p>但除了这些，我们就不知道之后在运行时做了什么了。</p>

<h4>Objective-C Runtime 是什么？</h4>

<p>Objective-C 的 Runtime 是一个运行时库（Runtime Library），它是一个主要使用 C 和汇编写的库，为 C 添加了面相对象的能力并创造了 Objective-C。这就是说它在类信息（Class information） 中被加载，完成所有的方法分发，方法转发，等等。Objective-C runtime 创建了所有需要的结构体，让 Objective-C 的面相对象编程变为可能。</p>

<h4>Objective-C Runtime 术语</h4>

<p>更深入之前，咱们先了解点术语。Mac 和 iPhone 开发者关心的有两个 runtime：Modern Runtime（现代的 Runtime） 和 Legacy Runtime（过时的 Runtime）。Modern Runtime：覆盖所有 64 位的 Mac OS X 应用和所有 iPhone OS 的应用。 Legacy Runtime: 覆盖其他的所有应用（所有 32 位的 Mac OS X 应用） Method 有 2 种基本类型的方法。Instance Method（实例方法）：以 ‘-’ 开始，比如 -(void)doFoo; 在对象实例上操作。Class Method（类方法）：以 ‘+’ 开始，比如 +(id)alloc。方法（Methods）和 C 的函数很像，是一组代码，执行一个小的任务，如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (NSString *)movieTitle
</span><span class='line'>{
</span><span class='line'>    return @"Futurama: Into the Wild Green Yonder";
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Selector 在 Objective-C 中 selector 只是一个 C 的数据结构，用于表示一个你想在一个对象上执行的 Objective-C 方法。在 runtime 中的定义像这样…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef struct objc_selector  *SEL; </span></code></pre></td></tr></table></div></figure>


<p>像这样使用…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SEL aSel = @selector(movieTitle); </span></code></pre></td></tr></table></div></figure>


<h4>Message（消息）</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[target getMovieTitleForObject:obj];</span></code></pre></td></tr></table></div></figure>


<p>消息是方括号 ‘[]’ 中的那部分，由你要向其发送消息的对象（target），你想要在上面执行的方法（method）还有你发送的参数（arguments）组成。Objective-C 的消息和 C 函数调用是不同的。事实上，你向一个对象发送消息并不意味着它会执行它。Object（对象）会检查消息的发送者，基于这点再决定是执行一个不同的方法还是转发消息到另一个目标对象上。Class 如果你查看一个类的runtime信息，你会看到这个…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef struct objc_class *Class;
</span><span class='line'>typedef struct objc_object {
</span><span class='line'>    Class isa;
</span><span class='line'>} *id; </span></code></pre></td></tr></table></div></figure>


<p>这里有几个事情。我们有一个 Objective-C 类的结构体和一个对象的结构体。objc_object 只有一个指向类的 isa 指针，就是我们说的术语 “isa pointer”（isa 指针）。这个 isa 指针是当你向对象发送消息时，Objective-C Runtime 检查一个对象并且查看它的类是什么然后开始查看它是否响应这些 selectors 所需要的一切。最后我么看到了 id 指针。默认情况下 id 指针除了告诉我们它们是 Objective-C 对象外没有其他用了。当你有一个 id 指针，然后你就可以问这个对象是什么类的，看看它是否响应一个方法，等等，然后你就可以在知道这个指针指向的是什么对象后执行更多的操作了。你可以在 LLVM/Clang 的文档中的 Block 中看到</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Block_literal_1 {
</span><span class='line'>    void *isa; // initialized to &_NSConcreteStackBlock or &_NSConcreteGlobalBlock    
</span><span class='line'>    int flags;    
</span><span class='line'>    int reserved;     
</span><span class='line'>    void (*invoke)(void *, ...); 
</span><span class='line'>    struct Block_descriptor_1 { 
</span><span class='line'>        unsigned long int reserved; // NULL     
</span><span class='line'>        unsigned long int size;  // sizeof(struct Block_literal_1)
</span><span class='line'>        // optional helper functions     
</span><span class='line'>        void (*copy_helper)(void *dst, void *src);
</span><span class='line'>        void (*dispose_helper)(void *src);     
</span><span class='line'>    } *descriptor;    
</span><span class='line'>    // imported variables
</span><span class='line'>}; </span></code></pre></td></tr></table></div></figure>


<p>Blocks 被设计为兼容 Objective-C 的 runtime，所以他们被作为对象对待，因此他们可以响应消息，比如 -retain，-release，-copy ，等等。IMP（方法实现 MethodImplementations）</p>

<p>typedef id (*IMP)(id self,SEL _cmd,&hellip;);
IMP 是指向方法实现的函数指针，由编译器为你生成。如果你新接触 Objective-C 你现在不需要直接接触这些，但是我们将会看到，Objective-C runtime 将如何调用你的方法的。Objective-C Classes（Objective-C 类） 那么什么是 Objective-C 类？在 Objective-C 中的一个类实现看起来像这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface MyClass : NSObject {
</span><span class='line'>    // vars
</span><span class='line'>    NSInteger counter;
</span><span class='line'>}
</span><span class='line'>// methods
</span><span class='line'>-(void)doFoo;
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>//但是 runtime 不只要追踪这些
</span><span class='line'>
</span><span class='line'>#if !__OBJC2__   
</span><span class='line'>    Class super_class                        OBJC2_UNAVAILABLE;
</span><span class='line'>    const char *name                         OBJC2_UNAVAILABLE;
</span><span class='line'>    long version                             OBJC2_UNAVAILABLE;
</span><span class='line'>    long info                                OBJC2_UNAVAILABLE;
</span><span class='line'>    long instance_size                       OBJC2_UNAVAILABLE;    
</span><span class='line'>    struct objc_ivar_list *ivars             OBJC2_UNAVAILABLE;    
</span><span class='line'>    struct objc_method_list **methodLists    OBJC2_UNAVAILABLE;    
</span><span class='line'>    struct objc_cache *cache                 OBJC2_UNAVAILABLE;    
</span><span class='line'>    struct objc_protocol_*protocols          OBJC2_UNAVAILABLE;
</span><span class='line'>#endif </span></code></pre></td></tr></table></div></figure>


<p>我们可以看到，一个类有其父类的引用，它的名字，实例变量，方法，缓存还有它遵循的协议。runtime 在响应类或实例的方法时需要这些信息。</p>

<h4>那么 Class 定义的是对象还是对象本身？它是如何实现的 （译注：读者需要区分 Class 和 class 是不同的，正如 Nil 和 nil 的用途是不同的）</h4>

<p>是的，之前我说过 Objective-C 类也是对象，runtime 通过创建 Meta Classes 来处理这些。当你发送一个消息像这样 [NSObject alloc] 你正在向类对象发送一个消息，这个类对象需要是 MetaClass 的实例，MetaClass 也是 root meta class 的实例。当你说继承自 NSObject 时，你的类指向 NSObject 作为自己的 superclass。然而，所有的 meta class 指向 root metaclass 作为自己的 superclass。所有的 meta class 只是简单的有一个自己响应的方法列表。所以当你向一个类对象发送消息如 [NSObject alloc]，然后实际上 objc_msgSend() 会检查 meta class 看看它是否响应这个方法，如果他找到了一个方法，就在这个 Class 对象上执行（译注：class 是一个实例对象的类型，Class 是一个类（class）的类型。对于完全的 OO 来说，类也是个对象，类是类类型(MetaClass)的实例，所以类的类型描述就是 meta class）。</p>

<h4>为什么我们继承自苹果的类</h4>

<p>从你开始 Cocoa 开发时，那些教程就说如继承自 NSObject 然后开始写一些代码，你享受了很多继承自苹果的类所带来的便利。有一件事你从未意识到的是你的对象被设置为使用 Objective-C 的 runtime。当我们为我们的类的一个实例分配了内存，像这样…</p>

<p>MyObject *object = [[MyObject alloc] init];
最先执行的消息是 +alloc。如果你查看下文档，它说“新的实例对象的 isa 实例变量被初始化为指向一个数据结构，那个数据结构描述了这个类；其他的实例变量被初始化为 0。”所以继承自苹果的类不仅仅是继承了一些重要的属性，也继承了能在内存中轻松分配内存的能力和在内存中创建满足 runtime 期望的对象结构（设置 isa 指针指向我们的类）。</p>

<h4>那么 Class Cache 是什么？（objc_cache *cache）</h4>

<p>当 Objective-C runtime 沿着一个对象的 isa 指针检查时，它会发现一个对象实现了许多的方法。然而你可能只调用其中一小部分的方法，也没有意义每次检查时搜索这个类的分发表（dispatch table）中的所有 selector。所以这个类实现了一个缓存，当你搜索一个类的分发表，并找到合适的 selector 后，就会把它放进缓存中。所以当 objc_msgSend() 在一个类中查找 selector 时会先查找类缓存。有个理论是，当你在一个类上调用了一个消息，你很可能之后还会调用它。所以如果我们考虑到这点，就意味着当我们有个子类继承自 NSObject 叫做 MyObject 并且运行了以下的代码</p>

<p>MyObject *obj = [[MyObject alloc] init];</p>

<p>@implementation MyObject
- (id)init {
    if(self = [super init]) {
        [self setVarA:@”blah”];  <br/>
    }
    return self;
}
@end
发生了以下的事：</p>

<p>(1) [MyObject alloc] 首先被执行。MyObject 没有实现 alloc 方法，所以我们不能在这个类中找到 +alloc 方法，然后沿着 superclass 指针会指向 NSObject。</p>

<p>(2) 我们询问 NSObject 是否响应 +alloc 方法，它可以。+alloc 检查消息的接收者类，是 MyObject，然后分配一块和我们的类同样大小的内存空间，并初始化它的 isa 指针指向 MyObject 类，我们现在有了一个实例对象，最终把类对象的 +alloc 方法加入 NSObject 的类缓存（class cache）中（lastly we put +alloc in NSObject’s class cache for the class object ）。</p>

<p>(3) 到现在为止，我们发送了一个类消息，但是现在我们发送一个实例消息，只是简单的调用 -init 或者我们设计的初始化方法。当然，我们的类会响应这个方法，所以 -(id)init 加入到缓存中。（译注：要是 MyObject 实现了 init 方法，就会把 init 方法加入到 MyObject 的 class cache 中，要是没有实现，只是因为继承才有了这个方法，init 方法还是会加入到 NSObject 的 class cache 中）。</p>

<p>(4) 然后 self = [super init] 被调用。super 是个 magic keyword，指向对象的父类，所以我们得到了 NSObject 并调用它的的 init 方法。这样可以确保 OOP（面相对象编程） 的继承功能正常，这个方法可以正确的初始化父类的变量，之后你（在子类中）可以初始化自己的变量，如果需要可以覆盖父类的方法。在 NSObject 的例子中，没什么重要的要做，但并不总是这样。有时要做些重要的初始化。比如…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import &lt;Foundation/Foundation.h&gt; 
</span><span class='line'>
</span><span class='line'>@interface MyObject : NSObject {
</span><span class='line'>    NSString *aString;
</span><span class='line'>} 
</span><span class='line'>    @property(retain) NSString *aString; 
</span><span class='line'>
</span><span class='line'>@end 
</span><span class='line'>
</span><span class='line'>@implementation MyObject
</span><span class='line'>
</span><span class='line'>-(id)init 
</span><span class='line'>{ 
</span><span class='line'>    if (self = [super init]) {
</span><span class='line'>        [self setAString:nil];
</span><span class='line'>    }
</span><span class='line'>    return self;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@synthesize aString;
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>int main (int argc, const char * argv[]) 
</span><span class='line'>{
</span><span class='line'>    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
</span><span class='line'>
</span><span class='line'>    id obj1 = [NSMutableArray alloc]; 
</span><span class='line'>    id obj2 = [[NSMutableArray alloc] init];   
</span><span class='line'>    id obj3 = [NSArray alloc]; 
</span><span class='line'>    id obj4 = [[NSArray alloc] initWithObjects:@"Hello",nil];
</span><span class='line'>
</span><span class='line'>    NSLog(@"obj1 class is %@",NSStringFromClass([obj1 class]));
</span><span class='line'>    NSLog(@"obj2 class is %@",NSStringFromClass([obj2 class]));
</span><span class='line'>    NSLog(@"obj3 class is %@",NSStringFromClass([obj3 class]));
</span><span class='line'>    NSLog(@"obj4 class is %@",NSStringFromClass([obj4 class]));
</span><span class='line'>
</span><span class='line'>    id obj5 = [MyObject alloc]; 
</span><span class='line'>    id obj6 = [[MyObject alloc] init];   
</span><span class='line'>
</span><span class='line'>    NSLog(@"obj5 class is %@",NSStringFromClass([obj5 class]));    
</span><span class='line'>    NSLog(@"obj6 class is %@",NSStringFromClass([obj6 class]));   
</span><span class='line'>
</span><span class='line'>    [pool drain];
</span><span class='line'>    return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>现在如果你新接触 Cocoa ，我让你猜会会输出什么，你可能会说</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSMutableArray
</span><span class='line'>NSMutableArray 
</span><span class='line'>NSArray
</span><span class='line'>NSArray
</span><span class='line'>MyObject
</span><span class='line'>MyObject</span></code></pre></td></tr></table></div></figure>


<p>但是，实际上是</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>obj1 class is __NSPlaceholderArray
</span><span class='line'>obj2 class is NSCFArray
</span><span class='line'>obj3 class is __NSPlaceholderArray
</span><span class='line'>obj4 class is NSCFArray
</span><span class='line'>obj5 class is MyObject
</span><span class='line'>obj6 class is MyObject</span></code></pre></td></tr></table></div></figure>


<p>这是因为在 Objective-C 中 +alloc 方法可能会返回某个类的对象，然后在 -init 中返回另一个类的对象。
（译注：感兴趣的同学可以看下这两篇文章：Class Clusters, Make Your Own Abstract Factory Class Cluster in Objective-C, 第二篇文章需要自备小梯子。)</p>

<h4>那么在 objc_msgSend 中发生了什么？</h4>

<p>事实上在 objc_msgSend() 中发生了许多事儿。假设我们有这样的代码…</p>

<p>[self printMessageWithString:@&ldquo;Hello World!&rdquo;];
它实际上会被编译器翻译为…</p>

<p>objc_msgSend(self,@selector(printMessageWithString:),@&ldquo;Hello World!&rdquo;);
我们沿着目标对象的 isa 指针查找，看看是否这个对象响应 @selector(printMessageWithString:) selector。假设我们在类的分发表或者缓存中找到了这个 selector，我们沿着函数指针并且执行它。这样 objcmsgSend() 就永远不会返回，它开始执行，然后沿着指向方法的指针，然后你的方法返回，这样看起来 objcmsgSend() 方法返回了。Bill Bumgarner 比我讲了更多 objc_msgSend() 的细节（部分1，部分2 和 部分3）。</p>

<p>概括下他说的，并且你已经看过了 Objective-C 的 runtime 代码…</p>

<p>检查忽略的 Selector 和短路（Short Circut）—— 显然，如果我们运行在垃圾回收机制下，我们可以忽略调用 -retain, -release, 等等。
检查 nil 对象（target）。和其他的语言不一样的是，在 Objective-C 中向 nil 发送消息是完全合法的，并且有些原因下你会愿意这么做的。假设我们有个非 nil 的对象，然后我们继续…
然后我们需要在这个类上找到 IMP，所以我们先从 class cache 中找起，如果找到了就沿着指针跳到这个函数。
如果没有在缓存中找到 IMP，然后去查找类的分发表，如果找到了，就沿着指针跳到这个函数。
如果 IMP 没有在缓存和类的分发表中找到，然后我们跳到转发机制。这意味着最终你的代码被编译器转换为 C 函数。你写的方法会像这样…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-(int)doComputeWithNum:(int)aNum </span></code></pre></td></tr></table></div></figure>


<p>会被翻译为…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int aClass_doComputeWithNum(aClass *self,SEL _cmd,int aNum) </span></code></pre></td></tr></table></div></figure>


<p>Objective-C Runtime 通过调用（invoking）指向这些方法的函数指针调用你的方法（call your methods）。现在，我要说的是，你不能直接调用这些被翻译的方法，但是 Cocoa 框架提供了获得函数指针的方法…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//declare C function pointer
</span><span class='line'>int (computeNum *)(id,SEL,int);
</span><span class='line'>
</span><span class='line'>//methodForSelector is COCOA & not ObjC Runtime
</span><span class='line'>//gets the same function pointer objc_msgSend gets
</span><span class='line'>computeNum = (int (*)(id,SEL,int))[target methodForSelector:@selector(    doComputeWithNum:)]; 
</span><span class='line'>
</span><span class='line'>//execute the C function pointer returned by the runtime
</span><span class='line'>computeNum(obj,@selector(doComputeWithNum:),aNum); </span></code></pre></td></tr></table></div></figure>


<p>通过这种方法，你可以直接访问这个函数，并且可以在运行时直接调用，甚至可以使用这个避开 runtime 的动态特性，如果你绝对需要确保一个方法被执行。Objective-C 就是用这种途径去调用你的方法的，但是使用的是 objc_msgSend()。</p>

<h4>Objective-C 消息转发</h4>

<p>在 Objective-C 中向一个不知道如何响应这个方法的对象发送消息是完全合法的（甚至可能是一种潜在的设计决定）。苹果的文档中给出的一个原因是模拟多继承，Objective-C 不是原生支持的，或者你可能只是想抽象你的设计并且隐藏幕后处理这些消息的其他对象/类。这一点是 runtime 非常需要的。它是这样做的 1. Runtime 检查了你的类和所有父类的 class cache 和分发表，但是没找到指定的方法。2. Objective_C 的 Runtime 会在你的类上调用 + (BOOL) resolveInstanceMethod:(SEL)aSEL。 这就给了你一个机会去提供一个方法实现并且告诉 runtime 你已经解析了这个方法，如果它开始查找，这回就会找到这个方法。你可以像这样实现…定义一个函数…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void fooMethod(id obj, SEL _cmd)
</span><span class='line'>{ 
</span><span class='line'>    NSLog(@"Doing Foo");
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后你可以像这样使用 class_addMethod() 解析它…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+(BOOL)resolveInstanceMethod:(SEL)aSEL
</span><span class='line'>{
</span><span class='line'>    if(aSEL == @selector(doFoo:))
</span><span class='line'>    {
</span><span class='line'>            class_addMethod([self class],aSEL,(IMP)fooMethod,"v@:");
</span><span class='line'>            return YES;
</span><span class='line'>    }
</span><span class='line'>    return [super resolveInstanceMethod];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在 class_addMethod() 最后一部分的 “v@:” 是方法的返回和参数类型。你可以在 Runtime Guide 的 Type Encoding 章节看到完整介绍。 3. Runtime 然后调用 – (id)forwardingTargetForSelector:(SEL)aSelector。这样做是为了给你一次机会（因为我们不能解析这个方法（参见上面的 #2））引导 Objective-C runtime 到另一个可以响应这个消息的对象上，在花费昂贵的处理过程调用 – (void)forwardInvocation:(NSInvocation *)anInvocation 之前调用这个方法也是更好的。你可以像这样实现</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (id)forwardingTargetForSelector:(SEL)aSelector
</span><span class='line'>{
</span><span class='line'>    if(aSelector == @selector(mysteriousMethod:))
</span><span class='line'>    {        
</span><span class='line'>        return alternateObject;
</span><span class='line'>    }
</span><span class='line'>    return [super forwardingTargetForSelector:aSelector];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>显然你不想从这个方法直接返回 self，否则可能会产生一个死循环。 4. Runtime 最后一次会尝试在目标对象上调用 – (void)forwardInvocation:(NSInvocation *)anInvocation。如果你从没看过 NSInvocation，它是 Objective-C 消息的对象形式。一旦你有了一个 NSInvocation 你可以改变这个消息的一切，包括目标对象，selector 和参数。所以你可以这样做…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-(void)forwardInvocation:(NSInvocation *)invocation
</span><span class='line'>{  
</span><span class='line'>    SEL invSEL = invocation.selector;    
</span><span class='line'>    if([altObject respondsToSelector:invSEL]) {        
</span><span class='line'>        [invocation invokeWithTarget:altObject];    
</span><span class='line'>    } else {        
</span><span class='line'>        [self doesNotRecognizeSelector:invSEL];    
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如果你继承自 NSObject，默认它的 – (void)forwardInvocation:(NSInvocation *)anInvocation 实现只是简单的调用 -doesNotRecognizeSelector:，你可以在最后一次机会里覆盖这个方法去做一些事情。（译注：对这块内容有兴趣的同学可以参见：<a href="http://www.cnblogs.com/biosli/p/NSObjectinherit2.html%EF%BC%89">http://www.cnblogs.com/biosli/p/NSObjectinherit2.html%EF%BC%89</a></p>

<h4>Non Fragile ivars（Modern Runtime）（非脆弱的 ivar）</h4>

<p>我们最近在 Modern Runtime 里得到的是 Non Fragile ivars 的概念。当编译你的类时，编译器生成了一个 ivar 布局，显示了在你的类中从哪可以访问你的 ivars，获取指向你的对象的指针，查看 ivar 与对象起始字节的偏移关系，和获取读入的变量类型的总共字节大小等一些底层的细节。所以你的 ivar 布局可能看起来像这样，左侧的数字是字节偏移量。</p>

<p>我们有了 NSObject 的 ivar 布局，然后我们继承自 NSObject 去扩展它并且添加了我们自己的 ivars。在苹果发布更新前这都工作的很好，但是 Mac OS X 10.6 发布后，就成了这样</p>

<p>你的自定义对象被剔除了因为我们有了一个重叠的父类。唯一可以防止这个的办法是如果苹果坚持之前的布局，如果他们这么做了，那么他们的框架就不能改进，因为他们的 ivar 布局被冻住了。在 fragile ivar 下你不得不重新编译你继承自苹果类的类来恢复兼容性。所以在非 fragile ivar 时，会发生生么？</p>

<p>使用非 fragile ivars 时，编译器生成和 fragile ivars 相同的 ivar 布局。然而当 runtime 检测到一个重叠的超类时，它调整你在这个类中新增的 ivar 的偏移量，这样在子类中新增加的那部分就显示出来了。</p>

<h4>Objective-C 关联对象</h4>

<p>最近在 Mac OS X 10.6 雪豹 中新引入了关联引用。Objective-C 不能动态的添加一些属性到对象上，和其他的一些原生支持这点的语言不一样。所以之前你都不得不努力为未来要增加的变量预留好空间。在 Mac OS X 10.6 中，Objective-C 的 Runtime 已经原生的支持这个功能了。如果我们想向一个已有的类添加变量，看起来像这样…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import &lt;Cocoa/Cocoa.h&gt; //Cocoa
</span><span class='line'>#include &lt;objc/runtime.h&gt; //objc runtime api’s 
</span><span class='line'>
</span><span class='line'>@interface NSView (CustomAdditions)
</span><span class='line'>@property(retain) NSImage *customImage;
</span><span class='line'>@end 
</span><span class='line'>
</span><span class='line'>@implementation NSView (CustomAdditions) 
</span><span class='line'>
</span><span class='line'>static char img_key; //has a unique address (identifier)
</span><span class='line'>
</span><span class='line'>- (NSImage *)customImage
</span><span class='line'>{    
</span><span class='line'>    return objc_getAssociatedObject(self,&img_key);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)setCustomImage:(NSImage *)image
</span><span class='line'>{    
</span><span class='line'>    objc_setAssociatedObject(self, &img_key,image, OBJC_ASSOCIATION_RETAIN);
</span><span class='line'>} 
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>objc_setAssociatedObject() 的选项，你可以在 runtime.h 文件中找到。
</span><span class='line'>
</span><span class='line'>/* Associated Object support. */ 
</span><span class='line'>
</span><span class='line'>/* objc_setAssociatedObject() options */
</span><span class='line'>enum {    
</span><span class='line'>    OBJC_ASSOCIATION_ASSIGN = 0,    
</span><span class='line'>    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1,    
</span><span class='line'>    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,    
</span><span class='line'>    OBJC_ASSOCIATION_RETAIN = 01401,    
</span><span class='line'>    OBJC_ASSOCIATION_COPY = 01403
</span><span class='line'>}; </span></code></pre></td></tr></table></div></figure>


<p>这些和 @property 语法中的选项意思一样。</p>

<h4>混和的 vTable Dispatch</h4>

<p>如果你看过 modern runtime 的代码，你会发现这个（在 objc-runtime-new.m 中）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/***********************************************************************
</span><span class='line'>* vtable dispatch
</span><span class='line'>* 
</span><span class='line'>* Every class gets a vtable pointer. The vtable is an array of IMPs.
</span><span class='line'>* The selectors represented in the vtable are the same for all classes
</span><span class='line'>*   (i.e. no class has a bigger or smaller vtable).
</span><span class='line'>* Each vtable index has an associated trampoline which dispatches to 
</span><span class='line'>*   the IMP at that index for the receiver class's vtable (after 
</span><span class='line'>*   checking for NULL). Dispatch fixup uses these trampolines instead 
</span><span class='line'>*   of objc_msgSend.
</span><span class='line'>* Fragility: The vtable size and list of selectors is chosen at launch 
</span><span class='line'>*   time. No compiler-generated code depends on any particular vtable 
</span><span class='line'>*   configuration, or even the use of vtable dispatch at all.
</span><span class='line'>* Memory size: If a class's vtable is identical to its superclass's 
</span><span class='line'>*   (i.e. the class overrides none of the vtable selectors), then 
</span><span class='line'>*   the class points directly to its superclass's vtable. This means 
</span><span class='line'>*   selectors to be included in the vtable should be chosen so they are 
</span><span class='line'>*   (1) frequently called, but (2) not too frequently overridden. In 
</span><span class='line'>*   particular, -dealloc is a bad choice.
</span><span class='line'>* Forwarding: If a class doesn't implement some vtable selector, that 
</span><span class='line'>*   selector's IMP is set to objc_msgSend in that class's vtable.
</span><span class='line'>* +initialize: Each class keeps the default vtable (which always 
</span><span class='line'>*   redirects to objc_msgSend) until its +initialize is completed.
</span><span class='line'>*   Otherwise, the first message to a class could be a vtable dispatch, 
</span><span class='line'>*   and the vtable trampoline doesn't include +initialize checking.
</span><span class='line'>* Changes: Categories, addMethod, and setImplementation all force vtable 
</span><span class='line'>*   reconstruction for the class and all of its subclasses, if the 
</span><span class='line'>*   vtable selectors are affected.
</span><span class='line'>**********************************************************************/ </span></code></pre></td></tr></table></div></figure>


<p>背后的思想是，runtime 尝试在这个 vtable 中存储最近被调用的 selectors，这样就可以提升你的应用的速度，因为它使用了比 objc_msgSend 更少的指令（fewer instructions）。vtable 中保存 16 个全局最经常调用的 selectors，事实上顺着代码往下看你可以发现垃圾回收和非垃圾回收类型程序的默认 selectors …</p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[移动App架构设计]]></title>
        <link href="http://swplzj.github.io/blog/2014/10/25/yi-dong-app-jia-gou-she-ji/"/>
        <updated>2014-10-25T21:47:01+08:00</updated>
        <id>http://swplzj.github.io/blog/2014/10/25/yi-dong-app-jia-gou-she-ji</id>
        <content type="html"><![CDATA[<p>Native app的开发相比传统的项目迭代周期要短很多, 需求的变化也频繁一些, 在开发的不同生命周期里采用不同的架构模式可以有效的节约开发时间, 提高开发效率, 这篇文章介绍几种常用的架构模式:</p>

<!--more-->


<h4>表现层</h4>

<h5>基本的MVC</h5>

<p>移动app一般都是采用经典的mvc架构</p>

<table>
<thead>
<tr>
<th>层次      </th>
<th> 作用     </th>
<th> 设计原则</th>
</tr>
</thead>
<tbody>
<tr>
<td>模型层(model)</td>
<td>   封装了应用的一系列数据, 并定义了操作, 处理这些数据的逻辑和计算规则。</td>
<td>通过Notification,KVO对控制器进行反馈</td>
</tr>
<tr>
<td>视图层(view) </td>
<td>视图对象是一个应用中, 用户可以看到的对象. 视图对象知道如何绘制自己, 也能够响应用户的操作. 视图对象的主要目的之一是将应用模型对象中的数据显示出来, 并允许用户编辑该数据 </td>
<td>视图通过不能直接操作模型层, 通过target-action, delegate, dataSource和控制器进行反馈</td>
</tr>
<tr>
<td>控制器层(controller)    </td>
<td>控制器层是在视图层和若干个模型层的中间人</td>
<td> c可以直接操作模型层和视图层</td>
</tr>
</tbody>
</table>


<p><img src="https://github.com/uxyheaven/NativeAppFrameworkDesign/raw/master/image/mvc.png" alt="id1" /></p>

<h5>总结:</h5>

<ul>
<li>C对M：API</li>
<li>C对V：Outlet</li>
<li>V对C：Target-action， Delegate，Datasource</li>
<li>M对C：Notification，KVO</li>
</ul>


<h5>MVC的改进版 MVVM</h5>

<p>MVVM是在MVC的基础上多了一个View Model: 表示逻辑, 将 model 的数据转换为 view 可以呈现的东西. 适合大量展示类的App.</p>

<p><img src="https://github.com/uxyheaven/NativeAppFrameworkDesign/raw/master/image/mvvm.png" alt="id2" /></p>

<h5>HMVC</h5>

<p>Hierarchical MVC, 把客户端应用程序分解为有层次的父子关系的MVC, 反复应用这个模式, 形成结构化的客户端架构. 适合重型B/S架构的WebApp.</p>

<p>一个MVC模块由应用程序的一个模块抽象而成. 其中很重要的一个概念就是 Parent MVC , 它可以对应界面上的实体, 也可以是一个抽象的对象. 设想一个app 有标签栏, 工具栏, 导航栏, 主工作区, 对应到HMVC上就是这个app最底部的标签栏 是 Layer1, Layer2 导航栏,主要工作区, 工具栏. 如果觉得 Layer2 太复杂可以吧主要工作区放到 Layer3, 依次类推.</p>

<p>Controller 是功能模块的总控室, 它负责和子Controller或父Controller通信，并通知它的 View 处理改变界面显示, Model 处理一些业务逻辑或数据库访问操作. 如才的例子里, 点击了工具栏里的一个按钮, 工具栏的Controller 响应这个event, 发现是要切换主工作区, 工具栏做不了,就传递他的父Controller处理(如果父Controller也处理不了, 就继续往上传递)然后标签栏的Controller处理切换主工作区.</p>

<p>优点:</p>

<p>把程序分成了几个部分, 降低了依赖性
支持鼓励重用代码, 组件或者模块。
在今后的维护中, 提高了可扩展性。</p>

<p><img src="https://github.com/uxyheaven/NativeAppFrameworkDesign/raw/master/image/hmvc.png" alt="id3" /></p>

<h4>分层设计</h4>

<h5>三层架构</h5>

<p>我们在来看一下经典的三层架构</p>

<p>从上至下为</p>

<ul>
<li>表现层(UI)</li>
<li>业务逻辑层或称为领域层(BLL)</li>
<li>数据访问层(DAL)</li>
</ul>


<table>
<thead>
<tr>
<th>层次  </th>
<th> 作用    </th>
<th>设计原则</th>
</tr>
</thead>
<tbody>
<tr>
<td>表现层(UI) </td>
<td> 向用户展现特定业务数据，采集用户的输入信息和操 </td>
<td>用户至上，兼顾简洁；不包含任何业务相关的逻辑处理</td>
</tr>
<tr>
<td>业务逻辑层(BLL)    </td>
<td>从ＤＡＬ中获取数据, 在ＵＩ显示; 从ＵＩ中获取用户指令和数据, 执行业务逻辑或通过ＤＡＬ写入数据源 </td>
<td> 作为U层与Ｄ层的桥梁,目的在于展现清晰的函数结构, 只负责数据处理传递, 不涉及ＳＱＬ语句和ＡＤＯ.ＮＥＴ</td>
</tr>
<tr>
<td>数据访问层(DAL)    </td>
<td> 直接操作数据库，针对数据的增添 删除 修改 查找; 具体为业务逻辑层或表示层提供数据服务。</td>
<td> 专门操作数据库, 不考虑数据合法性. 数据库错误返回－1, 逻辑错误返回0, 并告知错误原因, 成功返回1</td>
</tr>
</tbody>
</table>


<p><img src="https://github.com/uxyheaven/NativeAppFrameworkDesign/raw/master/image/mvc_vs_3.png" alt="id4" /></p>

<p>然后呢,我们现在的架构则是
<img src="https://github.com/uxyheaven/NativeAppFrameworkDesign/raw/master/image/3.png" alt="id5" /></p>

<h5>四层架构</h5>

<p>在三层架构的基础上多了业务规则层, 通常的三层是把业务逻辑和业务规则合并为一个层，统称为业务层. 业务规则层的提出,既可以及时处理用户输入的不合法信息, 又可以及时处理数据库错误, 增大了业务逻辑层的结构清晰度, 让业务逻辑人员专心致志做逻辑.</p>

<p>从上至下为</p>

<ul>
<li>表现层</li>
<li>业务规则层</li>
<li>业务逻辑层或称为领域层</li>
<li>数据访问层</li>
</ul>


<table>
<thead>
<tr>
<th>层次  </th>
<th>作用</th>
<th>    设计原则</th>
</tr>
</thead>
<tbody>
<tr>
<td>业务规则层(ECL)</td>
<td>   对于UI层传下来的参数来说，检查合法性。</td>
<td>用户至上，兼顾简洁；不包含任何业务相关的逻辑处理</td>
</tr>
</tbody>
</table>


<h5>五层架构</h5>

<p>一般情况下, 我们的业务逻辑放在中间层, 那么对内部的这些大量种类繁多，使用方法也各异的不同的类的调用任务，就完全落到了表示层. 这样势必会增加表示层的代码量, 将表示层的任务复杂化, 和表示层只负责接受用户的输入并返回结果的任务不太相称, 并增加了层与层之间的耦合程度. 因此呢,我们需要增加接口去去统一的管理这些业务, 是设计模式中Facade模式的思想.</p>

<p>从上至下为</p>

<ul>
<li>表现层</li>
<li>业务外观层</li>
<li>业务规则层</li>
<li>业务逻辑层或称为领域层</li>
<li>数据访问层</li>
</ul>


<table>
<thead>
<tr>
<th>层次</th>
<th> 作用</th>
<th>     设计原则</th>
</tr>
</thead>
<tbody>
<tr>
<td>业务外观层 </td>
<td>为负责子系统中的一组接口提供一个一致而且简单的接口。</td>
<td></td>
</tr>
</tbody>
</table>


<h5>引入service层</h5>

<p>引入service层的架构和普通的分层架构的不同是: service层内部有数据, 可以单独运行.</p>

<p>service</p>

<p>从上至下为</p>

<ul>
<li>表现层</li>
<li>服务层(service)</li>
<li>数据访问层</li>
<li>业务逻辑层</li>
</ul>


<table>
<thead>
<tr>
<th>层次</th>
<th> 作用  </th>
<th> 设计原则</th>
</tr>
</thead>
<tbody>
<tr>
<td>表现层   </td>
<td>显示与用户的互交   </td>
<td></td>
</tr>
<tr>
<td>服务层   </td>
<td>service层提供表现层的业务逻辑入口,通过定义接口服务的形式,通过接口调用来完成.</td>
<td></td>
</tr>
<tr>
<td>业务逻辑层 </td>
<td>1接收服务层传来的DTO, 然后根据业务规则, 对传入的DTO进行加工, 返回加工后的信息 2 需要为每个对象提供业务行为, 并且这些对象之间是独立的 3 业务对象之间的交互流程通过服务层来组织</td>
<td></td>
</tr>
<tr>
<td>数据访问层 </td>
<td>本地数据远程数据的访问接口    </td>
<td></td>
</tr>
</tbody>
</table>


<h5>新秀VIPER</h5>

<p>viper这里不多说了,请想了解的自行搜索
<img src="https://github.com/uxyheaven/NativeAppFrameworkDesign/raw/master/image/viper.png" alt="id6" /></p>
]]></content>
    </entry>
    
    <entry>
        <title type="html"><![CDATA[iOS多线程操作：锁 互斥 同步]]></title>
        <link href="http://swplzj.github.io/blog/2014/10/17/ios-duo-xian-cheng-cao-zuo/"/>
        <updated>2014-10-17T23:03:45+08:00</updated>
        <id>http://swplzj.github.io/blog/2014/10/17/ios-duo-xian-cheng-cao-zuo</id>
        <content type="html"><![CDATA[<p>在iOS中有几种方法来解决多线程访问同一个内存地址的互斥同步问题，本文简单介绍：</p>

<h5>方法一，@synchronized(id anObject),(最简单的方法)</h5>

<p>会自动对参数对象加锁，保证临界区内的代码线程安全</p>

<!--more-->




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@synchronized(self)  
</span><span class='line'>{  
</span><span class='line'>     // 这段代码对其他 @synchronized(self) 都是互斥的         
</span><span class='line'>     // self 指向同一个对象  
</span><span class='line'>}   </span></code></pre></td></tr></table></div></figure>


<p></p>

<h5>方法二，NSLock</h5>

<p>NSLock对象实现了NSLocking protocol，包含几个方法：
lock，加锁
unlock，解锁
tryLock，尝试加锁，如果失败了，并不会阻塞线程，只是立即返回NO
lockBeforeDate:，在指定的date之前暂时阻塞线程（如果没有获取锁的话），如果到期还没有获取锁，则线程被唤醒，函数立即返回NO
比如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSLock *theLock = [[NSLock alloc] init];   
</span><span class='line'>if ([thelock lock])   
</span><span class='line'>{  
</span><span class='line'>   //do something here  
</span><span class='line'>   [theLock unlock];   
</span><span class='line'>}   </span></code></pre></td></tr></table></div></figure>


<h5>方法三，NSRecursiveLock，递归锁</h5>

<p>NSRecursiveLock，多次调用不会阻塞已获取该锁的线程。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> NSRecursiveLock *theLock = [[NSRecursiveLock alloc] init];   
</span><span class='line'> void MyRecursiveFunction(int value)   
</span><span class='line'>{   
</span><span class='line'>  [theLock lock];   
</span><span class='line'>  if (value != 0)   
</span><span class='line'>  &lt;span style=“font-size:14px;”&gt; &lt;/span&gt;{   
</span><span class='line'>    –value;   
</span><span class='line'>    MyRecursiveFunction(value);   
</span><span class='line'> }  
</span><span class='line'>   [theLock unlock];   
</span><span class='line'>}   
</span><span class='line'> MyRecursiveFunction(5);  </span></code></pre></td></tr></table></div></figure>


<p></p>

<h5>方法四，NSConditionLock，条件锁</h5>

<p>NSConditionLock，条件锁，可以设置条件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//公共部分  
</span><span class='line'>id condLock = [[NSConditionLock alloc] initWithCondition:NO_DATA];       
</span><span class='line'> //线程一，生产者  
</span><span class='line'> while(true) {   
</span><span class='line'>        [condLock lockWhenCondition:NO_DATA];   
</span><span class='line'>        //生产数据  
</span><span class='line'>        [condLock unlockWithCondition:HAS_DATA];   
</span><span class='line'>}     
</span><span class='line'> //线程二，消费者  
</span><span class='line'> while (true) {   
</span><span class='line'>        [condLock lockWhenCondition:HAS_DATA];   
</span><span class='line'>        //消费  
</span><span class='line'>        [condLock unlockWithCondition:NO_DATA];   
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<h5>方法五，NSDistributedLock，分布锁</h5>

<p>NSDistributedLock，分布锁，文件方式实现，可以跨进程
用tryLock方法获取锁。
用unlock方法释放锁。
如果一个获取锁的进程在释放锁之前挂了，那么锁就一直得不到释放了，此时可以通过breakLock强行获取锁。</p>
]]></content>
    </entry>
    
</feed>

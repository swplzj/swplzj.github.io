
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
 <!-- 百度站长HTML标签验证 -->
  <meta name="baidu-site-verification" content="2UxriFj8TS" />

  <title>iOS面试题-干货 - Leo Lee</title>
  <meta name="author" content="Leo Lee">

  
  <meta name="description" content="很全的面试题，有百度腾讯各大公司的真题，快来看看吧。 Part 1 1、说说OC内存管理； 2、ASIRequest是什么； 3、怎么输出json字符串； 4、说说http头部有哪些内容； 5、说说OC生命周期；
6、运用第三方框架，到时候出了问题，谁来负责 7、自己写一个strcpy函数 8、 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://swplzj.github.io/blog/2014/09/17/ios-mian-shi-ti">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Leo Lee" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
 <!-- <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script> -->
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  
<!--   

 --></head>

<body    class="collapse-sidebar sidebar-footer" >
  <nav id="main-nav" role="navigation">
<ul class="main-navigation">
  <li><a href="/" class="nav-link">首页 | Blog</a></li>
  <li><a href="/blog/archives" class="nav-link">归档 | Archives</a></li>
  <li><a href="/atom.xml" class="nav-link">订阅 | RSS</a></li>
  <li><a href="/about" class="nav-link">关于我 | About</a></li>
</ul>

</nav>
  
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">iOS面试题-干货</h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-09-17T17:29:15+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


<div class="entry-content"><p>很全的面试题，有百度腾讯各大公司的真题，快来看看吧。</p>

<h4>Part 1</h4>

<p>1、说说OC内存管理；</p>

<p>2、ASIRequest是什么；</p>

<p>3、怎么输出json字符串；</p>

<!--more-->


<p>4、说说http头部有哪些内容；</p>

<p>5、说说OC生命周期；
6、运用第三方框架，到时候出了问题，谁来负责</p>

<p>7、自己写一个strcpy函数</p>

<p>8、字母统计(如，输入字符串“aabbbccddddaaaaa”，输出“2a3b2c4d5a”)</p>

<p>9、你用过哪些框架</p>

<p>10、进程与线程的区别</p>

<p>11、开辟线程的方式有哪些</p>

<p>12、实现进程同步的方式有哪些，或者说你怎么实现进程同步</p>

<p>13、请你谈谈同步和异步，用操作系统知识解释一下。</p>

<p>14、请你谈谈多态</p>

<p>15、怎么将数据写入文件（归档，解当）</p>

<p>16、写一个set方法（retain和copy权限）</p>

<p>17、</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Int* fun()
</span><span class='line'>{
</span><span class='line'>   Int a=5;
</span><span class='line'>   Int * p=&a;
</span><span class='line'>   Return p;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>请问：在主函数里面调用fun函数，这样可以吗？如果不可以，请说明为什么，并给出一种解决方案。</p>

<p>18、在颜色中，有GB8888和 GB565标准，前者32位，其中R占8位，G占8位，B占8位，透明度占8位，后者16位，其中，R占5位，G占6位，B占5位。现在要将一个GB8888类型颜色转换成GB565类型，怎么转</p>

<p>19、判断一个数是否为素数</p>

<p>20、优化代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   1、int a=b*4;
</span><span class='line'>   2、int a=b/8;
</span><span class='line'>   3、int a=b%1;
</span><span class='line'>   4、int a=b%16;
</span><span class='line'>   5、int a=(b*3)/8;</span></code></pre></td></tr></table></div></figure>


<p> 21、什么是内联函数？</p>

<p>22、assign,retain,copy的区别</p>

<p>23、面向对象的特性</p>

<p>24、实现一个view从顶部移到底部的动画</p>

<p>25、#ff3344转换成uicolor</p>

<p>26、判断一个链表是否有循环</p>

<p>27、写一个代理类</p>

<p>28、进程之间是怎么通信的</p>

<p>29、oc有哪些优点和缺点</p>

<p>30、什么时候用delegate,什么时候用Notification?</p>

<p>31、写一个”标准”宏MIN ，这个宏输入两个参数并返回较小的一个。当你写下面的代码时会发生什么事？</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>least = MIN(*p++, b);</span></code></pre></td></tr></table></div></figure>


<p>32、MVC模式的理解</p>

<p>33、堆和栈的区别</p>

<p>34、自动释放池是什么,如何工作</p>

<p>35、写一个委托的interface</p>

<p>36、objective-c的内存管理</p>

<p>37、什么是Notification？</p>

<p>38、下面的声明都是什么意思？</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>constint a;
</span><span class='line'>intconst a;
</span><span class='line'>constint *a;
</span><span class='line'>int* const a;
</span><span class='line'>intconst * a const;</span></code></pre></td></tr></table></div></figure>


<h4>Part 2</h4>

<p><img src="http://nsobject.u.qiniudn.com/wp-content/uploads/2014/11/ssss.jpg" alt="id1" /></p>

<h4>Part 3</h4>

<p>这个是百度面试</p>

<p>Objective C runtime library：Objective C的对象模型，block的底层实现结构，消息发送，消息转发，这些都需要背后C一层的描述，内存管理。
Core Data：中多线程中处理大量数据同步时的操作。
Multithreading：什么时候处理多线程，几种方式，优缺点。
Delegate， Notification，KVO， other 优缺点
设计一个progress bar解决方案，追问到 Core Graphic、CGPath、maskLayer。
设计一个popup view被追问到 keyWindow、UIWindow的layer、UIView hierarchy。
从设计模式的角度分析Delegate、Notification、KVO的区别。被追问到自己写的library和开源的项目中用到哪些设计模式，为什么使用，有哪些好处和坏处，现在能否改进。
算是问题3的追问，设计一个方案来检测KVO的同步异步问题。willChange和 didChange的不同点，然后被追问到有没有其他地方也有类似情况，被追问到Core Data 中falut object。
这个是问题4的追问，设计一个KVO系统。
Multithreading，什么时候采用Multithreading方案，以及理由。追问到系统还有哪些在后台运行的thread，被追问到view life cycle、iOS6之后的不同以及内存管理。
Multithreading中常常遇到的问题，追问到死锁，优先级翻转，线程池等。
百度有一个亿级别的APP需要统计用户行为的日志系统。不使用数据库，只是使用普通文件，设计一个系统。被追问到内存映射文件。这个问题本来是服务器的问题，我表示从来没做过，回答很瞎。
算法考了2个。一个是如何求2个集合的交集。另一个是百亿数据中查找相同的数字以及出现的次数。</p>

<p>为什么做Windows Mobile
为什么改iOS
为什么来百度
为什么iPhone 可以成功，那些吸引你
如何看待AppStore 现在的生态圈</p>

<h4>Part 4</h4>

<p>下边是腾讯初级工程师面试题</p>

<p>1。简述push原理，push的证书和其它的右什么不一样？
2。viewcontroller的一些方法的说明viewDidLoad, viewWillDisappear, viewWillAppear方法的 顺序和 作用？
3。frame 和 bounds 的 区别 ，bound的大小改变frame 改变吗？
4。sqlite中插入特殊字符的方法和接收到处理方法。
5。谈谈你对数组和连表认识，还有你是怎么用他们的？
6。冒泡算法。
7。socket编程简述
8。asihttp代码原理 ，异步请求的原理，异步请求最大数目，为什么只能这么多？
9。http请求方式？
10。uiview的圆角属性设置方法。
（m_mainImgView.layer.cornerRadius = 6;
m_mainImgView.layer.masksToBounds = YES;）
11。 masksToBounds属性的作用。（决定子layer是否被当前layer的边界剪切。默认是NO。）</p>

<p>1Objective－C内部的实现
2CALayer和View的关系
3 http协议，tcp/ip
4 UITableView的那些元素是可以自定义的？
5 c语言的，定义变量，比如int，在什么情况下，其最大值是不同的
6 比较32位平台和64位平台不同
7 iphone app为什么会被打回来，如何避免??
8 为啥离开团队？
1.针对第一个问题，可以看看下面的教程</p>

<p>Object c研究的比较深入的教程</p>

<p><a href="http://www.cnblogs.com/yaski/">http://www.cnblogs.com/yaski/</a></p>

<p>第6章写的尤其好</p>

<p><a href="http://archive.cnblogs.com/a/1886332/">KVO/KVC 实现机理分析</a></p>

<p>2.CALayer和View的关系
一个UIView包含CALayer树，CALayer是一个数据模型，包含了一些用于显示的对象，但本身不用于显示。</p>

<p>CALayer相当于photoshop的一个层，很多动画可以通过设置CALayer来实现。据说有人用CALayer显示图片来播放视频。</p>

<p>Core animation应该是用CAlayer来实现各种动画。</p>

<h4>Part 5</h4>

<p>下面都是很基础的问题</p>

<h5>1、Object-C有多继承吗？没有的话用什么代替？cocoa 中所有的类都是NSObject 的子类</h5>

<p>多继承在这里是用protocol 委托代理 来实现的</p>

<p>你不用去考虑繁琐的多继承 ,虚基类的概念.</p>

<p>ood的多态特性 在 obj-c 中通过委托来实现.</p>

<h5>2、Object-C有私有方法吗？私有变量呢？</h5>

<p>objective-c – 类里面的方法只有两种, 静态方法和实例方法. 这似乎就不是完整的面向对象了,按照OO的原则就是一个对象只暴露有用的东西. 如果没有了私有方法的话, 对于一些小范围的代码重用就不那么顺手了. 在类里面声名一个私有方法</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface Controller : NSObject { NSString *something; }
</span><span class='line'>+ (void)thisIsAStaticMethod;
</span><span class='line'>– (void)thisIsAnInstanceMethod;
</span><span class='line'>@end
</span><span class='line'>@interface Controller (private) -
</span><span class='line'>(void)thisIsAPrivateMethod;
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>@private可以用来修饰私有变量</p>

<p>在Objective‐C中，所有实例变量默认都是私有的，所有实例方法默认都是公有的</p>

<h5>3、关键字const什么含义？</h5>

<p>const意味着”只读”，下面的声明都是什么意思？</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>const int a;
</span><span class='line'>int const a;
</span><span class='line'>const int *a;
</span><span class='line'>int * const a;
</span><span class='line'>int const * a const;</span></code></pre></td></tr></table></div></figure>


<p>前两个的作用是一样，a是一个常整型数。第三个意味着a是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。第四个意思a是一个指向整 型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型 数是不可修改的，同时指针也是不可修改的）。</p>

<p>结论：</p>

<p>•; 关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用const的程序员很少会留下的垃圾让别人来清理的。）</p>

<p>•; 通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。</p>

<p>•; 合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。</p>

<p>欲阻止一个变量被改变，可以使用 const 关键字。在定义该 const 变量时，通常需要对它进行初</p>

<p>始化，因为以后就没有机会再去改变它了；</p>

<p>（2）对指针来说，可以指定指针本身为 const，也可以指定指针所指的数据为 const，或二者同时指定为 const；</p>

<p>（3）在一个函数声明中，const 可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；</p>

<p>（4）对于类的成员函数，若指定其为 const 类型，则表明其是一个常函数，不能修改类的成员变量；</p>

<p>（5）对于类的成员函数，有时候必须指定其返回值为 const 类型，以使得其返回值不为“左值”。</p>

<h5>4、关键字volatile有什么含义？并给出三个不同例子？</h5>

<p>一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到</p>

<p>这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：</p>

<p>并行设备的硬件寄存器（如：状态寄存器）</p>

<p>一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)</p>

<p>多线程应用中被几个任务共享的变量</p>

<p>一个参数既可以是const还可以是volatile吗？解释为什么。</p>

<p>一个指针可以是volatile 吗？解释为什么。</p>

<p>下面是答案：</p>

<p>是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。</p>

<p>是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。</p>

<h5>5.static作用？</h5>

<p>函数体内 static 变量的作用范围为该函数体，不同于 auto 变量，该变量的内存只被分配一次，</p>

<p>因此其值在下次调用时仍维持上次的值；</p>

<p>（2）在模块内的 static 全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；</p>

<p>（3）在模块内的 static 函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明</p>

<p>它的模块内；</p>

<p>（4）在类中的 static 成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；</p>

<p>（5）在类中的 static 成员函数属于整个类所拥有，这个函数不接收 this 指针，因而只能访问类的static 成员变量。</p>

<h5>6、#import和#include的区别，@class代表什么？</h5>

<p>@class一般用于头文件中需要声明该类的某个实例变量的时候用到，在m文件中还是需要使用#import</p>

<p>而#import比起#include的好处就是不会引起重复包含</p>

<h5>7、线程和进程的区别？</h5>

<p>进程和线程都是由操作系统所体会的程序运行的基本单元，系统利用该基本单元实现系统对应用的并发性。</p>

<p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一 个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程 序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p>

<h5>8、堆和栈的区别？</h5>

<p>管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。</p>

<p>申请大小：</p>

<p>栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因 此，能从栈获得的空间较小。</p>

<p>堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</p>

<p>碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出</p>

<p>分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。</p>

<p>分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的。</p>

<h5>9、Object-C的内存管理？</h5>

<p>1.当你使用new,alloc和copy方法创建一个对象时,该对象的保留计数器值为1.当你不再使用该对象时,你要负责向该对象发送一条release或autorelease消息.这样,该对象将在使用寿命结束时被销毁.</p>

<p>2.当你通过任何其他方法获得一个对象时,则假设该对象的保留计数器值为1,而且已经被设置为自动释放,你不需要执行任何操作来确保该对象被清理.如果你打算在一段时间内拥有该对象,则需要保留它并确保在操作完成时释放它.</p>

<p>3.如果你保留了某个对象,你需要(最终)释放或自动释放该对象.必须保持retain方法和release方法的使用次数相等.</p>

<h5>10、为什么很多内置的类，如TableViewController的delegate的属性是assign不是retain？</h5>

<p>循环引用</p>

<p>所有的引用计数系统，都存在循环应用的问题。例如下面的引用关系：</p>

<p>对象a创建并引用到了对象b.</p>

<p>对象b创建并引用到了对象c.</p>

<p>对象c创建并引用到了对象b.</p>

<p>这时候b和c的引用计数分别是2和1。当a不再使用b，调用release释放对b的所有权，因为c还引用了b，所以b的引用计数为1，b不会被释放。b不释放，c的引用计数就是1，c也不会被释放。从此，b和c永远留在内存中。</p>

<p>这种情况，必须打断循环引用，通过其他规则来维护引用关系。比如，我们常见的delegate往往是assign方式的属性而不是retain方式的属 性，赋值不会增加引用计数，就是为了防止delegation两端产生不必要的循环引用。如果一个UITableViewController 对象a通 过retain获取了UITableView对象b的所有权，这个UITableView对象b的delegate又是a，如果这个delegate是 retain方式的，那基本上就没有机会释放这两个对象了。自己在设计使用delegate模式时，也要注意这点。</p>

<h5>11、定义属性时，什么情况使用copy、assign、retain？</h5>

<p>assign用于简单数据类型，如NSInteger,double,bool,</p>

<p>retain和copy用于对象，</p>

<p>copy用于当a指向一个对象，b也想指向同样的对象的时候，如果用assign，a如果释放，再调用b会crash,如果用copy 的方式，a和b各自有自己的内存，就可以解决这个问题。</p>

<p>retain 会使计数器加一，也可以解决assign的问题。</p>

<p>另外：atomic和nonatomic用来决定编译器生成的getter和setter是否为原子操作。在多线程环境下，原子操作是必要的，否则有可能引起错误的结果。</p>

<p>加了atomic，setter函数会变成下面这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (property != newValue) {
</span><span class='line'>  [property release];
</span><span class='line'>  property = [newValue retain];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>12、对象是什么时候被release的？</h5>

<p>引用计数为0时。</p>

<p>autorelease实际上只是把对release的调用延迟了，对于每一个Autorelease，系统只是把该Object放入了当前的 Autorelease pool中，当该pool被释放时，该pool中的所有Object会被调用Release。对于每一个Runloop，系统会 隐式创建一个Autorelease pool，这样所有的release pool会构成一个象CallStack一样的一个栈式结构，在每一个 Runloop结束时，当前栈顶的Autorelease pool会被销毁，这样这个pool里的每个Object（就是autorelease的对 象）会被release。那什么是一个Runloop呢？一个UI事件，Timer call， delegate call， 都会是一个新的 Runloop</p>

<h5>13、iOS有没有垃圾回收？</h5>

<p>Objective-C 2.0也是有垃圾回收机制的，但是只能在Mac OS X Leopard 10.5 以上的版本使用。</p>

<h5>14、tableView的重用机制？</h5>

<p>查看UITableView头文件，会找到NSMutableArray<em>  visiableCells，和 NSMutableDictnery</em> reusableTableCells两个结构。visiableCells内保存当前显示的 cells，reusableTableCells保存可重用的cells。</p>

<p>TableView显示之初，reusableTableCells为空，那么 tableView dequeueReusableCellWithIdentifier:CellIdentifier返回nil。开始的cell都 是通过</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier] </span></code></pre></td></tr></table></div></figure>


<p>来创建，而且cellForRowAtIndexPath只是调用最大显示cell数的次数。</p>

<p>比如：有100条数据，iPhone一屏最多显示10个cell。程序最开始显示TableView的情况是：</p>

<p>1.用 [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier] 创建10次cell，并给cell指定同样的重用标识(当然，可以为不同显示类型的cell指定不同的标识)。并且10个cell全部都加入到 visiableCells数组，reusableTableCells为空。</p>

<p>2.向下拖动tableView，当cell1完全移出屏幕，并且cell11(它也是alloc出来的，原因同上)完全显示出来的时候。 cell11加入到visiableCells，cell1移出visiableCells，cell1加入到reusableTableCells。</p>

<p>3.接着向下拖动tableView，因为reusableTableCells中已经有值，所以，当需要显示新的 cell，cellForRowAtIndexPath再次被调用的时 候，tableView dequeueReusableCellWithIdentifier:CellIdentifier，返回cell1。 cell1加入到visiableCells，cell1移出reusableTableCells；cell2移出 visiableCells，cell2加入到reusableTableCells。之后再需要显示的Cell就可以正常重用了。</p>

<h5>15、ViewController 的loadView、viewDidLoad、viewDidUnload分别是什么时候调用的，在自定义ViewCointroller时在这几个函数中应该做什么工作？</h5>

<p>由init、loadView、viewDidLoad、viewDidUnload、dealloc的关系说起</p>

<p>init方法</p>

<p>在init方法中实例化必要的对象（遵从LazyLoad思想）</p>

<p>init方法中初始化ViewController本身</p>

<p>loadView方法</p>

<p>当view需要被展示而它却是nil时，viewController会调用该方法。不要直接调用该方法。</p>

<p>如果手工维护views，必须重载重写该方法</p>

<p>如果使用IB维护views，必须不能重载重写该方法</p>

<p>loadView和IB构建view</p>

<p>你在控制器中实现了loadView方法，那么你可能会在应用运行的某个时候被内存管理控制调用。 如果设备内存不足的时候， view 控制器会收到 didReceiveMemoryWarning的消息。 默认的实现是检查当前控制器的view是否在使用。如果它的view不在当前正在使用的 view hierarchy里面，且你的控制器实现了loadView方法，那么这个view将被release, loadView方法将被再次调用 来创建一个新的view。</p>

<p>viewDidLoad方法</p>

<p>viewDidLoad 此方法只有当view从nib文件初始化的时候才被调用。</p>

<p>重载重写该方法以进一步定制view</p>

<p>在iPhone OS 3.0及之后的版本中，还应该重载重写viewDidUnload来释放对view的任何索引</p>

<p>viewDidLoad后调用数据Model</p>

<p>viewDidUnload方法</p>

<p>当系统内存吃紧的时候会调用该方法（注：viewController没有被dealloc）</p>

<p>内存吃紧时，在iPhone OS 3.0之前didReceiveMemoryWarning是释放无用内存的唯一方式，但是OS 3.0及以后viewDidUnload方法是更好的方式</p>

<p>在该方法中将所有IBOutlet（无论是property还是实例变量）置为nil（系统release view时已经将其release掉了）</p>

<p>在该方法中释放其他与view有关的对象、其他在运行时创建（但非系统必须）的对象、在viewDidLoad中被创建的对象、缓存数据 等 release对象后，将对象置为nil（IBOutlet只需要将其置为nil，系统release view时已经将其release掉了）</p>

<p>一般认为viewDidUnload是viewDidLoad的镜像，因为当view被重新请求时，viewDidLoad还会重新被执行</p>

<p>viewDidUnload中被release的对象必须是很容易被重新创建的对象（比如在viewDidLoad或其他方法中创建的对象），不要release用户数据或其他很难被重新创建的对象</p>

<p>dealloc方法</p>

<p>viewDidUnload和dealloc方法没有关联，dealloc还是继续做它该做的事情</p>

<h5>16、ViewController的didReceiveMemoryWarning是在什么时候调用的？默认的操作是什么？</h5>

<p>当程序接到内存警告时View Controller将会收到这个消息：didReceiveMemoryWarning</p>

<p>从iOS3.0开始，不需要重载这个函数，把释放内存的代码放到viewDidUnload中去。</p>

<p>这个函数的默认实现是:检查controller是否可以安全地释放它的view(这里加粗的view指的是controller的view属性)，比如view本身没有superview并且可以被很容易地重建（从nib或者loadView函数）。</p>

<p>如果view可以被释放，那么这个函数释放view并调用viewDidUnload。</p>

<p>你可以重载这个函数来释放controller中使用的其他内存。但要记得调用这个函数的super实现来允许父类（一般是UIVIewController）释放view。</p>

<p>如果你的ViewController保存着view的子view的引用，那么，在早期的iOS版本中，你应该在这个函数中来释放这些引用。而在iOS3.0或更高版本中，你应该在viewDidUnload中释放这些引用。</p>

<h5>17、列举Cocoa中常见的集中多线程的实现，并谈谈多线程安全的几种解决办法，一般什么地方会用到多线程？</h5>

<p>NSThread,GCD等。尽量用上层分装好的方法去实现多线程而不是手动调用NSThread。</p>

<h5>18、怎么理解MVC，在Cocoa中MVC是怎么实现的？</h5>

<p>Model: 代表你的应用程序是什么（不是怎么展现）</p>

<p>Controller: 控制你的Model怎么展现给用户（UI逻辑）</p>

<p>View: Controller的奴隶。。。</p>

<p>1 Model，Controller，View相互通讯的规则：</p>

<p>Controller可以直接和Model通信</p>

<p>Controller也可以直接和View通信</p>

<p>Model和View永远不能直接通信</p>

<p>iOS中View和Controller的通信是透明和固定的，主要通过outlet和action实现</p>

<p>View使用Delegate接口和Controller同步信息</p>

<p>View不直接和数据通信，使用dataSource接口从Controller处获取数据</p>

<p>View的delegate和dataSource一般就是Controller</p>

<p>Controller负责为View翻译和格式化Model的数据</p>

<p>Model使用Notification &amp; KVO的方式分发数据更新信息，Controller可以有选择的监听自己感兴趣的信息。</p>

<p>View也可以监听广播信息，但一般不是Model发出的信息</p>

<p>一个完整的App就是很多MVC的集合</p>

<h5>19、delegate和notification区别，分别在什么情况下使用？</h5>

<p>Delegate:</p>

<p>消息的发送者(sender)告知接收者(receiver)某个事件将要发生，delegate同意然然后发送者响应事件，delegate机制使得接收者可以改变发送者的行为。通常发送者和接收者的关系是直接的一对多的关系。</p>

<p>Notification:</p>

<p>消息的发送者告知接收者事件已经发生或者将要发送，仅此而已，接收者并不能反过来影响发送者的行为。通常发送者和接收者的关系是间接的多对多关系。</p>

<ol>
<li><p>效率肯定是delegate比nsnotification高。</p></li>
<li><p>delegate方法比notification更加直接，最典型的特征是，delegate方法往往需要关注返回值，也就是delegate方法 的结果。比如-windowShouldClose:，需要关心返回的是yes还是no。所以delegate方法往往包含should这个很传神的词。 也就是好比你做我的delegate，我会问你我想关闭窗口你愿意吗？你需要给我一个答案，我根据你的答案来决定如何做下一步。相反 的，notification最大的特色就是不关心接受者的态度，我只管把通告放出来，你接受不接受就是你的事情，同时我也不关心结果。所以 notification往往用did这个词汇，比如NSWindowDidResizeNotification，那么nswindow对象放出这个 notification后就什么都不管了也不会等待接受者的反应。</p></li>
</ol>


<p>1）两个模块之间联系不是很紧密，就用notification传值，例如多线程之间传值用notificaiton。</p>

<p>2）delegate只是一种较为简单的回调，且主要用在一个模块中，例如底层功能完成了，需要把一些值传到上层去，就事先把上层的函数通过 delegate传到底层，然后在底层call这个delegate，它们都在一个模块中，完成一个功能，例如 说 NavgationController 从 B 界面到A 点返回按钮 (调用popViewController方法) 可以用delegate 比较好。</p>

<h5>20、self.跟self什么区别？</h5>

<h5>21、id、nil代表什么？</h5>

<p>id和void <em>并非完全一样。在上面的代码中，id是指向struct objc_object的一个指针，这个意思基本上是说，id是一个指向任何 一个继承了Object（或者NSObject）类的对象。需要注意的是id是一个指针，所以你在使用id的时候不需要加星号。比如id foo=nil 定义了一个nil指针，这个指针指向NSObject的一个任意子类。而id </em>foo=nil则定义了一个指针，这个指针指向另一个指针，被指向的这个 指针指向NSObject的一个子类。</p>

<p>nil和C语言的NULL相同，在objc/objc.h中定义。nil表示一个Objctive-C对象，这个对象的指针指向空（没有东西就是空）。</p>

<p>首字母大写的Nil和nil有一点不一样，Nil定义一个指向空的类（是Class，而不是对象）。</p>

<p>SEL是“selector”的一个类型，表示一个方法的名字</p>

<p>Method（我们常说的方法）表示一种类型，这种类型与selector和实现(implementation)相关</p>

<p>IMP定义为 id (*IMP) (id, SEL, …)。这样说来， IMP是一个指向函数的指针，这个被指向的函数包括id(“self”指针)，调用的SEL（方法名），再加上一些其他参数.说白了IMP就是实现方法。</p>

<h5>22、内存管理 Autorelease、retain、copy、assign的set方法和含义？</h5>

<p>1，你初始化(alloc/init)的对象，你需要释放(release)它。例如：</p>

<p>NSMutableArray aArray = [[NSArray alloc] init]; 后，需要 [aArray release];</p>

<p>2，你retain或copy的，你需要释放它。例如：</p>

<p>[aArray retain] 后，需要 [aArray release];</p>

<p>3，被传递(assign)的对象，你需要斟酌的retain和release。例如：</p>

<p>obj2 = [[obj1 someMethod] autorelease];</p>

<p>对象2接收对象1的一个自动释放的值，或传递一个基本数据类型(NSInteger，NSString)时：你或希望将对象2进行retain，以防止它在被使用之前就被自动释放掉。但是在retain后，一定要在适当的时候进行释放。</p>

<p>关于索引计数(Reference Counting)的问题</p>

<p>retain值 = 索引计数(Reference Counting)</p>

<p>NSArray对象会retain(retain值加一)任何数组中的对象。当NSArray被卸载(dealloc)的时候，所有数组中的对象会被 执行一次释放(retain值减一)。不仅仅是NSArray，任何收集类(Collection Classes)都执行类似操作。例如 NSDictionary，甚至UINavigationController。</p>

<p>Alloc/init建立的对象，索引计数为1。无需将其再次retain。</p>

<p>[NSArray array]和[NSDate date]等“方法”建立一个索引计数为1的对象，但是也是一个自动释放对象。所以是本地临时对象，那么无所谓了。如果是打算在全Class中使用的变量(iVar)，则必须retain它。</p>

<p>缺省的类方法返回值都被执行了“自动释放”方法。(*如上中的NSArray)</p>

<p>在类中的卸载方法“dealloc”中，release所有未被平衡的NS对象。(*所有未被autorelease，而retain值为1的)</p>

<h5>23、类别的作用？</h5>

<p>有时我们需要在一个已经定义好的类中增加一些方法，而不想去重写该类。比如，当工程已经很大，代码量比较多，或者类中已经包住很多方法，已经有其他代码调用了该类创建对象并使用该类的方法时，可以使用类别对该类扩充新的方法。</p>

<p>注意：类别只能扩充方法，而不能扩充成员变量。</p>

<h5>24、委托（举例）</h5>

<p>委托代理（degegate），顾名思义，把某个对象要做的事情委托给别的对象去做。那么别的对象就是这个对象的代理，代替它来打理要做的事。反映到程序中，首先要明确一个对象的委托方是哪个对象，委托所做的内容是什么。</p>

<p>委托机制是一种设计模式，在很多语言中都用到的，这只是个通用的思想，网上会有很多关于这方面的介绍。</p>

<p>那么在苹果开发过程中，用到委托的程序实现思想如下，我主要拿如何在视图之间传输信息做个例子。</p>

<p>譬如：在两个页面（UIIview视图对象）实现传值，用委托（delegate）可以很好做到！</p>

<p>方法：</p>

<p>类A</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface A：UIView
</span><span class='line'>id transparendValueDelegate;
</span><span class='line'>@property(nomatic, retain) id transparendValueDelegate;
</span><span class='line'>@end
</span><span class='line'>@implemtion A
</span><span class='line'>@synthesize transparendValueDelegate
</span><span class='line'>-(void)Function
</span><span class='line'>{
</span><span class='line'>  NSString* value = @”hello”;
</span><span class='line'>  //让代理对象执行transparendValue动作
</span><span class='line'>  [transparendValueDelegate transparendValue: value];
</span><span class='line'>}
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>类B</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface B：UIView
</span><span class='line'>NSString* value;
</span><span class='line'>@end
</span><span class='line'>@implemtion B
</span><span class='line'>-(void)transparendValue:(NSString*)fromValue
</span><span class='line'>{
</span><span class='line'>  value = fromValue;
</span><span class='line'>  NSLog(@”the value is %@ “,value);
</span><span class='line'>}
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>//下面的设置A代理委托对象为B</p>

<p>//在定义A和B类对象处：</p>

<p>A* a = [[A alloc] init];</p>

<p>B* b = [[B alloc] init];</p>

<ol type="a">
<li>transparendValueDelegate = b;//设置对象a代理为对象b</li>
</ol>


<p>这样在视图A和B之间可以通过委托来传值！</p>

<h5>25、retainCount？</h5>

<h5>26.属性readwrite，readonly，assign，retain，copy，nonatomic 各是什么作用，在那种情况下用</h5>

<p>assign：指定setter方法用简单的赋值，这是默认操作。你可以对标量类型（如int）使用这个属性。你可以想象一个float，它不是一个对象，所以它不能retain、copy。</p>

<p>retain：指定retain应该在后面的对象上调用，前一个值发送一条release消息。你可以想象一个NSString实例，它是一个对象，而且你可能想要retain它。</p>

<p>copy：指定应该使用对象的副本（深度复制），前一个值发送一条release消息。基本上像retain，但是没有增加引用计数，是分配一块新的内存来放置它。</p>

<p>readonly：将只生成getter方法而不生成setter方法（getter方法没有get前缀）。</p>

<p>readwrite：默认属性，将生成不带额外参数的getter和setter方法（setter方法只有一个参数）。</p>

<p>atomic：对于对象的默认属性，就是setter/getter生成的方法是一个原子操作。如果有多个线程同时调用setter的话，不会出现某一个线程执行setter全部语句之前，另一个线程开始执行setter的情况，相关于方法头尾加了锁一样。</p>

<p>nonatomic：不保证setter/getter的原子性，多线程情况下数据可能会有问题。</p>

<h5>27.类变量的@protected ,@private ,@public ,@package声明各有什么含义</h5>

<p>Objective-C 对存取权限的设定。也是变量的作用域。</p>

<p>protected 该类和所有的子类中的方法可以直接访问这样的变量，这是默认的。</p>

<p>private — 该类中的方法可以访问这样的变量，子类不可以。 public — 除了自己和子类中的方法外，也可以被其他类或者其他模块中的方法所访问。开放性最大。 package — 对于64位图像，这样的成员变量可以在实现这个类的图像中随意访问。</p>

<h5>28.浅拷贝和深拷贝区别是什么</h5>

<p>简单的来说就是，在有指针的情况下，浅拷贝只是增加了一个指针指向已经存在的内存，而深拷贝就是增加一个指针并且申请一个新的内存，使这个增加的指针指向这个新的内存，采用深拷贝的情况下，释放内存的时候就不会出现在浅拷贝时重复释放同一内存的错误</p>

<h5>29.Cocoa中与虚基类的概念么？怎么简洁的实现</h5>

<h5>30.NSString 和 NSMutableString 有什么区别</h5>

<p>NSString相当于一个const char* 不可以改变。</p>

<p>而 NSMutableString相当于 char* 可以改变内部的内容。</p>

<h5>31.自动释放池跟GC有什么区别？iPhone上有GC么？［pool release］ 和［pool drain］有什么区别</h5>

<p>”Autorelease Pools”(自动释放池)在应用中的使用技巧。</p>

<p>1，Autorelease Pools概要</p>

<p>一个”Autorelease Pool”实例中“包含”其它各种调用了”autorelease”方法的对象。当它释放时，其中所有被管理对象都会收 到”relrease”的消信。注意，同一个对象可以被多次调用”autorelease”方法，并可以放到同一个”Autorelease Pool” 中。引入这个自动释放池机制，对象的”autorelease”方法代替”relrease”方法可以延长它的生命周期，直接到当 前”Autorelrease Pool”释放。如果想让此对象的生命周期超过”Autorelease Pool”，还可以再次”retain”，呵 呵，有意思吧?且让我慢慢道来。</p>

<p>Cocoa总是认为当前至少有一个”Autorelease Pool”对象是可用的。若此对象并不存在，你调用的”autorelease”的所有对象都不会被自动释放掉，可想而知，造成内存泄露。Cocoa把这个错误信息写入日志??仅仅是为了以后分析。</p>

<p>你可以用”alloc”与”init”方法创建一个”NSAutoreleasePool”对象，并且可以调用”release”或”drain” （”release”与”drain”的区别是”drain”在有GC的环境中会引起GC回收操作，”release”反之。但在非GC环境中，两者相 同。官方的说法是为了程序的兼容性，应该考虑用”drain”代替”release”，）方法来回收它（调用它的”autorelease” 或”retain”方法会引起异常）。在一个完整的上下文最后”Autorelease Pool”对象应该被”release”掉（在方法内或一段循环 体内创建的”Autorelease Pool”对象）。</p>

<p>“Autorelease Pools”的所有实例在栈中管理（我们暂时叫他“自动释放池栈”），并且它们是可以被嵌套的（父生子，子生孙。。。子子孙 孙 ^_^）。例如，当我们创建一个”Autorelease Pool”对象后，它就被自动放到“自动释放池栈”的栈顶。当本池对象回收时，它就随之从 这个栈中POP掉。那么也就是说，当任何一个对象调用”autorelease”方法后，它会被放入当前线程中当前栈顶的自动释放池中。</p>

<p>接下来我们聊聊”Autorelease Pools”的嵌套问题。在你的应用中，你可以任意多的创建”Autorelease Pool”对象，而这些 对象被当前线程的“自动释放池栈”所管理。那么除了一个接一个的顺序创建并销毁它的情况外，还有一种使用方式，就是嵌套式的创建与使用。例如：在你的主函 数创建了一个”autorelease pool”，然后又调用了创建了”autorelease pool”实例的其它方法；或是在外循环中创建 了”Autorelease Pool”的实例，而内循环中也做了相同的事情。有意思吧，呵呵，嵌套的机制使父Pool实例释放后，它的所有子Pool也 将释放。但这里还存在一些副作用，后续文章会详细讨论。</p>

<p>“Application kit”在一个事件循环里会自动创建一个”autorelease pool”。像鼠标键的按下与释放，所以你编写的代码通常不需要考虑太多这方面的事情。当然，有以下三种情况你会创建与销毁自己的Pool实例：</p>

<p>1，应用不是基于”Application Kit”，像”Command-line tool”，因为它并没有内置的”autorelease pools”的支持。</p>

<p>2，创建线程，你必需在线程开始时创建一个”Autorelease Pool”实例。反之，会造成内存池露（会在以后的文章详细说明线程与池的技巧）。</p>

<p>3，一个循环内创建了太多的临时对象，你应该为他们创建一个”Autorelease Pool”对象，并在下次循还前销毁它们。</p>

<p>2，自动释放池中的”Non-AppKit”应用</p>

<p>在”Non-AppKit”应用中使用自动释放池的机制其实是相当简单的事情。你仅仅需要在main()起始处创建”Autorelease Pool” 对象，并在结尾处释放掉它。就像在Xcode的Foundation Tool的创建模版里写的一样。这个确保你在应用生命周期内至少有一 个”Autorelease Pool”是可用的。但是，这也使所有在此期间的所有”autorelease”的对象都必需在应用结束后才被释放。这也许 会引起在应用的使用中不断的增长，所以，你仍然考虑在不同的作用域创建新的”Autorelease Pool”。</p>

<p>大多应用中都存在各种级别的循环机制。在这些应用中，你可以在每个循环内的开头创建一个”Autorelease Pool”对象，并在结尾处释放掉它。</p>

<p>例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void main()
</span><span class='line'>{
</span><span class='line'>  NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
</span><span class='line'>  NSArray *args = [[NSProcessInfo processInfo] arguments];
</span><span class='line'>  unsigned count, limit = [args count];
</span><span class='line'>  for (count = 0; count &lt; limit; count++)
</span><span class='line'>  {
</span><span class='line'>  NSAutoreleasePool *loopPool = [[NSAutoreleasePool alloc] init];
</span><span class='line'>  NSString *fileContents;
</span><span class='line'>  NSString *fileName;
</span><span class='line'>  fileName = [args objectAtIndex:count];
</span><span class='line'>  fileContents = [[[NSString alloc] initWithContentsOfFile:fileName] autorelease];
</span><span class='line'>  // this is equivalent to using stringWithContentsOfFile:
</span><span class='line'>  [loopPool release];
</span><span class='line'>  }
</span><span class='line'>  [pool drain];
</span><span class='line'>  exit (EXIT_SUCCESS);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在命令行中处理所有以参数传来的文件。一次循环处理一个文件。在循环的开头创建一个”NSAutoreleasePool”对象，并在循环结束时释放掉。 因此，任何在其中创建并调用“autorelease”的对象都将添加到这个Pool实例中，当本池被释放后，这些对象也将被回收。注意，任何在作用域内 创建的”autoreleased”对象（像”fileName”），虽然并没有显示的调用”autorelease”方法，但都将被当前池所管理并释 放。</p>

<h5>32.C和obj-c 如何混用</h5>

<p>1）obj-c的编译器处理后缀为m的文件时，可以识别obj-c和c的代码，处理mm文件可以识别obj-c,c,c++代码，但cpp文件必须只能用c/c++代码，而且cpp文件include的头文件中，也不能出现obj-c的代码，因为cpp只是cpp</p>

<p>2)在mm文件中混用cpp直接使用即可，所以obj-c混cpp不是问题</p>

<p>3）在cpp中混用obj-c其实就是使用obj-c编写的模块是我们想要的。</p>

<p>如果模块以类实现，那么要按照cpp class的标准写类的定义，头文件中不能出现obj-c的东西，包括#import cocoa的。实现文件中，即类的实现代码中可以使用obj-c的东西，可以import,只是后缀是mm。</p>

<p>如果模块以函数实现，那么头文件要按c的格式声明函数，实现文件中，c++函数内部可以用obj-c，但后缀还是mm或m。</p>

<p>总结：只要cpp文件和cpp include的文件中不包含obj-c的东西就可以用了，cpp混用obj-c的关键是使用接口，而不能直接使用实现代 码，实际上cpp混用的是obj-c编译后的o文件，这个东西其实是无差别的，所以可以用。obj-c的编译器支持cpp</p>

<h5>33.响应者链是什么</h5>

<p>响应者链是Application Kit事件处理架构的中心机制。它由一系列链接在一起的响应者对象组成，事件或者动作消息可以沿着这些对象进行传 递。如图6-20显示的那样，如果一个响应者对象不能处理某个事件或动作－也就是说，它不响应那个消息，或者不认识那个事件，则将该消息重新发送给链中的 下一个响应者。消息沿着响应者链向上、向更高级别的对象传递，直到最终被处理（如果最终还是没有被处理，就会被抛弃）。</p>

<p>当Application Kit在应用程序中构造对象时，会为每个窗口建立响应者链。响应者链中的基本对象是NSWindow对象及其视图层次。在视图层次中级别较低的视图将比级别更高的视图优先获得处理事件或动作消息的机会。NSWindow中保有一个第一响应者的引用，它通常是当前窗口中处于选择状态的视图，窗口通常把响应消息的机会首先给它。对于事件消息，响应者链通常以发生事件的窗口对应的NSWindow对象作为结束，虽然其它对象也可以作为下一个响应者被加入到NSWindow对象的后面。</p>

<h5>34..UIscrollVew用到了什么设计模式？还能再foundation库中找到类似的吗？</h5>

<p>组合模式composition，所有的container view都用了这个模式</p>

<p>观察者模式observer，所有的UIResponder都用了这个模式。</p>

<p>模板(Template)模式，所有datasource和delegate接口都是模板模式的典型应用</p>

<h5>33. .timer的间隔周期准吗？为什么？怎样实现一个精准的timer?</h5>

<p>NSTimer可以精确到50-100毫秒.</p>

<p>NSTimer不是绝对准确的,而且中间耗时或阻塞错过下一个点,那么下一个点就pass过去了</p>

<p>此份面试题包含40个题目，是现在网上能搜索到的一个比较热的一份，但是答案并不是很详细和完整，基本答案来着cocoaChina，和一些自己的补充。</p>

<h5>34.Difference between shallow copy and deep copy?</h5>

<p>浅复制和深复制的区别？</p>

<p>答案：浅层复制：只复制指向对象的指针，而不复制引用对象本身。</p>

<p>深层复制：复制引用对象本身。</p>

<p>意思就是说我有个A对象，复制一份后得到A_copy对象后，对于浅复制来说，A和A_copy指向的是同一个内存资源，复制的只不过是是一个指针，对象本身资源</p>

<p>还是只有一份，那如果我们对A_copy执行了修改操作,那么发现A引用的对象同样被修改，这其实违背了我们复制拷贝的一个思想。深复制就好理解了,内存中存在了</p>

<p>两份独立对象本身。</p>

<p>用网上一哥们通俗的话将就是：</p>

<p>浅复制好比你和你的影子，你完蛋，你的影子也完蛋</p>

<p>深复制好比你和你的克隆人，你完蛋，你的克隆人还活着。</p>

<h5>35.What is advantage of categories? What is difference between implementing a category and inheritance?</h5>

<p>类别的作用？继承和类别在实现中有何区别？</p>

<p>答案：category 可以在不获悉，不改变原来代码的情况下往里面添加新的方法，只能添加，不能删除修改。</p>

<p>并且如果类别和原来类中的方法产生名称冲突，则类别将覆盖原来的方法，因为类别具有更高的优先级。</p>

<p>类别主要有3个作用：</p>

<p>(1)将类的实现分散到多个不同文件或多个不同框架中。</p>

<p>(2)创建对私有方法的前向引用。</p>

<p>(3)向对象添加非正式协议。</p>

<p>继承可以增加，修改或者删除方法，并且可以增加属性。</p>

<h5>36.Difference between categories and extensions?</h5>

<p>类别和类扩展的区别。</p>

<p>答案：category和extensions的不同在于后者可以添加属性。另外后者添加的方法是必须要实现的。</p>

<p>extensions可以认为是一个私有的Category。</p>

<h5>37.Difference between protocol in objective c and interfaces in java?</h5>

<p>oc中的协议和java中的接口概念有何不同？</p>

<p>答案：OC中的代理有2层含义，官方定义为 formal和informal protocol。前者和Java接口一样。</p>

<p>informal protocol中的方法属于设计模式考虑范畴，不是必须实现的，但是如果有实现，就会改变类的属性。</p>

<p>其实关于正式协议，类别和非正式协议我很早前学习的时候大致看过，也写在了学习教程里</p>

<p>“非正式协议概念其实就是类别的另一种表达方式“这里有一些你可能希望实现的方法，你可以使用他们更好的完成工作”。</p>

<p>这个意思是，这些是可选的。比如我门要一个更好的方法，我们就会申明一个这样的类别去实现。然后你在后期可以直接使用这些更好的方法。</p>

<p>这么看，总觉得类别这玩意儿有点像协议的可选协议。”</p>

<p>现在来看，其实protocal已经开始对两者都统一和规范起来操作，因为资料中说“非正式协议使用interface修饰“，</p>

<p>现在我们看到协议中两个修饰词：“必须实现(@requied)”和“可选实现(@optional)”。</p>

<h5>38.What are KVO and KVC?</h5>

<p>答案：kvc:键 - 值编码是一种间接访问对象的属性使用字符串来标识属性，而不是通过调用存取方法，直接或通过实例变量访问的机制。</p>

<p>很多情况下可以简化程序代码。apple文档其实给了一个很好的例子。</p>

<p>kvo:键值观察机制，他提供了观察某一属性变化的方法，极大的简化了代码。</p>

<p>具体用看到嗯哼用到过的一个地方是对于按钮点击变化状态的的监控。</p>

<p>比如我自定义的一个button</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[self addObserver:self forKeyPath:@"highlighted" options:0 context:nil];
</span><span class='line'>- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context
</span><span class='line'>{
</span><span class='line'>  if([keyPath isEqualToString:@"highlighted"] ) {
</span><span class='line'>  [self setNeedsDisplay];
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>对于系统是根据keypath去取的到相应的值发生改变，理论上来说是和kvc机制的道理是一样的。</p>

<p>对于kvc机制如何通过key寻找到value：</p>

<p>“当通过KVC调用对象时，比如：[self valueForKey:@”someKey”]时，程序会自动试图通过几种不同的方式解析这个调用。首先 查找对象是否带有 someKey 这个方法，如果没找到，会继续查找对象是否带有someKey这个实例变量（iVar），如果还没有找到，程序会继续 试图调用 -(id) valueForUndefinedKey:这个方法。如果这个方法还是没有被实现的话，程序会抛出一个 NSUndefinedKeyException异常错误。</p>

<p>(cocoachina.com注：Key-Value Coding查找方法的时候，不仅仅会查找someKey这个方法，还会查找 getsomeKey这个方法，前面加一个get，或者<em>someKey以及</em>getsomeKey这几种形式。同时，查找实例变量的时候也会不仅仅查找 someKey这个变量，也会查找_someKey这个变量是否存在。）</p>

<p>设计valueForUndefinedKey:方法的主要目的是当你使用-(id)valueForKey方法从对象中请求值时，对象能够在错误发生前，有最后的机会响应这个请求。这样做有很多好处，下面的两个例子说明了这样做的好处。“</p>

<p>来至cocoa，这个说法应该挺有道理。</p>

<p>因为我们知道button却是存在一个highlighted实例变量.因此为何上面我们只是add一个相关的keypath就行了，</p>

<p>可以按照kvc查找的逻辑理解，就说的过去了。</p>

<h5>39.What is purpose of delegates?</h5>

<p>代理的作用？</p>

<p>答案：代理的目的是改变或传递控制链。允许一个类在某些特定时刻通知到其他类，而不需要获取到那些类的指针。可以减少框架复杂度。</p>

<p>另外一点，代理可以理解为java中的回调监听机制的一种类似。</p>

<h5>40.What are mutable and immutable types in Objective C?</h5>

<p>oc中可修改和不可以修改类型。</p>

<p>答案：可修改不可修改的集合类。这个我个人简单理解就是可动态添加修改和不可动态添加修改一样。</p>

<p>比如NSArray和NSMutableArray。前者在初始化后的内存控件就是固定不可变的，后者可以添加等，可以动态申请新的内存空间。</p>

<h5>41.When we call objective c is runtime language what does it mean?</h5>

<p>我们说的oc是动态运行时语言是什么意思？</p>

<p>答案：多态。 主要是将数据类型的确定由编译时，推迟到了运行时。</p>

<p>这个问题其实浅涉及到两个概念，运行时和多态。</p>

<p>简单来说，运行时机制使我们直到运行时才去决定一个对象的类别，以及调用该类别对象指定方法。</p>

<p>多态：不同对象以自己的方式响应相同的消息的能力叫做多态。意思就是假设生物类（life）都用有一个相同的方法-eat;</p>

<p>那人类属于生物，猪也属于生物，都继承了life后，实现各自的eat，但是调用是我们只需调用各自的eat方法。</p>

<p>也就是不同的对象以自己的方式响应了相同的消息（响应了eat这个选择器）。</p>

<p>因此也可以说，运行时机制是多态的基础？~~~</p>

<h5>42.what is difference between NSNotification and protocol?</h5>

<p>通知和协议的不同之处？</p>

<p>答案：协议有控制链(has-a)的关系，通知没有。</p>

<p>首先我一开始也不太明白，什么叫控制链（专业术语了~）。但是简单分析下通知和代理的行为模式，我们大致可以有自己的理解</p>

<p>简单来说，通知的话，它可以一对多，一条消息可以发送给多个消息接受者。</p>

<p>代理按我们的理解，到不是直接说不能一对多，比如我们知道的明星经济代理人，很多时候一个经济人负责好几个明星的事务。</p>

<p>只是对于不同明星间，代理的事物对象都是不一样的，一一对应，不可能说明天要处理A明星要一个发布会，代理人发出处理发布会的消息后，别称B的</p>

<p>发布会了。但是通知就不一样，他只关心发出通知，而不关心多少接收到感兴趣要处理。</p>

<p>因此控制链（has-a从英语单词大致可以看出，单一拥有和可控制的对应关系。</p>

<h5>43.What is push notification?</h5>

<p>什么是推送消息？</p>

<p>答案：太简单，不作答~~~~~~~~~~</p>

<p>这是cocoa上的答案。</p>

<p>其实到不是说太简单，只是太泛泛的一个概念的东西。就好比说，什么是人。</p>

<p>推送通知更是一种技术。</p>

<p>简单点就是客户端获取资源的一种手段。</p>

<p>普通情况下，都是客户端主动的pull。</p>

<p>推送则是服务器端主动push。</p>

<h5>44.Polymorphism？</h5>

<p>关于多态性</p>

<p>答案：多态，子类指针可以赋值给父类。</p>

<p>这个题目其实可以出到一切面向对象语言中，</p>

<p>因此关于多态，继承和封装基本最好都有个自我意识的理解，也并非一定要把书上资料上写的能背出来。</p>

<p>最重要的是转化成自我理解。</p>

<h5>45.Singleton?</h5>

<p>对于单例的理解</p>

<p>答案：11，12题目其实出的有点泛泛的感觉了，可能说是编程语言需要或是必备的基础。</p>

<p>基本能用熟悉的语言写出一个单例，以及可以运用到的场景或是你编程中碰到过运用的此种模式的框架类等。</p>

<p>进一步点，考虑下如何在多线程访问单例时的安全性。</p>

<h5>46.What is responder chain?</h5>

<p>说说响应链</p>

<p>答案： 事件响应链。包括点击事件，画面刷新事件等。在视图栈内从上至下，或者从下之上传播。</p>

<p>可以说点事件的分发，传递以及处理。具体可以去看下touch事件这块。因为问的太抽象化了</p>

<p>严重怀疑题目出到越后面就越笼统。</p>

<h5>47.Difference between frame and bounds?</h5>

<p>frame和bounds有什么不同？</p>

<p>答案:frame指的是：该view在父view坐标系统中的位置和大小。（参照点是父亲的坐标系统）</p>

<p>bounds指的是：该view在本身坐标系统中 的位置和大小。（参照点是本身坐标系统）</p>

<h5>48.Difference between method and selector?</h5>

<p>方法和选择器有何不同？</p>

<p>答案：selector是一个方法的名字，method是一个组合体，包含了名字和实现.</p>

<p>详情可以看apple文档。</p>

<h5>49.Is there any garbage collection mechanism in Objective C.?</h5>

<p>OC的垃圾回收机制？</p>

<p>答案： OC2.0有Garbage collection，但是iOS平台不提供。</p>

<p>一般我们了解的objective-c对于内存管理都是手动操作的，但是也有自动释放池。</p>

<p>但是差了大部分资料，貌似不要和arc机制搞混就好了。</p>

<p>求更多~~</p>

<h5>50.NSOperation queue?</h5>

<p>答案：存放NSOperation的集合类。</p>

<p>操作和操作队列，基本可以看成java中的线程和线程池的概念。用于处理ios多线程开发的问题。</p>

<p>网上部分资料提到一点是，虽然是queue，但是却并不是带有队列的概念，放入的操作并非是按照严格的先进现出。</p>

<p>这边又有个疑点是，对于队列来说，先进先出的概念是Afunc添加进队列，Bfunc紧跟着也进入队列，Afunc先执行这个是必然的，</p>

<p>但是Bfunc是等Afunc完全操作完以后，B才开始启动并且执行，因此队列的概念离乱上有点违背了多线程处理这个概念。</p>

<p>但是转念一想其实可以参考银行的取票和叫号系统。</p>

<p>因此对于A比B先排队取票但是B率先执行完操作，我们亦然可以感性认为这还是一个队列。</p>

<p>但是后来看到一票关于这操作队列话题的文章，其中有一句提到</p>

<p>“因为两个操作提交的时间间隔很近，线程池中的线程，谁先启动是不定的。”</p>

<p>瞬间觉得这个queue名字有点忽悠人了，还不如pool~</p>

<p>综合一点，我们知道他可以比较大的用处在于可以帮组多线程编程就好了。</p>

<h5>51.What is lazy loading?</h5>

<p>答案：懒汉模式，只在用到的时候才去初始化。</p>

<p>也可以理解成延时加载。</p>

<p>我觉得最好也最简单的一个列子就是tableView中图片的加载显示了。</p>

<p>一个延时载，避免内存过高，一个异步加载，避免线程堵塞。</p>

<h5>52.Can we use two tableview controllers on one viewcontroller?</h5>

<p>是否在一个视图控制器中嵌入两个tableview控制器？</p>

<p>答案：一个视图控制只提供了一个View视图，理论上一个tableViewController也不能放吧，</p>

<p>只能说可以嵌入一个tableview视图。当然，题目本身也有歧义，如果不是我们定性思维认为的UIViewController，</p>

<p>而是宏观的表示视图控制者，那我们倒是可以把其看成一个视图控制者，它可以控制多个视图控制器，比如TabbarController</p>

<p>那样的感觉。</p>

<h5>53.Can we use one tableview with two different datasources? How you will achieve this?</h5>

<p>一个tableView是否可以关联两个不同的数据源？你会怎么处理？</p>

<p>答案：首先我们从代码来看，数据源如何关联上的，其实是在数据源关联的代理方法里实现的。</p>

<p>因此我们并不关心如何去关联他，他怎么关联上，方法只是让我返回根据自己的需要去设置如相关的数据源。</p>

<p>因此，我觉得可以设置多个数据源啊，但是有个问题是，你这是想干嘛呢？想让列表如何显示，不同的数据源分区块显示？</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Leo Lee</span></span>

      








  


<time datetime="2014-09-17T17:29:15+08:00" pubdate data-updated="true"></time>
      


    </p>
    
      <div class="sharing">
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2014/09/16/min-jie-kai-fa-liu-cheng-zong-jie/" title="Previous Post: 敏捷开发流程总结">&laquo; 敏捷开发流程总结</a>
      
      
        <a class="basic-alignment right" href="/blog/2014/09/17/look-up/" title="Next Post: 《抬起头吧》">《抬起头吧》 &raquo;</a>
      
    </p>
  </footer>
</article>


<!-- 添加多说 -->


  <section>
    <h1>Comments</h1>
    <div id="comments" aria-live="polite">
<!-- Duoshuo Comment BEGIN -->
<div class="ds-thread"></div>
<script type="text/javascript">
  var duoshuoQuery = {short_name:"swplzj"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script>
<!-- Duoshuo Comment END -->
</div>
  </section>


</div>

<aside class="sidebar">
  
    
  
</aside>


    </div>
  </div>
  <footer role="contentinfo">
<!-- <p>
	Copyright &copy; 2015 - Leo Lee -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p> -->


<p style="text-align:center">
  <!-- Copyright &copy; 2015 - Leo Lee - -->
  	Copyright &copy; 2015 - Leo Lee -

  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>

    <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1255930196'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1255930196%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));</script>
</p>


</footer>
  











</body>
</html>

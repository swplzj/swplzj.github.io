
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>理解 OBJECTIVE-C RUNTIME - 李振杰</title>
  <meta name="author" content="Leo Lee">

  
  <meta name="description" content="当人们初学 Cocoa/Objective-C 时，Objective-C Runtime 是被忽略的特性之一。原因是 Objective-C（这门语言）很容易在几小时内就熟悉，新学 Cocoa 的人花费他们大部分的时间学习 Cocoa 框架和适应它是如何工作的。然而每个人至少应该知道一些 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://swplzj.github.io/blog/2014/11/11/li-jie-objective-c-runtime">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="李振杰" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
 <!-- <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script> -->
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  
<!--   

 --></head>

<body    class="collapse-sidebar sidebar-footer" >
  <nav id="main-nav" role="navigation">
<ul class="main-navigation">
  <li><a href="/" class="nav-link">首页 | Blog</a></li>
  <li><a href="/blog/archives" class="nav-link">归档 | Archives</a></li>
  <li><a href="/atom.xml" class="nav-link">订阅 | RSS</a></li>
  <li><a href="/about" class="nav-link">关于我 | About</a></li>
</ul>

</nav>
  
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">理解 OBJECTIVE-C RUNTIME</h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-11-11T21:34:12+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


<div class="entry-content"><p>当人们初学 Cocoa/Objective-C 时，Objective-C Runtime 是被忽略的特性之一。原因是 Objective-C（这门语言）很容易在几小时内就熟悉，新学 Cocoa 的人花费他们大部分的时间学习 Cocoa 框架和适应它是如何工作的。然而每个人至少应该知道一些 runtime 的工作细节，需要比知道编译器会把 [target doMethodWith:var1]; 转换为 objc_msgSend(target,@selector(doMethodWith:),var1); 更深入一些。知道 Objective-C 正在做的会让你更深入的理解 Objective-C 和你正在运行的 app。我认为 Mac/iPhone 的开发者不管你现在是什么水平，都会有收获的。</p>

<!--more-->


<h4>Objective-C Runtime 是开源的</h4>

<p>Objective-C 是开源的，任何时候你都能从 <a href="http://opensource.apple.com.">http://opensource.apple.com.</a> 获取。事实上查看 Objective-C 源码是我理解它是如何工作的第一种方式，在这个问题上要比读苹果的文档要好。你可以下载适合 Mac OS X 10.6.2 的 objc4-437.1.tar.gz。（译注：最新objc4-551.1.tar.gz）</p>

<h4>动态 vs 静态语言</h4>

<p>Objective-C 是面相运行时的语言（runtime oriented language），就是说它会尽可能的把编译和链接时要执行的逻辑延迟到运行时。这就给了你很大的灵活性，你可以按需要把消息重定向给合适的对象，你甚至可以交换方法的实现，等等（译注：在 Objective-C 中调用一个对象的方法可以看成向一个对象发送消息, Method Swizzling 具体实现可以参看 jrswizzle ）。这就需要使用 runtime，runtime 可以做对象自省查看他们正在做的和不能做的（don’t respond to）并且合适的分发消息（译注：感兴趣的同学可以查看 NSObject 类的 – forwardingTargetForSelector: 和 – forwardInvocation: 方法。P.S. 不是 NSObject 协议！ ）。如果我们和 C 这样的语言对比。在 C 里，你从 main() 方法开始写然后就是从上到下的写逻辑了并按你写代码的顺序执行程序。一个 C 的结构体不能转发函数执行请求到其他的目标上（other targets）。很可能你的程序是这样的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt; stdio.h &gt;
</span><span class='line'>int main(int argc, const char **argv[])
</span><span class='line'>{        
</span><span class='line'>    printf("Hello World!");
</span><span class='line'>    return 0;
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>编译器解析，优化然后把优化后的代码转成汇编：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.text
</span><span class='line'> .align 4,0x90
</span><span class='line'> .globl _main
</span><span class='line'>_main:
</span><span class='line'>Leh_func_begin1:
</span><span class='line'> pushq %rbp
</span><span class='line'>Llabel1:
</span><span class='line'> movq %rsp, %rbp
</span><span class='line'>Llabel2:
</span><span class='line'> subq $16, %rsp
</span><span class='line'>Llabel3:
</span><span class='line'> movq %rsi, %rax
</span><span class='line'> movl %edi, %ecx 
</span><span class='line'> movl %ecx, -8(%rbp)
</span><span class='line'> movq %rax, -16(%rbp) 
</span><span class='line'> xorb %al, %al 
</span><span class='line'> leaq LC(%rip), %rcx 
</span><span class='line'> movq %rcx, %rdi 
</span><span class='line'> call _printf 
</span><span class='line'> movl $0, -4(%rbp) 
</span><span class='line'> movl -4(%rbp), %eax 
</span><span class='line'> addq $16, %rsp 
</span><span class='line'> popq %rbp 
</span><span class='line'> ret
</span><span class='line'>Leh_func_end1: 
</span><span class='line'> .cstring
</span><span class='line'>LC: 
</span><span class='line'> .asciz "Hello World!"</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>然后链接库并生成可执行程序（译注：如果你对 C 的编译链接过程还不熟悉可以参看 Deep C and C++）。要和 Objective-C 对比的话，处理过程很相似，生成的代码依赖于是否有 Objective-C Runtime 库。当刚学 Objective-C 时，我们最先了解的(最简单的那种)是 Objective-C 中用括号包起来的代码像这样…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[self doSomethingWithVar:var1];</span></code></pre></td></tr></table></div></figure>


<p>被转换为…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>objc_msgSend(self,@selector(doSomethingWithVar:),var1);</span></code></pre></td></tr></table></div></figure>


<p>但除了这些，我们就不知道之后在运行时做了什么了。</p>

<h4>Objective-C Runtime 是什么？</h4>

<p>Objective-C 的 Runtime 是一个运行时库（Runtime Library），它是一个主要使用 C 和汇编写的库，为 C 添加了面相对象的能力并创造了 Objective-C。这就是说它在类信息（Class information） 中被加载，完成所有的方法分发，方法转发，等等。Objective-C runtime 创建了所有需要的结构体，让 Objective-C 的面相对象编程变为可能。</p>

<h4>Objective-C Runtime 术语</h4>

<p>更深入之前，咱们先了解点术语。Mac 和 iPhone 开发者关心的有两个 runtime：Modern Runtime（现代的 Runtime） 和 Legacy Runtime（过时的 Runtime）。Modern Runtime：覆盖所有 64 位的 Mac OS X 应用和所有 iPhone OS 的应用。 Legacy Runtime: 覆盖其他的所有应用（所有 32 位的 Mac OS X 应用） Method 有 2 种基本类型的方法。Instance Method（实例方法）：以 ‘-’ 开始，比如 -(void)doFoo; 在对象实例上操作。Class Method（类方法）：以 ‘+’ 开始，比如 +(id)alloc。方法（Methods）和 C 的函数很像，是一组代码，执行一个小的任务，如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (NSString *)movieTitle
</span><span class='line'>{
</span><span class='line'>    return @"Futurama: Into the Wild Green Yonder";
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Selector 在 Objective-C 中 selector 只是一个 C 的数据结构，用于表示一个你想在一个对象上执行的 Objective-C 方法。在 runtime 中的定义像这样…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef struct objc_selector  *SEL; </span></code></pre></td></tr></table></div></figure>


<p>像这样使用…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SEL aSel = @selector(movieTitle); </span></code></pre></td></tr></table></div></figure>


<h4>Message（消息）</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[target getMovieTitleForObject:obj];</span></code></pre></td></tr></table></div></figure>


<p>消息是方括号 ‘[]’ 中的那部分，由你要向其发送消息的对象（target），你想要在上面执行的方法（method）还有你发送的参数（arguments）组成。Objective-C 的消息和 C 函数调用是不同的。事实上，你向一个对象发送消息并不意味着它会执行它。Object（对象）会检查消息的发送者，基于这点再决定是执行一个不同的方法还是转发消息到另一个目标对象上。Class 如果你查看一个类的runtime信息，你会看到这个…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef struct objc_class *Class;
</span><span class='line'>typedef struct objc_object {
</span><span class='line'>    Class isa;
</span><span class='line'>} *id; </span></code></pre></td></tr></table></div></figure>


<p>这里有几个事情。我们有一个 Objective-C 类的结构体和一个对象的结构体。objc_object 只有一个指向类的 isa 指针，就是我们说的术语 “isa pointer”（isa 指针）。这个 isa 指针是当你向对象发送消息时，Objective-C Runtime 检查一个对象并且查看它的类是什么然后开始查看它是否响应这些 selectors 所需要的一切。最后我么看到了 id 指针。默认情况下 id 指针除了告诉我们它们是 Objective-C 对象外没有其他用了。当你有一个 id 指针，然后你就可以问这个对象是什么类的，看看它是否响应一个方法，等等，然后你就可以在知道这个指针指向的是什么对象后执行更多的操作了。你可以在 LLVM/Clang 的文档中的 Block 中看到</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Block_literal_1 {
</span><span class='line'>    void *isa; // initialized to &_NSConcreteStackBlock or &_NSConcreteGlobalBlock    
</span><span class='line'>    int flags;    
</span><span class='line'>    int reserved;     
</span><span class='line'>    void (*invoke)(void *, ...); 
</span><span class='line'>    struct Block_descriptor_1 { 
</span><span class='line'>        unsigned long int reserved; // NULL     
</span><span class='line'>        unsigned long int size;  // sizeof(struct Block_literal_1)
</span><span class='line'>        // optional helper functions     
</span><span class='line'>        void (*copy_helper)(void *dst, void *src);
</span><span class='line'>        void (*dispose_helper)(void *src);     
</span><span class='line'>    } *descriptor;    
</span><span class='line'>    // imported variables
</span><span class='line'>}; </span></code></pre></td></tr></table></div></figure>


<p>Blocks 被设计为兼容 Objective-C 的 runtime，所以他们被作为对象对待，因此他们可以响应消息，比如 -retain，-release，-copy ，等等。IMP（方法实现 MethodImplementations）</p>

<p>typedef id (*IMP)(id self,SEL _cmd,&hellip;);
IMP 是指向方法实现的函数指针，由编译器为你生成。如果你新接触 Objective-C 你现在不需要直接接触这些，但是我们将会看到，Objective-C runtime 将如何调用你的方法的。Objective-C Classes（Objective-C 类） 那么什么是 Objective-C 类？在 Objective-C 中的一个类实现看起来像这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface MyClass : NSObject {
</span><span class='line'>    // vars
</span><span class='line'>    NSInteger counter;
</span><span class='line'>}
</span><span class='line'>// methods
</span><span class='line'>-(void)doFoo;
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>//但是 runtime 不只要追踪这些
</span><span class='line'>
</span><span class='line'>#if !__OBJC2__   
</span><span class='line'>    Class super_class                        OBJC2_UNAVAILABLE;
</span><span class='line'>    const char *name                         OBJC2_UNAVAILABLE;
</span><span class='line'>    long version                             OBJC2_UNAVAILABLE;
</span><span class='line'>    long info                                OBJC2_UNAVAILABLE;
</span><span class='line'>    long instance_size                       OBJC2_UNAVAILABLE;    
</span><span class='line'>    struct objc_ivar_list *ivars             OBJC2_UNAVAILABLE;    
</span><span class='line'>    struct objc_method_list **methodLists    OBJC2_UNAVAILABLE;    
</span><span class='line'>    struct objc_cache *cache                 OBJC2_UNAVAILABLE;    
</span><span class='line'>    struct objc_protocol_*protocols          OBJC2_UNAVAILABLE;
</span><span class='line'>#endif </span></code></pre></td></tr></table></div></figure>


<p>我们可以看到，一个类有其父类的引用，它的名字，实例变量，方法，缓存还有它遵循的协议。runtime 在响应类或实例的方法时需要这些信息。</p>

<h4>那么 Class 定义的是对象还是对象本身？它是如何实现的 （译注：读者需要区分 Class 和 class 是不同的，正如 Nil 和 nil 的用途是不同的）</h4>

<p>是的，之前我说过 Objective-C 类也是对象，runtime 通过创建 Meta Classes 来处理这些。当你发送一个消息像这样 [NSObject alloc] 你正在向类对象发送一个消息，这个类对象需要是 MetaClass 的实例，MetaClass 也是 root meta class 的实例。当你说继承自 NSObject 时，你的类指向 NSObject 作为自己的 superclass。然而，所有的 meta class 指向 root metaclass 作为自己的 superclass。所有的 meta class 只是简单的有一个自己响应的方法列表。所以当你向一个类对象发送消息如 [NSObject alloc]，然后实际上 objc_msgSend() 会检查 meta class 看看它是否响应这个方法，如果他找到了一个方法，就在这个 Class 对象上执行（译注：class 是一个实例对象的类型，Class 是一个类（class）的类型。对于完全的 OO 来说，类也是个对象，类是类类型(MetaClass)的实例，所以类的类型描述就是 meta class）。</p>

<h4>为什么我们继承自苹果的类</h4>

<p>从你开始 Cocoa 开发时，那些教程就说如继承自 NSObject 然后开始写一些代码，你享受了很多继承自苹果的类所带来的便利。有一件事你从未意识到的是你的对象被设置为使用 Objective-C 的 runtime。当我们为我们的类的一个实例分配了内存，像这样…</p>

<p>MyObject *object = [[MyObject alloc] init];
最先执行的消息是 +alloc。如果你查看下文档，它说“新的实例对象的 isa 实例变量被初始化为指向一个数据结构，那个数据结构描述了这个类；其他的实例变量被初始化为 0。”所以继承自苹果的类不仅仅是继承了一些重要的属性，也继承了能在内存中轻松分配内存的能力和在内存中创建满足 runtime 期望的对象结构（设置 isa 指针指向我们的类）。</p>

<h4>那么 Class Cache 是什么？（objc_cache *cache）</h4>

<p>当 Objective-C runtime 沿着一个对象的 isa 指针检查时，它会发现一个对象实现了许多的方法。然而你可能只调用其中一小部分的方法，也没有意义每次检查时搜索这个类的分发表（dispatch table）中的所有 selector。所以这个类实现了一个缓存，当你搜索一个类的分发表，并找到合适的 selector 后，就会把它放进缓存中。所以当 objc_msgSend() 在一个类中查找 selector 时会先查找类缓存。有个理论是，当你在一个类上调用了一个消息，你很可能之后还会调用它。所以如果我们考虑到这点，就意味着当我们有个子类继承自 NSObject 叫做 MyObject 并且运行了以下的代码</p>

<p>MyObject *obj = [[MyObject alloc] init];</p>

<p>@implementation MyObject
- (id)init {
    if(self = [super init]) {
        [self setVarA:@”blah”];  <br/>
    }
    return self;
}
@end
发生了以下的事：</p>

<p>(1) [MyObject alloc] 首先被执行。MyObject 没有实现 alloc 方法，所以我们不能在这个类中找到 +alloc 方法，然后沿着 superclass 指针会指向 NSObject。</p>

<p>(2) 我们询问 NSObject 是否响应 +alloc 方法，它可以。+alloc 检查消息的接收者类，是 MyObject，然后分配一块和我们的类同样大小的内存空间，并初始化它的 isa 指针指向 MyObject 类，我们现在有了一个实例对象，最终把类对象的 +alloc 方法加入 NSObject 的类缓存（class cache）中（lastly we put +alloc in NSObject’s class cache for the class object ）。</p>

<p>(3) 到现在为止，我们发送了一个类消息，但是现在我们发送一个实例消息，只是简单的调用 -init 或者我们设计的初始化方法。当然，我们的类会响应这个方法，所以 -(id)init 加入到缓存中。（译注：要是 MyObject 实现了 init 方法，就会把 init 方法加入到 MyObject 的 class cache 中，要是没有实现，只是因为继承才有了这个方法，init 方法还是会加入到 NSObject 的 class cache 中）。</p>

<p>(4) 然后 self = [super init] 被调用。super 是个 magic keyword，指向对象的父类，所以我们得到了 NSObject 并调用它的的 init 方法。这样可以确保 OOP（面相对象编程） 的继承功能正常，这个方法可以正确的初始化父类的变量，之后你（在子类中）可以初始化自己的变量，如果需要可以覆盖父类的方法。在 NSObject 的例子中，没什么重要的要做，但并不总是这样。有时要做些重要的初始化。比如…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import &lt;Foundation/Foundation.h&gt; 
</span><span class='line'>
</span><span class='line'>@interface MyObject : NSObject {
</span><span class='line'>    NSString *aString;
</span><span class='line'>} 
</span><span class='line'>    @property(retain) NSString *aString; 
</span><span class='line'>
</span><span class='line'>@end 
</span><span class='line'>
</span><span class='line'>@implementation MyObject
</span><span class='line'>
</span><span class='line'>-(id)init 
</span><span class='line'>{ 
</span><span class='line'>    if (self = [super init]) {
</span><span class='line'>        [self setAString:nil];
</span><span class='line'>    }
</span><span class='line'>    return self;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@synthesize aString;
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>int main (int argc, const char * argv[]) 
</span><span class='line'>{
</span><span class='line'>    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
</span><span class='line'>
</span><span class='line'>    id obj1 = [NSMutableArray alloc]; 
</span><span class='line'>    id obj2 = [[NSMutableArray alloc] init];   
</span><span class='line'>    id obj3 = [NSArray alloc]; 
</span><span class='line'>    id obj4 = [[NSArray alloc] initWithObjects:@"Hello",nil];
</span><span class='line'>
</span><span class='line'>    NSLog(@"obj1 class is %@",NSStringFromClass([obj1 class]));
</span><span class='line'>    NSLog(@"obj2 class is %@",NSStringFromClass([obj2 class]));
</span><span class='line'>    NSLog(@"obj3 class is %@",NSStringFromClass([obj3 class]));
</span><span class='line'>    NSLog(@"obj4 class is %@",NSStringFromClass([obj4 class]));
</span><span class='line'>
</span><span class='line'>    id obj5 = [MyObject alloc]; 
</span><span class='line'>    id obj6 = [[MyObject alloc] init];   
</span><span class='line'>
</span><span class='line'>    NSLog(@"obj5 class is %@",NSStringFromClass([obj5 class]));    
</span><span class='line'>    NSLog(@"obj6 class is %@",NSStringFromClass([obj6 class]));   
</span><span class='line'>
</span><span class='line'>    [pool drain];
</span><span class='line'>    return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>现在如果你新接触 Cocoa ，我让你猜会会输出什么，你可能会说</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSMutableArray
</span><span class='line'>NSMutableArray 
</span><span class='line'>NSArray
</span><span class='line'>NSArray
</span><span class='line'>MyObject
</span><span class='line'>MyObject</span></code></pre></td></tr></table></div></figure>


<p>但是，实际上是</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>obj1 class is __NSPlaceholderArray
</span><span class='line'>obj2 class is NSCFArray
</span><span class='line'>obj3 class is __NSPlaceholderArray
</span><span class='line'>obj4 class is NSCFArray
</span><span class='line'>obj5 class is MyObject
</span><span class='line'>obj6 class is MyObject</span></code></pre></td></tr></table></div></figure>


<p>这是因为在 Objective-C 中 +alloc 方法可能会返回某个类的对象，然后在 -init 中返回另一个类的对象。
（译注：感兴趣的同学可以看下这两篇文章：Class Clusters, Make Your Own Abstract Factory Class Cluster in Objective-C, 第二篇文章需要自备小梯子。)</p>

<h4>那么在 objc_msgSend 中发生了什么？</h4>

<p>事实上在 objc_msgSend() 中发生了许多事儿。假设我们有这样的代码…</p>

<p>[self printMessageWithString:@&ldquo;Hello World!&rdquo;];
它实际上会被编译器翻译为…</p>

<p>objc_msgSend(self,@selector(printMessageWithString:),@&ldquo;Hello World!&rdquo;);
我们沿着目标对象的 isa 指针查找，看看是否这个对象响应 @selector(printMessageWithString:) selector。假设我们在类的分发表或者缓存中找到了这个 selector，我们沿着函数指针并且执行它。这样 objcmsgSend() 就永远不会返回，它开始执行，然后沿着指向方法的指针，然后你的方法返回，这样看起来 objcmsgSend() 方法返回了。Bill Bumgarner 比我讲了更多 objc_msgSend() 的细节（部分1，部分2 和 部分3）。</p>

<p>概括下他说的，并且你已经看过了 Objective-C 的 runtime 代码…</p>

<p>检查忽略的 Selector 和短路（Short Circut）—— 显然，如果我们运行在垃圾回收机制下，我们可以忽略调用 -retain, -release, 等等。
检查 nil 对象（target）。和其他的语言不一样的是，在 Objective-C 中向 nil 发送消息是完全合法的，并且有些原因下你会愿意这么做的。假设我们有个非 nil 的对象，然后我们继续…
然后我们需要在这个类上找到 IMP，所以我们先从 class cache 中找起，如果找到了就沿着指针跳到这个函数。
如果没有在缓存中找到 IMP，然后去查找类的分发表，如果找到了，就沿着指针跳到这个函数。
如果 IMP 没有在缓存和类的分发表中找到，然后我们跳到转发机制。这意味着最终你的代码被编译器转换为 C 函数。你写的方法会像这样…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-(int)doComputeWithNum:(int)aNum </span></code></pre></td></tr></table></div></figure>


<p>会被翻译为…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int aClass_doComputeWithNum(aClass *self,SEL _cmd,int aNum) </span></code></pre></td></tr></table></div></figure>


<p>Objective-C Runtime 通过调用（invoking）指向这些方法的函数指针调用你的方法（call your methods）。现在，我要说的是，你不能直接调用这些被翻译的方法，但是 Cocoa 框架提供了获得函数指针的方法…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//declare C function pointer
</span><span class='line'>int (computeNum *)(id,SEL,int);
</span><span class='line'>
</span><span class='line'>//methodForSelector is COCOA & not ObjC Runtime
</span><span class='line'>//gets the same function pointer objc_msgSend gets
</span><span class='line'>computeNum = (int (*)(id,SEL,int))[target methodForSelector:@selector(    doComputeWithNum:)]; 
</span><span class='line'>
</span><span class='line'>//execute the C function pointer returned by the runtime
</span><span class='line'>computeNum(obj,@selector(doComputeWithNum:),aNum); </span></code></pre></td></tr></table></div></figure>


<p>通过这种方法，你可以直接访问这个函数，并且可以在运行时直接调用，甚至可以使用这个避开 runtime 的动态特性，如果你绝对需要确保一个方法被执行。Objective-C 就是用这种途径去调用你的方法的，但是使用的是 objc_msgSend()。</p>

<h4>Objective-C 消息转发</h4>

<p>在 Objective-C 中向一个不知道如何响应这个方法的对象发送消息是完全合法的（甚至可能是一种潜在的设计决定）。苹果的文档中给出的一个原因是模拟多继承，Objective-C 不是原生支持的，或者你可能只是想抽象你的设计并且隐藏幕后处理这些消息的其他对象/类。这一点是 runtime 非常需要的。它是这样做的 1. Runtime 检查了你的类和所有父类的 class cache 和分发表，但是没找到指定的方法。2. Objective_C 的 Runtime 会在你的类上调用 + (BOOL) resolveInstanceMethod:(SEL)aSEL。 这就给了你一个机会去提供一个方法实现并且告诉 runtime 你已经解析了这个方法，如果它开始查找，这回就会找到这个方法。你可以像这样实现…定义一个函数…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void fooMethod(id obj, SEL _cmd)
</span><span class='line'>{ 
</span><span class='line'>    NSLog(@"Doing Foo");
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后你可以像这样使用 class_addMethod() 解析它…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+(BOOL)resolveInstanceMethod:(SEL)aSEL
</span><span class='line'>{
</span><span class='line'>    if(aSEL == @selector(doFoo:))
</span><span class='line'>    {
</span><span class='line'>            class_addMethod([self class],aSEL,(IMP)fooMethod,"v@:");
</span><span class='line'>            return YES;
</span><span class='line'>    }
</span><span class='line'>    return [super resolveInstanceMethod];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在 class_addMethod() 最后一部分的 “v@:” 是方法的返回和参数类型。你可以在 Runtime Guide 的 Type Encoding 章节看到完整介绍。 3. Runtime 然后调用 – (id)forwardingTargetForSelector:(SEL)aSelector。这样做是为了给你一次机会（因为我们不能解析这个方法（参见上面的 #2））引导 Objective-C runtime 到另一个可以响应这个消息的对象上，在花费昂贵的处理过程调用 – (void)forwardInvocation:(NSInvocation *)anInvocation 之前调用这个方法也是更好的。你可以像这样实现</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (id)forwardingTargetForSelector:(SEL)aSelector
</span><span class='line'>{
</span><span class='line'>    if(aSelector == @selector(mysteriousMethod:))
</span><span class='line'>    {        
</span><span class='line'>        return alternateObject;
</span><span class='line'>    }
</span><span class='line'>    return [super forwardingTargetForSelector:aSelector];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>显然你不想从这个方法直接返回 self，否则可能会产生一个死循环。 4. Runtime 最后一次会尝试在目标对象上调用 – (void)forwardInvocation:(NSInvocation *)anInvocation。如果你从没看过 NSInvocation，它是 Objective-C 消息的对象形式。一旦你有了一个 NSInvocation 你可以改变这个消息的一切，包括目标对象，selector 和参数。所以你可以这样做…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-(void)forwardInvocation:(NSInvocation *)invocation
</span><span class='line'>{  
</span><span class='line'>    SEL invSEL = invocation.selector;    
</span><span class='line'>    if([altObject respondsToSelector:invSEL]) {        
</span><span class='line'>        [invocation invokeWithTarget:altObject];    
</span><span class='line'>    } else {        
</span><span class='line'>        [self doesNotRecognizeSelector:invSEL];    
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如果你继承自 NSObject，默认它的 – (void)forwardInvocation:(NSInvocation *)anInvocation 实现只是简单的调用 -doesNotRecognizeSelector:，你可以在最后一次机会里覆盖这个方法去做一些事情。（译注：对这块内容有兴趣的同学可以参见：<a href="http://www.cnblogs.com/biosli/p/NSObjectinherit2.html%EF%BC%89">http://www.cnblogs.com/biosli/p/NSObjectinherit2.html%EF%BC%89</a></p>

<h4>Non Fragile ivars（Modern Runtime）（非脆弱的 ivar）</h4>

<p>我们最近在 Modern Runtime 里得到的是 Non Fragile ivars 的概念。当编译你的类时，编译器生成了一个 ivar 布局，显示了在你的类中从哪可以访问你的 ivars，获取指向你的对象的指针，查看 ivar 与对象起始字节的偏移关系，和获取读入的变量类型的总共字节大小等一些底层的细节。所以你的 ivar 布局可能看起来像这样，左侧的数字是字节偏移量。</p>

<p>我们有了 NSObject 的 ivar 布局，然后我们继承自 NSObject 去扩展它并且添加了我们自己的 ivars。在苹果发布更新前这都工作的很好，但是 Mac OS X 10.6 发布后，就成了这样</p>

<p>你的自定义对象被剔除了因为我们有了一个重叠的父类。唯一可以防止这个的办法是如果苹果坚持之前的布局，如果他们这么做了，那么他们的框架就不能改进，因为他们的 ivar 布局被冻住了。在 fragile ivar 下你不得不重新编译你继承自苹果类的类来恢复兼容性。所以在非 fragile ivar 时，会发生生么？</p>

<p>使用非 fragile ivars 时，编译器生成和 fragile ivars 相同的 ivar 布局。然而当 runtime 检测到一个重叠的超类时，它调整你在这个类中新增的 ivar 的偏移量，这样在子类中新增加的那部分就显示出来了。</p>

<h4>Objective-C 关联对象</h4>

<p>最近在 Mac OS X 10.6 雪豹 中新引入了关联引用。Objective-C 不能动态的添加一些属性到对象上，和其他的一些原生支持这点的语言不一样。所以之前你都不得不努力为未来要增加的变量预留好空间。在 Mac OS X 10.6 中，Objective-C 的 Runtime 已经原生的支持这个功能了。如果我们想向一个已有的类添加变量，看起来像这样…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import &lt;Cocoa/Cocoa.h&gt; //Cocoa
</span><span class='line'>#include &lt;objc/runtime.h&gt; //objc runtime api’s 
</span><span class='line'>
</span><span class='line'>@interface NSView (CustomAdditions)
</span><span class='line'>@property(retain) NSImage *customImage;
</span><span class='line'>@end 
</span><span class='line'>
</span><span class='line'>@implementation NSView (CustomAdditions) 
</span><span class='line'>
</span><span class='line'>static char img_key; //has a unique address (identifier)
</span><span class='line'>
</span><span class='line'>- (NSImage *)customImage
</span><span class='line'>{    
</span><span class='line'>    return objc_getAssociatedObject(self,&img_key);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)setCustomImage:(NSImage *)image
</span><span class='line'>{    
</span><span class='line'>    objc_setAssociatedObject(self, &img_key,image, OBJC_ASSOCIATION_RETAIN);
</span><span class='line'>} 
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>objc_setAssociatedObject() 的选项，你可以在 runtime.h 文件中找到。
</span><span class='line'>
</span><span class='line'>/* Associated Object support. */ 
</span><span class='line'>
</span><span class='line'>/* objc_setAssociatedObject() options */
</span><span class='line'>enum {    
</span><span class='line'>    OBJC_ASSOCIATION_ASSIGN = 0,    
</span><span class='line'>    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1,    
</span><span class='line'>    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,    
</span><span class='line'>    OBJC_ASSOCIATION_RETAIN = 01401,    
</span><span class='line'>    OBJC_ASSOCIATION_COPY = 01403
</span><span class='line'>}; </span></code></pre></td></tr></table></div></figure>


<p>这些和 @property 语法中的选项意思一样。</p>

<h4>混和的 vTable Dispatch</h4>

<p>如果你看过 modern runtime 的代码，你会发现这个（在 objc-runtime-new.m 中）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/***********************************************************************
</span><span class='line'>* vtable dispatch
</span><span class='line'>* 
</span><span class='line'>* Every class gets a vtable pointer. The vtable is an array of IMPs.
</span><span class='line'>* The selectors represented in the vtable are the same for all classes
</span><span class='line'>*   (i.e. no class has a bigger or smaller vtable).
</span><span class='line'>* Each vtable index has an associated trampoline which dispatches to 
</span><span class='line'>*   the IMP at that index for the receiver class's vtable (after 
</span><span class='line'>*   checking for NULL). Dispatch fixup uses these trampolines instead 
</span><span class='line'>*   of objc_msgSend.
</span><span class='line'>* Fragility: The vtable size and list of selectors is chosen at launch 
</span><span class='line'>*   time. No compiler-generated code depends on any particular vtable 
</span><span class='line'>*   configuration, or even the use of vtable dispatch at all.
</span><span class='line'>* Memory size: If a class's vtable is identical to its superclass's 
</span><span class='line'>*   (i.e. the class overrides none of the vtable selectors), then 
</span><span class='line'>*   the class points directly to its superclass's vtable. This means 
</span><span class='line'>*   selectors to be included in the vtable should be chosen so they are 
</span><span class='line'>*   (1) frequently called, but (2) not too frequently overridden. In 
</span><span class='line'>*   particular, -dealloc is a bad choice.
</span><span class='line'>* Forwarding: If a class doesn't implement some vtable selector, that 
</span><span class='line'>*   selector's IMP is set to objc_msgSend in that class's vtable.
</span><span class='line'>* +initialize: Each class keeps the default vtable (which always 
</span><span class='line'>*   redirects to objc_msgSend) until its +initialize is completed.
</span><span class='line'>*   Otherwise, the first message to a class could be a vtable dispatch, 
</span><span class='line'>*   and the vtable trampoline doesn't include +initialize checking.
</span><span class='line'>* Changes: Categories, addMethod, and setImplementation all force vtable 
</span><span class='line'>*   reconstruction for the class and all of its subclasses, if the 
</span><span class='line'>*   vtable selectors are affected.
</span><span class='line'>**********************************************************************/ </span></code></pre></td></tr></table></div></figure>


<p>背后的思想是，runtime 尝试在这个 vtable 中存储最近被调用的 selectors，这样就可以提升你的应用的速度，因为它使用了比 objc_msgSend 更少的指令（fewer instructions）。vtable 中保存 16 个全局最经常调用的 selectors，事实上顺着代码往下看你可以发现垃圾回收和非垃圾回收类型程序的默认 selectors …</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Leo Lee</span></span>

      








  


<time datetime="2014-11-11T21:34:12+08:00" pubdate data-updated="true"></time>
      


    </p>
    
      <div class="sharing">
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2014/10/25/yi-dong-app-jia-gou-she-ji/" title="Previous Post: 移动App架构设计">&laquo; 移动App架构设计</a>
      
      
        <a class="basic-alignment right" href="/blog/2014/11/14/you-xiu-kai-yuan-xiang-mu-facebook-paper-dong-hua-yin-qing-pop/" title="Next Post: 优秀开源项目：FACEBOOK PAPER动画引擎 – POP">优秀开源项目：FACEBOOK PAPER动画引擎 – POP &raquo;</a>
      
    </p>
  </footer>
</article>


<!-- 添加多说 -->


  <section>
    <h1>Comments</h1>
    <div id="comments" aria-live="polite">
<!-- Duoshuo Comment BEGIN -->
<div class="ds-thread"></div>
<script type="text/javascript">
  var duoshuoQuery = {short_name:"swplzj"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script>
<!-- Duoshuo Comment END -->
</div>
  </section>


</div>

<aside class="sidebar">
  
    
  
</aside>


    </div>
  </div>
  <footer role="contentinfo">
<!-- <p>
	Copyright &copy; 2015 - Leo Lee -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p> -->


<p style="text-align:center">
  <!-- Copyright &copy; 2015 - Leo Lee - -->
  	Copyright &copy; 2015 - Leo Lee -

  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>

    <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1255930196'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1255930196%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));</script>
</p>


</footer>
  











</body>
</html>
